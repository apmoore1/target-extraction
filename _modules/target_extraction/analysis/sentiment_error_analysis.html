

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>target_extraction.analysis.sentiment_error_analysis &mdash; Target Extraction 0.0.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> Target Extraction
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <!-- Local TOC -->
              <div class="local-toc"></div>
            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Target Extraction</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>target_extraction.analysis.sentiment_error_analysis</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for target_extraction.analysis.sentiment_error_analysis</h1><div class="highlight"><pre>
<span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">This module is dedicated to creating new TargetTextCollections that are </span>
<span class="sd">subsamples of the original(s) that will allow the user to analysis the </span>
<span class="sd">data with respect to some certain property.</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span><span class="p">,</span> <span class="n">Counter</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Iterable</span>
<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Pool</span>
<span class="kn">import</span> <span class="nn">math</span>

<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="kn">from</span> <span class="nn">target_extraction.data_types</span> <span class="kn">import</span> <span class="n">TargetTextCollection</span><span class="p">,</span> <span class="n">TargetText</span>

<span class="n">PLOT_SUBSET_ABBREVIATION</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;distinct_sentiment_1&#39;</span> <span class="p">:</span> <span class="s1">&#39;DS1&#39;</span><span class="p">,</span> 
                            <span class="s1">&#39;distinct_sentiment_2&#39;</span><span class="p">:</span> <span class="s1">&#39;DS2&#39;</span><span class="p">,</span> 
                            <span class="s1">&#39;distinct_sentiment_3&#39;</span><span class="p">:</span> <span class="s1">&#39;DS3&#39;</span><span class="p">,</span>
                            <span class="s1">&#39;1-target&#39;</span><span class="p">:</span> <span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;low-targets&#39;</span><span class="p">:</span> <span class="s1">&#39;Low&#39;</span><span class="p">,</span> 
                            <span class="s1">&#39;med-targets&#39;</span><span class="p">:</span> <span class="s1">&#39;Med&#39;</span><span class="p">,</span> <span class="s1">&#39;high-targets&#39;</span><span class="p">:</span> <span class="s1">&#39;High&#39;</span><span class="p">,</span>
                            <span class="s1">&#39;1-TSSR&#39;</span><span class="p">:</span> <span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;1-multi-TSSR&#39;</span><span class="p">:</span> <span class="s1">&#39;1-Multi&#39;</span><span class="p">,</span> 
                            <span class="s1">&#39;low-TSSR&#39;</span><span class="p">:</span> <span class="s1">&#39;Low&#39;</span><span class="p">,</span> <span class="s1">&#39;high-TSSR&#39;</span><span class="p">:</span> <span class="s1">&#39;High&#39;</span><span class="p">,</span>
                            <span class="s1">&#39;unknown_sentiment_known_target&#39;</span><span class="p">:</span> <span class="s1">&#39;USKT&#39;</span><span class="p">,</span> 
                            <span class="s1">&#39;unknown_targets&#39;</span><span class="p">:</span> <span class="s1">&#39;UT&#39;</span><span class="p">,</span> 
                            <span class="s1">&#39;known_sentiment_known_target&#39;</span><span class="p">:</span> <span class="s1">&#39;KSKT&#39;</span><span class="p">,</span>
                            <span class="s1">&#39;zero-shot&#39;</span><span class="p">:</span> <span class="s1">&#39;Zero&#39;</span><span class="p">,</span> <span class="s1">&#39;low-shot&#39;</span><span class="p">:</span> <span class="s1">&#39;Low&#39;</span><span class="p">,</span> 
                            <span class="s1">&#39;med-shot&#39;</span><span class="p">:</span> <span class="s1">&#39;Med&#39;</span><span class="p">,</span> <span class="s1">&#39;high-shot&#39;</span><span class="p">:</span> <span class="s1">&#39;High&#39;</span><span class="p">}</span>

<span class="n">ERROR_SPLIT_SUBSET_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;DS&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;distinct_sentiment_1&#39;</span><span class="p">,</span> <span class="s1">&#39;distinct_sentiment_2&#39;</span><span class="p">,</span> 
                                   <span class="s1">&#39;distinct_sentiment_3&#39;</span><span class="p">],</span>
                            <span class="s1">&#39;NT&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;1-target&#39;</span><span class="p">,</span> <span class="s1">&#39;low-targets&#39;</span><span class="p">,</span> <span class="s1">&#39;med-targets&#39;</span><span class="p">,</span> 
                                   <span class="s1">&#39;high-targets&#39;</span><span class="p">],</span>
                            <span class="s1">&#39;TSSR&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;1-TSSR&#39;</span><span class="p">,</span> <span class="s1">&#39;1-multi-TSSR&#39;</span><span class="p">,</span> <span class="s1">&#39;low-TSSR&#39;</span><span class="p">,</span> 
                                     <span class="s1">&#39;high-TSSR&#39;</span><span class="p">],</span>
                            <span class="s1">&#39;TSR&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;unknown_sentiment_known_target&#39;</span><span class="p">,</span> 
                                    <span class="s1">&#39;unknown_targets&#39;</span><span class="p">,</span> 
                                    <span class="s1">&#39;known_sentiment_known_target&#39;</span><span class="p">],</span>
                            <span class="s1">&#39;n-shot&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;zero-shot&#39;</span><span class="p">,</span> <span class="s1">&#39;low-shot&#39;</span><span class="p">,</span> 
                                       <span class="s1">&#39;med-shot&#39;</span><span class="p">,</span> <span class="s1">&#39;high-shot&#39;</span><span class="p">]}</span>
<span class="n">SUBSET_NAMES_ERROR_SPLIT</span> <span class="o">=</span> <span class="p">{}</span>

<div class="viewcode-block" id="NoSamplesError"><a class="viewcode-back" href="../../../target_extraction.analysis.html#target_extraction.analysis.sentiment_error_analysis.NoSamplesError">[docs]</a><span class="k">class</span> <span class="nc">NoSamplesError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
   <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">   If there are or will be no samples within a Dataset or subset.</span>
<span class="sd">   &#39;&#39;&#39;</span>
   <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">error_string</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        :param error_string: Error string to generate on Error</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">error_string</span><span class="p">)</span></div>

<div class="viewcode-block" id="count_error_key_occurrence"><a class="viewcode-back" href="../../../target_extraction.analysis.html#target_extraction.analysis.sentiment_error_analysis.count_error_key_occurrence">[docs]</a><span class="k">def</span> <span class="nf">count_error_key_occurrence</span><span class="p">(</span><span class="n">dataset</span><span class="p">:</span> <span class="n">TargetTextCollection</span><span class="p">,</span> 
                               <span class="n">error_key</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    :param dataset: The dataset that contains error analysis key which are </span>
<span class="sd">                    one hot encoding of whether a target is in that </span>
<span class="sd">                    error analysis class or not. Example function that </span>
<span class="sd">                    produces these error keys are </span>
<span class="sd">                    :func:`target_extraction.error_analysis.same_one_sentiment`</span>
<span class="sd">    :param error_key: Name of the error key e.g. `same_one_sentiment`</span>
<span class="sd">    :returns: The number of targets within the dataset that are in that error</span>
<span class="sd">              class.</span>
<span class="sd">    :raises KeyError: If the `error_key` does not exist in one or more of the </span>
<span class="sd">                      TargetText objects within the `dataset`</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">target_data</span> <span class="ow">in</span> <span class="n">dataset</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="c1"># Will raise a key error if the TargetText object does not have that </span>
        <span class="c1"># error_key</span>
        <span class="n">target_data</span><span class="o">.</span><span class="n">_key_error</span><span class="p">(</span><span class="n">error_key</span><span class="p">)</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">target_data</span><span class="p">[</span><span class="n">error_key</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">count</span></div>

<div class="viewcode-block" id="reduce_collection_by_sentiment_class"><a class="viewcode-back" href="../../../target_extraction.analysis.html#target_extraction.analysis.sentiment_error_analysis.reduce_collection_by_sentiment_class">[docs]</a><span class="k">def</span> <span class="nf">reduce_collection_by_sentiment_class</span><span class="p">(</span><span class="n">dataset</span><span class="p">:</span> <span class="n">TargetTextCollection</span><span class="p">,</span>
                                         <span class="n">reduce_sentiment</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                                         <span class="n">associated_keys</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
                                         <span class="n">sentiment_key</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;target_sentiments&#39;</span>
                                         <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TargetTextCollection</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    :param dataset: The dataset that is to be reduced so that it only contains</span>
<span class="sd">                    the given sentiment class.</span>
<span class="sd">    :param reduce_sentiment: The sentiment class that the target must be associated </span>
<span class="sd">                             with to be returned in this TargetTextCollection.</span>
<span class="sd">    :param associated_keys: The keys that are associated to the target that </span>
<span class="sd">                            must be kept and are linked to that target. E.g. </span>
<span class="sd">                            `target_sentiments`, `targets`, `spans`, and </span>
<span class="sd">                            `subset error keys`.</span>
<span class="sd">    :param sentiment_key: The key in the TargetText samples within the collection</span>
<span class="sd">                          that contains the sentiment values to reduce by.</span>
<span class="sd">    :returns: A new TargetTextCollection that contains only those targets and </span>
<span class="sd">              relevant `associated_keys` within the TargetText&#39;s that contains</span>
<span class="sd">              the given sentiment.</span>
<span class="sd">    :raises KeyError: If the `error_key` or one or more of the `associated_keys` </span>
<span class="sd">                      does not exist in one or more of the TargetText objects </span>
<span class="sd">                      within the `dataset`</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">reduced_collection</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">anonymised</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">key_check_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="o">*</span><span class="n">associated_keys</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">sentiment_key</span><span class="p">]))</span>
    <span class="k">for</span> <span class="n">target_data</span> <span class="ow">in</span> <span class="n">dataset</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">_key</span> <span class="ow">in</span> <span class="n">key_check_list</span><span class="p">:</span>
            <span class="n">target_data</span><span class="o">.</span><span class="n">_key_error</span><span class="p">(</span><span class="n">_key</span><span class="p">)</span>
        
        <span class="n">new_target_object</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">target_data</span><span class="p">))</span>
        <span class="c1"># remove the associated values</span>
        <span class="k">for</span> <span class="n">associated_key</span> <span class="ow">in</span> <span class="n">associated_keys</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">new_target_object</span><span class="p">[</span><span class="n">associated_key</span><span class="p">]</span>

        <span class="n">skip_target</span> <span class="o">=</span> <span class="kc">True</span>
        
        <span class="n">sentiment_values</span> <span class="o">=</span> <span class="n">target_data</span><span class="p">[</span><span class="n">sentiment_key</span><span class="p">]</span>
        <span class="n">relevent_sentiment_indexes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">sentiment_values</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">sentiment_value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sentiment_values</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">sentiment_value</span> <span class="o">==</span> <span class="n">reduce_sentiment</span><span class="p">:</span>
                <span class="n">relevent_sentiment_indexes</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">relevent_sentiment_indexes</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">value</span><span class="p">:</span>
                <span class="n">skip_target</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">associated_key</span> <span class="ow">in</span> <span class="n">associated_keys</span><span class="p">:</span>
                    <span class="n">associated_value</span> <span class="o">=</span> <span class="n">target_data</span><span class="p">[</span><span class="n">associated_key</span><span class="p">][</span><span class="n">index</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">associated_key</span> <span class="ow">in</span> <span class="n">new_target_object</span><span class="p">:</span>
                        <span class="n">new_target_object</span><span class="p">[</span><span class="n">associated_key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">associated_value</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">new_target_object</span><span class="p">[</span><span class="n">associated_key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">associated_value</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">skip_target</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="s1">&#39;text&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">new_target_object</span><span class="p">:</span>
            <span class="n">new_target_object</span><span class="p">[</span><span class="s1">&#39;text&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">new_target_object</span><span class="p">[</span><span class="s1">&#39;text&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">anonymised</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">new_target_object</span><span class="p">[</span><span class="s1">&#39;anonymised&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">new_target_object</span> <span class="o">=</span> <span class="n">TargetText</span><span class="p">(</span><span class="o">**</span><span class="n">new_target_object</span><span class="p">)</span>
        <span class="n">reduced_collection</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_target_object</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">TargetTextCollection</span><span class="p">(</span><span class="n">reduced_collection</span><span class="p">,</span> <span class="n">anonymised</span><span class="o">=</span><span class="n">anonymised</span><span class="p">)</span></div>

<div class="viewcode-block" id="reduce_collection_by_key_occurrence"><a class="viewcode-back" href="../../../target_extraction.analysis.html#target_extraction.analysis.sentiment_error_analysis.reduce_collection_by_key_occurrence">[docs]</a><span class="k">def</span> <span class="nf">reduce_collection_by_key_occurrence</span><span class="p">(</span><span class="n">dataset</span><span class="p">:</span> <span class="n">TargetTextCollection</span><span class="p">,</span> 
                                        <span class="n">error_key</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> 
                                        <span class="n">associated_keys</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
                                        <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TargetTextCollection</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    :param dataset: The dataset that contains error analysis key which are </span>
<span class="sd">                    one hot encoding of whether a target is in that </span>
<span class="sd">                    error analysis class or not. Example function that </span>
<span class="sd">                    produces these error keys are </span>
<span class="sd">                    :func:`target_extraction.error_analysis.same_one_sentiment`</span>
<span class="sd">    :param error_key: Name of the error key e.g. `same_one_sentiment`. Or it can </span>
<span class="sd">                      be a list of error keys for which this will reduce the </span>
<span class="sd">                      collection so that it includes all samples that contain </span>
<span class="sd">                      at least one of these error keys.</span>
<span class="sd">    :param associated_keys: The keys that are associated to the target that </span>
<span class="sd">                            must be kept and are linked to that target. E.g. </span>
<span class="sd">                            `target_sentiments`, `targets`, `spans`, and </span>
<span class="sd">                            `subset error keys`.</span>
<span class="sd">    :returns: A new TargetTextCollection that contains only those targets and </span>
<span class="sd">              relevant `associated_keys` within the TargetText&#39;s that the</span>
<span class="sd">              error analysis key(s) were `True` (1 in the one hot encoding). </span>
<span class="sd">              This could mean that some TargetText&#39;s will no longer exist.</span>
<span class="sd">    :raises KeyError: If the `error_key` or one or more of the `associated_keys` </span>
<span class="sd">                      does not exist in one or more of the TargetText objects </span>
<span class="sd">                      within the `dataset`</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">reduced_collection</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">anonymised</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">error_key</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">error_key</span> <span class="o">=</span> <span class="p">[</span><span class="n">error_key</span><span class="p">]</span>
    <span class="n">error_keys</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">error_key</span>
    <span class="n">key_check_list</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="n">associated_keys</span><span class="p">]</span> <span class="o">+</span> <span class="n">error_keys</span>
    <span class="k">for</span> <span class="n">target_data</span> <span class="ow">in</span> <span class="n">dataset</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="c1"># Will raise a key error if the TargetText object does not have that </span>
        <span class="c1"># error_key or any of the associated_keys</span>
        <span class="k">for</span> <span class="n">_key</span> <span class="ow">in</span> <span class="n">key_check_list</span><span class="p">:</span>
            <span class="n">target_data</span><span class="o">.</span><span class="n">_key_error</span><span class="p">(</span><span class="n">_key</span><span class="p">)</span>
        
        <span class="n">new_target_object</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">target_data</span><span class="p">))</span>
        <span class="c1"># remove the associated values</span>
        <span class="k">for</span> <span class="n">associated_key</span> <span class="ow">in</span> <span class="n">associated_keys</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">new_target_object</span><span class="p">[</span><span class="n">associated_key</span><span class="p">]</span>

        <span class="n">skip_target</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">error_key_values</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">error_key</span> <span class="ow">in</span> <span class="n">error_keys</span><span class="p">:</span>
            <span class="n">error_values</span> <span class="o">=</span> <span class="n">target_data</span><span class="p">[</span><span class="n">error_key</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">error_key_values</span><span class="p">:</span>
                <span class="n">error_key_values</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">error_values</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">error_key_error</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Not all error keys are of the same length, &#39;</span>
                                   <span class="sa">f</span><span class="s1">&#39;of which they should error keys: </span><span class="si">{</span><span class="n">error_keys</span><span class="si">}</span><span class="s1">&#39;</span>
                                   <span class="sa">f</span><span class="s1">&#39; TargetObject </span><span class="si">{</span><span class="n">target_data</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">error_key_values</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">error_values</span><span class="p">),</span> <span class="n">error_key_error</span>
            <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">error_values</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">value</span><span class="p">:</span>
                    <span class="n">error_key_values</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">error_key_values</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">value</span><span class="p">:</span>
                <span class="n">skip_target</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">associated_key</span> <span class="ow">in</span> <span class="n">associated_keys</span><span class="p">:</span>
                    <span class="n">associated_value</span> <span class="o">=</span> <span class="n">target_data</span><span class="p">[</span><span class="n">associated_key</span><span class="p">][</span><span class="n">index</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">associated_key</span> <span class="ow">in</span> <span class="n">new_target_object</span><span class="p">:</span>
                        <span class="n">new_target_object</span><span class="p">[</span><span class="n">associated_key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">associated_value</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">new_target_object</span><span class="p">[</span><span class="n">associated_key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">associated_value</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">skip_target</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="s1">&#39;text&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">new_target_object</span><span class="p">:</span>
            <span class="n">new_target_object</span><span class="p">[</span><span class="s1">&#39;text&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">new_target_object</span><span class="p">[</span><span class="s1">&#39;text&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">anonymised</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">new_target_object</span><span class="p">[</span><span class="s1">&#39;anonymised&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">new_target_object</span> <span class="o">=</span> <span class="n">TargetText</span><span class="p">(</span><span class="o">**</span><span class="n">new_target_object</span><span class="p">)</span>
        <span class="n">reduced_collection</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_target_object</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">TargetTextCollection</span><span class="p">(</span><span class="n">reduced_collection</span><span class="p">,</span> <span class="n">anonymised</span><span class="o">=</span><span class="n">anonymised</span><span class="p">)</span></div>

<div class="viewcode-block" id="swap_and_reduce"><a class="viewcode-back" href="../../../target_extraction.analysis.html#target_extraction.analysis.sentiment_error_analysis.swap_and_reduce">[docs]</a><span class="k">def</span> <span class="nf">swap_and_reduce</span><span class="p">(</span><span class="n">_collection</span><span class="p">:</span> <span class="n">TargetTextCollection</span><span class="p">,</span> 
                    <span class="n">subset_key</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
                    <span class="n">true_sentiment_key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                    <span class="n">prediction_keys</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">TargetTextCollection</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Furthermore the keys that will be reduced won&#39;t just be the `targets`, `spans`,</span>
<span class="sd">    `true_sentiment_key` and all `prediction_keys` but any error subset name from </span>
<span class="sd">    within `PLOT_SUBSET_ABBREVIATION` that is in the TargetTexts in the collection.</span>

<span class="sd">    :param _collection: TargetTextCollection to reduce the samples based on the </span>
<span class="sd">                        subset_key argument given.</span>
<span class="sd">    :param subset_key: Name of the error key e.g. `same_one_sentiment`. Or it can </span>
<span class="sd">                       be a list of error keys for which this will reduce the </span>
<span class="sd">                       collection so that it includes all samples that contain </span>
<span class="sd">                       at least one of these error keys.</span>
<span class="sd">    :param true_sentiment: The key in each TargetText within the collection </span>
<span class="sd">                           that contains the true sentiment labels.</span>
<span class="sd">    :param prediction_keys: The list of keys in each TargetText </span>
<span class="sd">                            where each key contains a list of predicted sentiments.</span>
<span class="sd">                            These predicted sentiments are expected to be in a </span>
<span class="sd">                            list of a list where the outer list defines the </span>
<span class="sd">                            number of models trained e.g. number of model runs </span>
<span class="sd">                            and the inner list is the length of the number of </span>
<span class="sd">                            predictions required for that text/sentence.</span>
<span class="sd">    :returns: A collection that has been reduced based on the subset_key </span>
<span class="sd">              argument. This is a helper function for the </span>
<span class="sd">              `reduce_collection_by_key_occurrence` as this function ensure that </span>
<span class="sd">              the predicted sentiment keys are changed before and after reducing </span>
<span class="sd">              the collection so that they are processed properly as the predicted </span>
<span class="sd">              sentiment labels are of shape (number of model runs, number of sentiments)</span>
<span class="sd">              where as all other lists in the TargetText are of (number of sentiments) </span>
<span class="sd">              size. Furthermore if the reduction causes all any of the TargetText&#39;s</span>
<span class="sd">              in the collection to have no Targets then that TargetText will be </span>
<span class="sd">              removed from the collection, thus you could have a collection of </span>
<span class="sd">              zero.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">reduce_keys</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;targets&#39;</span><span class="p">,</span> <span class="s1">&#39;spans&#39;</span><span class="p">,</span> <span class="n">true_sentiment_key</span><span class="p">]</span> <span class="o">+</span> <span class="n">prediction_keys</span>
    <span class="n">target_sample</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">_collection</span><span class="o">.</span><span class="n">dict_iterator</span><span class="p">())</span>
    <span class="c1"># Adds the subset error keys to the reduce keys so that the reduction is </span>
    <span class="c1"># performed correctly.</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">target_sample</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">PLOT_SUBSET_ABBREVIATION</span><span class="p">:</span>
            <span class="n">reduce_keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">prediction_key</span> <span class="ow">in</span> <span class="n">prediction_keys</span><span class="p">:</span>
        <span class="n">_collection</span> <span class="o">=</span> <span class="n">swap_list_dimensions</span><span class="p">(</span><span class="n">_collection</span><span class="p">,</span> <span class="n">prediction_key</span><span class="p">)</span>
    <span class="n">_collection</span> <span class="o">=</span> <span class="n">reduce_collection_by_key_occurrence</span><span class="p">(</span><span class="n">_collection</span><span class="p">,</span> 
                                                        <span class="n">subset_key</span><span class="p">,</span> 
                                                        <span class="n">reduce_keys</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">prediction_key</span> <span class="ow">in</span> <span class="n">prediction_keys</span><span class="p">:</span>
        <span class="n">_collection</span> <span class="o">=</span> <span class="n">swap_list_dimensions</span><span class="p">(</span><span class="n">_collection</span><span class="p">,</span> <span class="n">prediction_key</span><span class="p">)</span>
    <span class="c1"># Remove TargetTexts from the collection that do not contain a target anymore</span>
    <span class="n">_collection</span> <span class="o">=</span> <span class="n">_collection</span><span class="o">.</span><span class="n">samples_with_targets</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">_collection</span></div>

<span class="k">def</span> <span class="nf">_pre_post_subsampling</span><span class="p">(</span><span class="n">test_dataset</span><span class="p">:</span> <span class="n">TargetTextCollection</span><span class="p">,</span> 
                          <span class="n">train_dataset</span><span class="p">:</span> <span class="n">TargetTextCollection</span><span class="p">,</span> 
                          <span class="n">lower</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">error_key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                          <span class="n">error_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> 
                                                <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> 
                                                <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="n">TargetText</span><span class="p">],</span> <span class="nb">bool</span><span class="p">],</span>
                          <span class="n">train_dict</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                          <span class="n">test_dict</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
                          <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TargetTextCollection</span><span class="p">:</span>
    <span class="n">train_target_sentiments</span> <span class="o">=</span> <span class="n">train_dataset</span><span class="o">.</span><span class="n">target_sentiments</span><span class="p">(</span><span class="n">lower</span><span class="o">=</span><span class="n">lower</span><span class="p">,</span> 
                                                              <span class="n">unique_sentiment</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">test_target_sentiments</span> <span class="o">=</span> <span class="n">test_dataset</span><span class="o">.</span><span class="n">target_sentiments</span><span class="p">(</span><span class="n">lower</span><span class="o">=</span><span class="n">lower</span><span class="p">,</span> 
                                                            <span class="n">unique_sentiment</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">train_dict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">train_target_sentiments</span> <span class="o">=</span> <span class="n">train_dict</span>
    <span class="k">if</span> <span class="n">test_dict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">test_target_sentiments</span> <span class="o">=</span> <span class="n">test_dict</span>

    <span class="k">for</span> <span class="n">target_data</span> <span class="ow">in</span> <span class="n">test_dataset</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="n">test_targets</span> <span class="o">=</span> <span class="n">target_data</span><span class="p">[</span><span class="s1">&#39;targets&#39;</span><span class="p">]</span>
        <span class="n">target_sentiments</span> <span class="o">=</span> <span class="n">target_data</span><span class="p">[</span><span class="s1">&#39;target_sentiments&#39;</span><span class="p">]</span>
        <span class="n">error_values</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">test_targets</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">target_data</span><span class="p">[</span><span class="n">error_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">error_values</span>
            <span class="k">continue</span>
        <span class="k">for</span> <span class="n">target</span><span class="p">,</span> <span class="n">target_sentiment</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">test_targets</span><span class="p">,</span> <span class="n">target_sentiments</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">lower</span><span class="p">:</span>
                <span class="n">target</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">error_func</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">train_target_sentiments</span><span class="p">,</span> 
                          <span class="n">test_target_sentiments</span><span class="p">,</span> <span class="n">target_sentiment</span><span class="p">,</span>
                          <span class="n">target_data</span><span class="p">):</span>
                <span class="n">error_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="n">error_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">assert_err_msg</span> <span class="o">=</span> <span class="s1">&#39;This should not occur as the number of targets in &#39;</span>\
                         <span class="sa">f</span><span class="s1">&#39;this TargetText object </span><span class="si">{</span><span class="n">target_data</span><span class="si">}</span><span class="s1"> should equal &#39;</span>\
                         <span class="sa">f</span><span class="s1">&#39;the number of same_one_value integer list </span><span class="si">{</span><span class="n">error_values</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">test_targets</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">error_values</span><span class="p">),</span> <span class="n">assert_err_msg</span>
        <span class="n">target_data</span><span class="p">[</span><span class="n">error_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">error_values</span>
    <span class="k">return</span> <span class="n">test_dataset</span>

<div class="viewcode-block" id="same_one_sentiment"><a class="viewcode-back" href="../../../target_extraction.analysis.html#target_extraction.analysis.sentiment_error_analysis.same_one_sentiment">[docs]</a><span class="k">def</span> <span class="nf">same_one_sentiment</span><span class="p">(</span><span class="n">test_dataset</span><span class="p">:</span> <span class="n">TargetTextCollection</span><span class="p">,</span> 
                       <span class="n">train_dataset</span><span class="p">:</span> <span class="n">TargetTextCollection</span><span class="p">,</span> 
                       <span class="n">lower</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TargetTextCollection</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Given a test and train dataset will return the same test dataset but </span>
<span class="sd">    with an additional key `same_one_sentiment` for each TargetText object</span>
<span class="sd">    in the test collection. This `same_one_sentiment` key will contain a list </span>
<span class="sd">    the same length as the number of targets in that TargetText object with </span>
<span class="sd">    0&#39;s and 1&#39;s where a 1 represents the associated target has the same one </span>
<span class="sd">    sentiment label in the train and test where as the 0 means it does not.</span>

<span class="sd">    :Note: If the TargetText object `targets` is None as in there are no</span>
<span class="sd">           targets in that sample then the `same_one_sentiment` key</span>
<span class="sd">           will be represented as an empty list</span>

<span class="sd">    :param test_dataset: Test dataset to sub-sample</span>
<span class="sd">    :param train_dataset: Train dataset to reference</span>
<span class="sd">    :param lower: Whether to lower case the target words</span>
<span class="sd">    :returns: The test dataset but with each TargetText object containing a </span>
<span class="sd">              `same_one_sentiment` key and associated list of values.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="k">def</span> <span class="nf">error_func</span><span class="p">(</span><span class="n">target</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> 
                   <span class="n">train_target_sentiments</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
                   <span class="n">test_target_sentiments</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
                   <span class="n">target_sentiment</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> 
                   <span class="n">target_data</span><span class="p">:</span> <span class="n">TargetText</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">target</span> <span class="ow">in</span> <span class="n">train_target_sentiments</span> <span class="ow">and</span> 
            <span class="n">target</span> <span class="ow">in</span> <span class="n">test_target_sentiments</span><span class="p">):</span>
            <span class="n">train_sentiments</span> <span class="o">=</span> <span class="n">train_target_sentiments</span><span class="p">[</span><span class="n">target</span><span class="p">]</span>
            <span class="n">test_sentiments</span> <span class="o">=</span> <span class="n">test_target_sentiments</span><span class="p">[</span><span class="n">target</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">train_sentiments</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">test_sentiments</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">train_sentiments</span> <span class="o">==</span> <span class="n">test_sentiments</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>    
    
    <span class="k">return</span> <span class="n">_pre_post_subsampling</span><span class="p">(</span><span class="n">test_dataset</span><span class="p">,</span> <span class="n">train_dataset</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> 
                                 <span class="s1">&#39;same_one_sentiment&#39;</span><span class="p">,</span> <span class="n">error_func</span><span class="p">)</span></div>

<div class="viewcode-block" id="same_multi_sentiment"><a class="viewcode-back" href="../../../target_extraction.analysis.html#target_extraction.analysis.sentiment_error_analysis.same_multi_sentiment">[docs]</a><span class="k">def</span> <span class="nf">same_multi_sentiment</span><span class="p">(</span><span class="n">test_dataset</span><span class="p">:</span> <span class="n">TargetTextCollection</span><span class="p">,</span> 
                         <span class="n">train_dataset</span><span class="p">:</span> <span class="n">TargetTextCollection</span><span class="p">,</span> 
                         <span class="n">lower</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TargetTextCollection</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Given a test and train dataset will return the same test dataset but </span>
<span class="sd">    with an additional key `same_multi_sentiment` for each TargetText object</span>
<span class="sd">    in the test collection. This `same_multi_sentiment` key will contain a list </span>
<span class="sd">    the same length as the number of targets in that TargetText object with </span>
<span class="sd">    0&#39;s and 1&#39;s where a 1 represents the associated target has the same </span>
<span class="sd">    sentiment labels (more than one sentiment label e.g. positive and negative</span>
<span class="sd">    not just positive or not just negative) in the train and test </span>
<span class="sd">    where as the 0 means it does not.</span>

<span class="sd">    :Note: If the TargetText object `targets` is None as in there are no</span>
<span class="sd">           targets in that sample then the `same_multi_sentiment` key</span>
<span class="sd">           will be represented as an empty list</span>

<span class="sd">    :param test_dataset: Test dataset to sub-sample</span>
<span class="sd">    :param train_dataset: Train dataset to reference</span>
<span class="sd">    :param lower: Whether to lower case the target words</span>
<span class="sd">    :returns: The test dataset but with each TargetText object containing a </span>
<span class="sd">              `same_multi_sentiment` key and associated list of values.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">error_func</span><span class="p">(</span><span class="n">target</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> 
                   <span class="n">train_target_sentiments</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
                   <span class="n">test_target_sentiments</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
                   <span class="n">target_sentiment</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> 
                   <span class="n">target_data</span><span class="p">:</span> <span class="n">TargetText</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">target</span> <span class="ow">in</span> <span class="n">train_target_sentiments</span> <span class="ow">and</span> 
            <span class="n">target</span> <span class="ow">in</span> <span class="n">test_target_sentiments</span><span class="p">):</span>
            <span class="n">train_sentiments</span> <span class="o">=</span> <span class="n">train_target_sentiments</span><span class="p">[</span><span class="n">target</span><span class="p">]</span>
            <span class="n">test_sentiments</span> <span class="o">=</span> <span class="n">test_target_sentiments</span><span class="p">[</span><span class="n">target</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">train_sentiments</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">test_sentiments</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">train_sentiments</span> <span class="o">==</span> <span class="n">test_sentiments</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>    
    
    <span class="k">return</span> <span class="n">_pre_post_subsampling</span><span class="p">(</span><span class="n">test_dataset</span><span class="p">,</span> <span class="n">train_dataset</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> 
                                 <span class="s1">&#39;same_multi_sentiment&#39;</span><span class="p">,</span> <span class="n">error_func</span><span class="p">)</span></div>

<div class="viewcode-block" id="similar_sentiment"><a class="viewcode-back" href="../../../target_extraction.analysis.html#target_extraction.analysis.sentiment_error_analysis.similar_sentiment">[docs]</a><span class="k">def</span> <span class="nf">similar_sentiment</span><span class="p">(</span><span class="n">test_dataset</span><span class="p">:</span> <span class="n">TargetTextCollection</span><span class="p">,</span> 
                      <span class="n">train_dataset</span><span class="p">:</span> <span class="n">TargetTextCollection</span><span class="p">,</span> 
                      <span class="n">lower</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TargetTextCollection</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Given a test and train dataset will return the same test dataset but </span>
<span class="sd">    with an additional key `similar_sentiment` for each TargetText object</span>
<span class="sd">    in the test collection. This `similar_sentiment` key will contain a list </span>
<span class="sd">    the same length as the number of targets in that TargetText object with </span>
<span class="sd">    0&#39;s and 1&#39;s where a 1 represents the associated target has occured more </span>
<span class="sd">    than once in the train or test sets with at least some overlap between the </span>
<span class="sd">    test and train sentiments but not identical. E.g. the target `camera` </span>
<span class="sd">    could occur with `positive` and `negative` sentiment in the test set and </span>
<span class="sd">    only `negative` in the train set.</span>

<span class="sd">    :Note: If the TargetText object `targets` is None as in there are no</span>
<span class="sd">           targets in that sample then the `similar_sentiment` key</span>
<span class="sd">           will be represented as an empty list</span>

<span class="sd">    :param test_dataset: Test dataset to sub-sample</span>
<span class="sd">    :param train_dataset: Train dataset to reference</span>
<span class="sd">    :param lower: Whether to lower case the target words</span>
<span class="sd">    :returns: The test dataset but with each TargetText object containing a </span>
<span class="sd">              `similar_sentiment` key and associated list of values.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">error_func</span><span class="p">(</span><span class="n">target</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> 
                   <span class="n">train_target_sentiments</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
                   <span class="n">test_target_sentiments</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
                   <span class="n">target_sentiment</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> 
                   <span class="n">target_data</span><span class="p">:</span> <span class="n">TargetText</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">target</span> <span class="ow">in</span> <span class="n">train_target_sentiments</span> <span class="ow">and</span> 
            <span class="n">target</span> <span class="ow">in</span> <span class="n">test_target_sentiments</span><span class="p">):</span>
            <span class="n">train_sentiments</span> <span class="o">=</span> <span class="n">train_target_sentiments</span><span class="p">[</span><span class="n">target</span><span class="p">]</span>
            <span class="n">test_sentiments</span> <span class="o">=</span> <span class="n">test_target_sentiments</span><span class="p">[</span><span class="n">target</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">train_sentiments</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> 
                <span class="nb">len</span><span class="p">(</span><span class="n">test_sentiments</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">train_sentiments</span> <span class="o">==</span> <span class="n">test_sentiments</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="n">test_sentiments</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">train_sentiments</span><span class="p">):</span>
                    <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>    
    
    <span class="k">return</span> <span class="n">_pre_post_subsampling</span><span class="p">(</span><span class="n">test_dataset</span><span class="p">,</span> <span class="n">train_dataset</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> 
                                 <span class="s1">&#39;similar_sentiment&#39;</span><span class="p">,</span> <span class="n">error_func</span><span class="p">)</span></div>

<div class="viewcode-block" id="different_sentiment"><a class="viewcode-back" href="../../../target_extraction.analysis.html#target_extraction.analysis.sentiment_error_analysis.different_sentiment">[docs]</a><span class="k">def</span> <span class="nf">different_sentiment</span><span class="p">(</span><span class="n">test_dataset</span><span class="p">:</span> <span class="n">TargetTextCollection</span><span class="p">,</span> 
                        <span class="n">train_dataset</span><span class="p">:</span> <span class="n">TargetTextCollection</span><span class="p">,</span> 
                        <span class="n">lower</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TargetTextCollection</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Given a test and train dataset will return the same test dataset but </span>
<span class="sd">    with an additional key `different_sentiment` for each TargetText object</span>
<span class="sd">    in the test collection. This `different_sentiment` key will contain a list </span>
<span class="sd">    the same length as the number of targets in that TargetText object with </span>
<span class="sd">    0&#39;s and 1&#39;s where a 1 represents the associated target has no overlap </span>
<span class="sd">    in sentiment labels between the test and the train.</span>

<span class="sd">    :Note: If the TargetText object `targets` is None as in there are no</span>
<span class="sd">           targets in that sample then the `different_sentiment` key</span>
<span class="sd">           will be represented as an empty list</span>

<span class="sd">    :param test_dataset: Test dataset to sub-sample</span>
<span class="sd">    :param train_dataset: Train dataset to reference</span>
<span class="sd">    :param lower: Whether to lower case the target words</span>
<span class="sd">    :returns: The test dataset but with each TargetText object containing a </span>
<span class="sd">              `different_sentiment` key and associated list of values.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">error_func</span><span class="p">(</span><span class="n">target</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> 
                   <span class="n">train_target_sentiments</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
                   <span class="n">test_target_sentiments</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
                   <span class="n">target_sentiment</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> 
                   <span class="n">target_data</span><span class="p">:</span> <span class="n">TargetText</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">target</span> <span class="ow">in</span> <span class="n">train_target_sentiments</span> <span class="ow">and</span> 
            <span class="n">target</span> <span class="ow">in</span> <span class="n">test_target_sentiments</span><span class="p">):</span>
            <span class="n">train_sentiments</span> <span class="o">=</span> <span class="n">train_target_sentiments</span><span class="p">[</span><span class="n">target</span><span class="p">]</span>
            <span class="n">test_sentiments</span> <span class="o">=</span> <span class="n">test_target_sentiments</span><span class="p">[</span><span class="n">target</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">test_sentiments</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">train_sentiments</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>    
    
    <span class="k">return</span> <span class="n">_pre_post_subsampling</span><span class="p">(</span><span class="n">test_dataset</span><span class="p">,</span> <span class="n">train_dataset</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> 
                                 <span class="s1">&#39;different_sentiment&#39;</span><span class="p">,</span> <span class="n">error_func</span><span class="p">)</span></div>

<div class="viewcode-block" id="unknown_targets"><a class="viewcode-back" href="../../../target_extraction.analysis.html#target_extraction.analysis.sentiment_error_analysis.unknown_targets">[docs]</a><span class="k">def</span> <span class="nf">unknown_targets</span><span class="p">(</span><span class="n">test_dataset</span><span class="p">:</span> <span class="n">TargetTextCollection</span><span class="p">,</span> 
                    <span class="n">train_dataset</span><span class="p">:</span> <span class="n">TargetTextCollection</span><span class="p">,</span> 
                    <span class="n">lower</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TargetTextCollection</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Given a test and train dataset will return the same test dataset but </span>
<span class="sd">    with an additional key `unknown_targets` for each TargetText object</span>
<span class="sd">    in the test collection. This `unknown_targets` key will contain a list </span>
<span class="sd">    the same length as the number of targets in that TargetText object with </span>
<span class="sd">    0&#39;s and 1&#39;s where a 1 represents a target that exists in the test set </span>
<span class="sd">    but not in the train.</span>

<span class="sd">    :Note: If the TargetText object `targets` is None as in there are no</span>
<span class="sd">           targets in that sample then the `unknown_targets` key</span>
<span class="sd">           will be represented as an empty list</span>

<span class="sd">    :param test_dataset: Test dataset to sub-sample</span>
<span class="sd">    :param train_dataset: Train dataset to reference</span>
<span class="sd">    :param lower: Whether to lower case the target words</span>
<span class="sd">    :returns: The test dataset but with each TargetText object containing a </span>
<span class="sd">              `unknown_targets` key and associated list of values.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">error_func</span><span class="p">(</span><span class="n">target</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> 
                   <span class="n">train_target_sentiments</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
                   <span class="n">test_target_sentiments</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
                   <span class="n">target_sentiment</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> 
                   <span class="n">target_data</span><span class="p">:</span> <span class="n">TargetText</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">target</span> <span class="ow">in</span> <span class="n">train_target_sentiments</span> <span class="ow">and</span> 
            <span class="n">target</span> <span class="ow">in</span> <span class="n">test_target_sentiments</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>    
    
    <span class="k">return</span> <span class="n">_pre_post_subsampling</span><span class="p">(</span><span class="n">test_dataset</span><span class="p">,</span> <span class="n">train_dataset</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> 
                                 <span class="s1">&#39;unknown_targets&#39;</span><span class="p">,</span> <span class="n">error_func</span><span class="p">)</span></div>

<div class="viewcode-block" id="known_sentiment_known_target"><a class="viewcode-back" href="../../../target_extraction.analysis.html#target_extraction.analysis.sentiment_error_analysis.known_sentiment_known_target">[docs]</a><span class="k">def</span> <span class="nf">known_sentiment_known_target</span><span class="p">(</span><span class="n">test_dataset</span><span class="p">:</span> <span class="n">TargetTextCollection</span><span class="p">,</span> 
                                 <span class="n">train_dataset</span><span class="p">:</span> <span class="n">TargetTextCollection</span><span class="p">,</span> 
                                 <span class="n">lower</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TargetTextCollection</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Given a test and train dataset will return the same test dataset but </span>
<span class="sd">    with an additional key `known_sentiment_known_target` for each </span>
<span class="sd">    TargetText object in the test collection. This </span>
<span class="sd">    `known_sentiment_known_target` key will contain a list </span>
<span class="sd">    the same length as the number of targets in that TargetText object with </span>
<span class="sd">    0&#39;s and 1&#39;s where a 1 represents a target that exists in both train and </span>
<span class="sd">    test where that target for that instance in the test set has a sentiment </span>
<span class="sd">    that has been seen before in the training set for that target.</span>

<span class="sd">    :Note: If the TargetText object `targets` is None as in there are no</span>
<span class="sd">           targets in that sample then the `known_sentiment_known_target` key</span>
<span class="sd">           will be represented as an empty list</span>

<span class="sd">    :param test_dataset: Test dataset to sub-sample</span>
<span class="sd">    :param train_dataset: Train dataset to reference</span>
<span class="sd">    :param lower: Whether to lower case the target words</span>
<span class="sd">    :returns: The test dataset but with each TargetText object containing a </span>
<span class="sd">              `known_sentiment_known_target` key and associated list of values.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">error_func</span><span class="p">(</span><span class="n">target</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> 
                   <span class="n">train_target_sentiments</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
                   <span class="n">test_target_sentiments</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
                   <span class="n">target_sentiment</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> 
                   <span class="n">target_data</span><span class="p">:</span> <span class="n">TargetText</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">target</span> <span class="ow">in</span> <span class="n">train_target_sentiments</span> <span class="ow">and</span> 
            <span class="n">target</span> <span class="ow">in</span> <span class="n">test_target_sentiments</span><span class="p">):</span>
            <span class="n">train_sentiments</span> <span class="o">=</span> <span class="n">train_target_sentiments</span><span class="p">[</span><span class="n">target</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">target_sentiment</span> <span class="ow">in</span> <span class="n">train_sentiments</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">return</span> <span class="n">_pre_post_subsampling</span><span class="p">(</span><span class="n">test_dataset</span><span class="p">,</span> <span class="n">train_dataset</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> 
                                 <span class="s1">&#39;known_sentiment_known_target&#39;</span><span class="p">,</span> <span class="n">error_func</span><span class="p">)</span></div>

<div class="viewcode-block" id="unknown_sentiment_known_target"><a class="viewcode-back" href="../../../target_extraction.analysis.html#target_extraction.analysis.sentiment_error_analysis.unknown_sentiment_known_target">[docs]</a><span class="k">def</span> <span class="nf">unknown_sentiment_known_target</span><span class="p">(</span><span class="n">test_dataset</span><span class="p">:</span> <span class="n">TargetTextCollection</span><span class="p">,</span> 
                                   <span class="n">train_dataset</span><span class="p">:</span> <span class="n">TargetTextCollection</span><span class="p">,</span> 
                                   <span class="n">lower</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TargetTextCollection</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Given a test and train dataset will return the same test dataset but </span>
<span class="sd">    with an additional key `unknown_sentiment_known_target` for each </span>
<span class="sd">    TargetText object in the test collection. This </span>
<span class="sd">    `unknown_sentiment_known_target` key will contain a list </span>
<span class="sd">    the same length as the number of targets in that TargetText object with </span>
<span class="sd">    0&#39;s and 1&#39;s where a 1 represents a target that exists in both train and </span>
<span class="sd">    test where that target for that instance in the test set has a sentiment </span>
<span class="sd">    that has NOT been seen before in the training set for that target.</span>

<span class="sd">    :Note: If the TargetText object `targets` is None as in there are no</span>
<span class="sd">           targets in that sample then the `unknown_sentiment_known_target` key</span>
<span class="sd">           will be represented as an empty list</span>

<span class="sd">    :param test_dataset: Test dataset to sub-sample</span>
<span class="sd">    :param train_dataset: Train dataset to reference</span>
<span class="sd">    :param lower: Whether to lower case the target words</span>
<span class="sd">    :returns: The test dataset but with each TargetText object containing a </span>
<span class="sd">              `unknown_sentiment_known_target` key and associated list of values.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">error_func</span><span class="p">(</span><span class="n">target</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> 
                   <span class="n">train_target_sentiments</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
                   <span class="n">test_target_sentiments</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
                   <span class="n">target_sentiment</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> 
                   <span class="n">target_data</span><span class="p">:</span> <span class="n">TargetText</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">target</span> <span class="ow">in</span> <span class="n">train_target_sentiments</span> <span class="ow">and</span> 
            <span class="n">target</span> <span class="ow">in</span> <span class="n">test_target_sentiments</span><span class="p">):</span>
            <span class="n">train_sentiments</span> <span class="o">=</span> <span class="n">train_target_sentiments</span><span class="p">[</span><span class="n">target</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">target_sentiment</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">train_sentiments</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">return</span> <span class="n">_pre_post_subsampling</span><span class="p">(</span><span class="n">test_dataset</span><span class="p">,</span> <span class="n">train_dataset</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> 
                                 <span class="s1">&#39;unknown_sentiment_known_target&#39;</span><span class="p">,</span> <span class="n">error_func</span><span class="p">)</span></div>

<div class="viewcode-block" id="distinct_sentiment"><a class="viewcode-back" href="../../../target_extraction.analysis.html#target_extraction.analysis.sentiment_error_analysis.distinct_sentiment">[docs]</a><span class="k">def</span> <span class="nf">distinct_sentiment</span><span class="p">(</span><span class="n">dataset</span><span class="p">:</span> <span class="n">TargetTextCollection</span><span class="p">,</span> 
                       <span class="n">separate_labels</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                       <span class="n">true_sentiment_key</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;target_sentiments&#39;</span>
                       <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TargetTextCollection</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    :param dataset: The dataset to add the distinct sentiment labels to</span>
<span class="sd">    :param separate_labels: If True instead of having one error key </span>
<span class="sd">                            `distinct_sentiment` which contains a value of </span>
<span class="sd">                            a list of the number of distinct sentiments. There</span>
<span class="sd">                            will be `n` error keys of the format </span>
<span class="sd">                            `distinct_sentiment_n` where for each TargetText </span>
<span class="sd">                            object each one will contain 0&#39;s apart from the </span>
<span class="sd">                            `n` value which is the correct number of </span>
<span class="sd">                            distinct sentiments. The value `n` is computed </span>
<span class="sd">                            based on the number of unique distinct sentiments </span>
<span class="sd">                            in the collection. Example if there are 2 distinct </span>
<span class="sd">                            sentiment in the collection {2, 3} and the current </span>
<span class="sd">                            TargetText contain 2 targets with 2 distinct </span>
<span class="sd">                            sentiments then it will contain the following keys </span>
<span class="sd">                            and values: `distinct_sentiment_2`: [1,1] and </span>
<span class="sd">                            `distinct_sentiment_3`: [0,0].</span>
<span class="sd">    :param true_sentiment_key: Key in the `target_collection` targets that </span>
<span class="sd">                               contains the true sentiment scores for each </span>
<span class="sd">                               target in the TargetTextCollection.</span>
<span class="sd">    :returns: The same dataset but with each TargetText object containing a </span>
<span class="sd">              `distinct_sentiment` or `distinct_sentiment_n` key(s) and </span>
<span class="sd">              associated number of distinct sentiments that are in that </span>
<span class="sd">              TargetText object per target.</span>

<span class="sd">    :Example: Given a TargetTextCollection that contains a single TargetText </span>
<span class="sd">              object that has three targets where the first two have the label </span>
<span class="sd">              positive and the last is negative it will add the </span>
<span class="sd">              `distinct_sentiment` key to the TargetText object with the</span>
<span class="sd">              following value [2,2,2] as there are two unique/distinct </span>
<span class="sd">              sentiments in that TargetText object.</span>
<span class="sd">    :raises ValueError: If separate_labels is True and there are no sentiment </span>
<span class="sd">                        labels in the collection.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># only used in the separate_labels case</span>
    <span class="n">ds_keys</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">separate_labels</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">unique_ds</span> <span class="ow">in</span> <span class="n">dataset</span><span class="o">.</span><span class="n">unique_distinct_sentiments</span><span class="p">(</span><span class="n">true_sentiment_key</span><span class="p">):</span>
            <span class="n">ds_keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;distinct_sentiment_</span><span class="si">{</span><span class="n">unique_ds</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ds_keys</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;There are no Distinct sentiments/sentiments &#39;</span>
                             <span class="s1">&#39;in this collection&#39;</span><span class="p">)</span>
        
    <span class="k">for</span> <span class="n">target_data</span> <span class="ow">in</span> <span class="n">dataset</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="n">target_sentiments</span> <span class="o">=</span> <span class="n">target_data</span><span class="p">[</span><span class="n">true_sentiment_key</span><span class="p">]</span>
        <span class="n">distinct_sentiments</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">target_sentiments</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">num_unique_sentiments</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">target_sentiments</span><span class="p">))</span>
            <span class="n">num_targets</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_sentiments</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">separate_labels</span><span class="p">:</span>
                <span class="n">distinct_sentiments</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_targets</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">distinct_sentiments</span> <span class="o">=</span> <span class="p">[</span><span class="n">num_unique_sentiments</span> 
                                    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_targets</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">separate_labels</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ds_key</span> <span class="ow">in</span> <span class="n">ds_keys</span><span class="p">:</span>
                <span class="n">target_data</span><span class="p">[</span><span class="n">ds_key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">distinct_sentiments</span><span class="p">)</span>
            <span class="n">ds_key</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;distinct_sentiment_</span><span class="si">{</span><span class="n">num_unique_sentiments</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="n">target_data</span><span class="p">[</span><span class="n">ds_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">distinct_sentiments</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">target_data</span><span class="p">[</span><span class="s1">&#39;distinct_sentiment&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">distinct_sentiments</span>
    <span class="k">return</span> <span class="n">dataset</span></div>

<div class="viewcode-block" id="n_shot_subsets"><a class="viewcode-back" href="../../../target_extraction.analysis.html#target_extraction.analysis.sentiment_error_analysis.n_shot_subsets">[docs]</a><span class="k">def</span> <span class="nf">n_shot_subsets</span><span class="p">(</span><span class="n">test_dataset</span><span class="p">:</span> <span class="n">TargetTextCollection</span><span class="p">,</span> 
                   <span class="n">train_dataset</span><span class="p">:</span> <span class="n">TargetTextCollection</span><span class="p">,</span> 
                   <span class="n">lower</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">return_n_values</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
                   <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">TargetTextCollection</span><span class="p">,</span> 
                              <span class="n">Tuple</span><span class="p">[</span><span class="n">TargetTextCollection</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]]:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Given a test and train dataset will return the same test dataset but </span>
<span class="sd">    with 4 additional keys denoted as `zero-shot`, `low-shot`, `med-shot`, and </span>
<span class="sd">    `high-shot`. Each one of these represents a different set of *n* values </span>
<span class="sd">    within the *n-shot* setup. The *n-shot* setup is the number of times the </span>
<span class="sd">    target within the test sample has been seen in the training dataset. The </span>
<span class="sd">    `zero-shot` subset contains all targets that have *n=0*. The low, med, and </span>
<span class="sd">    high contain increasing values *n* respectively where each subset will </span>
<span class="sd">    contain approximately 1/3 of all samples in the test dataset once the </span>
<span class="sd">    `zero-shot` subset has been removed.</span>

<span class="sd">    :param test_dataset: Test dataset to sub-sample</span>
<span class="sd">    :param train_dataset: Train dataset to reference</span>
<span class="sd">    :param lower: Whether to lower case the target words</span>
<span class="sd">    :param return_n_values: If True will return a tuple containing 1. The </span>
<span class="sd">                            TargetTextCollection with the new error keys and </span>
<span class="sd">                            2. A list of tuples one for each of the error keys </span>
<span class="sd">                            stating the values of *n* that the error keys </span>
<span class="sd">                            are associated too.</span>
<span class="sd">    :returns: The test dataset but with each TargetText object containing a </span>
<span class="sd">              `zero-shot`, `low-shot`, `med-shot`, and `high-shot` key and </span>
<span class="sd">              associated list of values.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">get_third_n</span><span class="p">(</span><span class="n">third_sample_count</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> 
                    <span class="n">n_relation_target</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]],</span>
                    <span class="n">target_sample_count</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="n">start</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">start_n</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">end_n</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">n_relation</span><span class="p">,</span> <span class="n">targets</span> <span class="ow">in</span> <span class="n">n_relation_target</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">start</span><span class="p">:</span>
                <span class="n">start</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">start_n</span> <span class="o">=</span> <span class="n">n_relation</span>
            <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">targets</span><span class="p">:</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="n">target_sample_count</span><span class="p">[</span><span class="n">target</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;=</span> <span class="n">third_sample_count</span><span class="p">:</span>
                <span class="n">end_n</span> <span class="o">=</span> <span class="n">n_relation</span>
                <span class="k">break</span>
            <span class="n">end_n</span> <span class="o">=</span> <span class="n">n_relation</span>
        <span class="k">if</span> <span class="n">start_n</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">end_n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The start nor end can be zero&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">start_n</span><span class="p">,</span> <span class="n">end_n</span><span class="p">)</span> 

    <span class="k">def</span> <span class="nf">error_func</span><span class="p">(</span><span class="n">target</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> 
                   <span class="n">train_target_sentiments</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
                   <span class="n">filtered_test</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
                   <span class="n">target_sentiment</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> 
                   <span class="n">target_data</span><span class="p">:</span> <span class="n">TargetText</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">filtered_test</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>
    
    <span class="c1"># Get Target and associated count for both train and test datasets</span>
    <span class="n">train_target_sentiments</span> <span class="o">=</span> <span class="n">train_dataset</span><span class="o">.</span><span class="n">target_sentiments</span><span class="p">(</span><span class="n">lower</span><span class="o">=</span><span class="n">lower</span><span class="p">,</span> 
                                                              <span class="n">unique_sentiment</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">train_target_counts</span> <span class="o">=</span> <span class="p">{</span><span class="n">target</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">occurrences</span><span class="p">)</span> 
                           <span class="k">for</span> <span class="n">target</span><span class="p">,</span> <span class="n">occurrences</span> <span class="ow">in</span> <span class="n">train_target_sentiments</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="n">test_target_sentiments</span> <span class="o">=</span> <span class="n">test_dataset</span><span class="o">.</span><span class="n">target_sentiments</span><span class="p">(</span><span class="n">lower</span><span class="o">=</span><span class="n">lower</span><span class="p">,</span> 
                                                            <span class="n">unique_sentiment</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">test_target_counts</span> <span class="o">=</span> <span class="p">{</span><span class="n">target</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">occurrences</span><span class="p">)</span> 
                          <span class="k">for</span> <span class="n">target</span><span class="p">,</span> <span class="n">occurrences</span> <span class="ow">in</span> <span class="n">test_target_sentiments</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="n">test_target_n_relation</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c1"># Does not cover zero shot target in n_relation_test_target</span>
    <span class="n">n_relation_test_target</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">test_target_counts</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">target</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">train_target_counts</span><span class="p">:</span>
            <span class="n">test_target_n_relation</span><span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">number_times_in_train</span> <span class="o">=</span> <span class="n">train_target_counts</span><span class="p">[</span><span class="n">target</span><span class="p">]</span>
            <span class="n">test_target_n_relation</span><span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="o">=</span> <span class="n">number_times_in_train</span>
            <span class="n">n_relation_test_target</span><span class="p">[</span><span class="n">number_times_in_train</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
    <span class="n">zero_filter</span> <span class="o">=</span> <span class="p">{</span><span class="n">target</span><span class="p">:</span> <span class="n">n_relation</span> 
                   <span class="k">for</span> <span class="n">target</span><span class="p">,</span> <span class="n">n_relation</span> <span class="ow">in</span> <span class="n">test_target_n_relation</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> 
                   <span class="k">if</span> <span class="n">n_relation</span> <span class="o">==</span> <span class="mi">0</span><span class="p">}</span>

    <span class="n">n_relation_test_target</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">n_relation_test_target</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">number_samples_left</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">test_target_counts</span><span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="k">for</span> 
                               <span class="n">n_relation</span><span class="p">,</span> <span class="n">targets</span> <span class="ow">in</span> <span class="n">n_relation_test_target</span> 
                               <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">targets</span><span class="p">])</span>
    <span class="n">third_samples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">number_samples_left</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">filter_dict</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">(</span><span class="n">zero_filter</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">):</span>
        <span class="n">start_n</span><span class="p">,</span> <span class="n">end_n</span> <span class="o">=</span> <span class="n">get_third_n</span><span class="p">(</span><span class="n">third_samples</span><span class="p">,</span> <span class="n">n_relation_test_target</span><span class="p">,</span> 
                                     <span class="n">test_target_counts</span><span class="p">)</span>
        <span class="n">n_range</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">start_n</span><span class="p">,</span> <span class="n">end_n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">n_filter</span> <span class="o">=</span> <span class="p">{</span><span class="n">target</span><span class="p">:</span> <span class="n">n_relation</span> 
                    <span class="k">for</span> <span class="n">target</span><span class="p">,</span> <span class="n">n_relation</span> <span class="ow">in</span> <span class="n">test_target_n_relation</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> 
                    <span class="k">if</span> <span class="n">n_relation</span> <span class="ow">in</span> <span class="n">n_range</span><span class="p">}</span>
        <span class="n">filter_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">n_filter</span><span class="p">,</span> <span class="p">(</span><span class="n">start_n</span><span class="p">,</span> <span class="n">end_n</span><span class="p">))</span>
        <span class="n">n_relation_test_target</span> <span class="o">=</span> <span class="p">[(</span><span class="n">n_relation</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span> <span class="k">for</span> <span class="n">n_relation</span><span class="p">,</span> <span class="n">target</span> 
                                   <span class="ow">in</span> <span class="n">n_relation_test_target</span> <span class="k">if</span> <span class="n">n_relation</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">n_range</span><span class="p">]</span>
    <span class="n">filter_name_dict</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s1">&#39;zero-shot&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s1">&#39;low-shot&#39;</span><span class="p">,</span> 
                        <span class="mi">2</span><span class="p">:</span> <span class="s1">&#39;med-shot&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="s1">&#39;high-shot&#39;</span><span class="p">}</span>
    <span class="n">n_ranges</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">):</span>
        <span class="n">filter_con</span><span class="p">,</span> <span class="n">n_range</span> <span class="o">=</span> <span class="n">filter_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">error_name</span> <span class="o">=</span> <span class="n">filter_name_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">test_dataset</span> <span class="o">=</span> <span class="n">_pre_post_subsampling</span><span class="p">(</span><span class="n">test_dataset</span><span class="p">,</span> <span class="n">train_dataset</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> 
                                             <span class="n">error_name</span><span class="p">,</span> <span class="n">error_func</span><span class="p">,</span> <span class="n">train_dict</span><span class="o">=</span><span class="p">{},</span>
                                             <span class="n">test_dict</span><span class="o">=</span><span class="n">filter_con</span><span class="p">)</span>
        <span class="n">n_ranges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n_range</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_n_values</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">test_dataset</span><span class="p">,</span> <span class="n">n_ranges</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">test_dataset</span></div>

<div class="viewcode-block" id="n_shot_targets"><a class="viewcode-back" href="../../../target_extraction.analysis.html#target_extraction.analysis.sentiment_error_analysis.n_shot_targets">[docs]</a><span class="k">def</span> <span class="nf">n_shot_targets</span><span class="p">(</span><span class="n">test_dataset</span><span class="p">:</span> <span class="n">TargetTextCollection</span><span class="p">,</span> 
                   <span class="n">train_dataset</span><span class="p">:</span> <span class="n">TargetTextCollection</span><span class="p">,</span> 
                   <span class="n">n_condition</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">bool</span><span class="p">],</span> <span class="n">error_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                   <span class="n">lower</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TargetTextCollection</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Given a test and train dataset will return the same test dataset but </span>
<span class="sd">    with an additional key denoted by `error_name` argument for each </span>
<span class="sd">    TargetText object in the test collection. This </span>
<span class="sd">    `error_name` key will contain a list </span>
<span class="sd">    the same length as the number of targets in that TargetText object with </span>
<span class="sd">    0&#39;s and 1&#39;s where a 1 represents a target that has meet the `n_condition`.</span>
<span class="sd">    This allows you to find the performance of n shot target learning where </span>
<span class="sd">    the `n_condition` can allow you to find zero shot target (targets not seen</span>
<span class="sd">    in training but in test (also known as unknown targets)) or find &gt;K shot </span>
<span class="sd">    targets where targets have been seen K or more times.</span>

<span class="sd">    :Note: If the TargetText object `targets` is None as in there are no</span>
<span class="sd">           targets in that sample then the `error_name` argument key</span>
<span class="sd">           will be represented as an empty list</span>

<span class="sd">    :param test_dataset: Test dataset to sub-sample</span>
<span class="sd">    :param train_dataset: Train dataset to reference</span>
<span class="sd">    :param n_condition: A callable that denotes the number of times the target </span>
<span class="sd">                        has to be seen in the training dataset to represent a </span>
<span class="sd">                        1 in the error key. Example n_condition `lambda x: x&gt;5` this </span>
<span class="sd">                        means that a target has to be seen more than 5 times in</span>
<span class="sd">                        the training set.</span>
<span class="sd">    :param error_name: The name of the error key</span>
<span class="sd">    :param lower: Whether to lower case the target words</span>
<span class="sd">    :returns: The test dataset but with each TargetText object containing a </span>
<span class="sd">              `unknown_sentiment_known_target` key and associated list of values.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">error_func</span><span class="p">(</span><span class="n">target</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> 
                   <span class="n">train_target_sentiments</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
                   <span class="n">filtered_test</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
                   <span class="n">target_sentiment</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> 
                   <span class="n">target_data</span><span class="p">:</span> <span class="n">TargetText</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">filtered_test</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>
    
    <span class="c1"># Get Target and associated count for both train and test datasets</span>
    <span class="n">train_target_sentiments</span> <span class="o">=</span> <span class="n">train_dataset</span><span class="o">.</span><span class="n">target_sentiments</span><span class="p">(</span><span class="n">lower</span><span class="o">=</span><span class="n">lower</span><span class="p">,</span> 
                                                              <span class="n">unique_sentiment</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">train_target_counts</span> <span class="o">=</span> <span class="p">{</span><span class="n">target</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">occurrences</span><span class="p">)</span> 
                           <span class="k">for</span> <span class="n">target</span><span class="p">,</span> <span class="n">occurrences</span> <span class="ow">in</span> <span class="n">train_target_sentiments</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="n">test_target_sentiments</span> <span class="o">=</span> <span class="n">test_dataset</span><span class="o">.</span><span class="n">target_sentiments</span><span class="p">(</span><span class="n">lower</span><span class="o">=</span><span class="n">lower</span><span class="p">,</span> 
                                                            <span class="n">unique_sentiment</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">test_target_counts</span> <span class="o">=</span> <span class="p">{</span><span class="n">target</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">occurrences</span><span class="p">)</span> 
                          <span class="k">for</span> <span class="n">target</span><span class="p">,</span> <span class="n">occurrences</span> <span class="ow">in</span> <span class="n">test_target_sentiments</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="n">test_target_n_relation</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">test_target_counts</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">target</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">train_target_counts</span><span class="p">:</span>
            <span class="n">test_target_n_relation</span><span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">number_times_in_train</span> <span class="o">=</span> <span class="n">train_target_counts</span><span class="p">[</span><span class="n">target</span><span class="p">]</span>
            <span class="n">test_target_n_relation</span><span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="o">=</span> <span class="n">number_times_in_train</span>
    <span class="c1"># filter by the n_condition</span>
    <span class="n">filter_test_target_n_relation</span> <span class="o">=</span> <span class="p">{</span><span class="n">target</span><span class="p">:</span> <span class="n">train_occurrences</span> 
                                     <span class="k">for</span> <span class="n">target</span><span class="p">,</span> <span class="n">train_occurrences</span> <span class="ow">in</span> <span class="n">test_target_n_relation</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> 
                                     <span class="k">if</span> <span class="n">n_condition</span><span class="p">(</span><span class="n">train_occurrences</span><span class="p">)}</span>
    <span class="k">return</span> <span class="n">_pre_post_subsampling</span><span class="p">(</span><span class="n">test_dataset</span><span class="p">,</span> <span class="n">train_dataset</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> 
                                 <span class="n">error_name</span><span class="p">,</span> <span class="n">error_func</span><span class="p">,</span> <span class="n">train_dict</span><span class="o">=</span><span class="p">{},</span>
                                 <span class="n">test_dict</span><span class="o">=</span><span class="n">filter_test_target_n_relation</span><span class="p">)</span></div>

<div class="viewcode-block" id="num_targets_subset"><a class="viewcode-back" href="../../../target_extraction.analysis.html#target_extraction.analysis.sentiment_error_analysis.num_targets_subset">[docs]</a><span class="k">def</span> <span class="nf">num_targets_subset</span><span class="p">(</span><span class="n">dataset</span><span class="p">:</span> <span class="n">TargetTextCollection</span><span class="p">,</span> 
                       <span class="n">return_n_values</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
                       <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">TargetTextCollection</span><span class="p">,</span> 
                                  <span class="n">Tuple</span><span class="p">[</span><span class="n">TargetTextCollection</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]]:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Given a dataset it will add the following four error keys: `1-target`,</span>
<span class="sd">    `low-targets`, `med-targets`, `high-targets` to each target text object. </span>
<span class="sd">    where each value associated to the error keys are a list of 1&#39;s or 0&#39;s </span>
<span class="sd">    the length of the number of samples where 1 denotes the error key is True </span>
<span class="sd">    and 0 otherwise. `1-target` is 1 when the target text object contains one </span>
<span class="sd">    target. The others are based on the frequency of targets with respect to the </span>
<span class="sd">    number of samples in the dataset where if the target is in the low 1/3 of </span>
<span class="sd">    most frequent targets based on samples then it is </span>
<span class="sd">    binned in the `low-targets`, middle 1/3 `med-targets` etc.</span>

<span class="sd">    :param dataset: The dataset to add the following four error keys: `1-target`,</span>
<span class="sd">                    `low-targets`, `med-targets`, `high-targets`.</span>
<span class="sd">    :param return_n_values: Whether to return the number of targets in the </span>
<span class="sd">                            sentence are associated to the 4 error keys as a </span>
<span class="sd">                            List of Tuples.</span>
<span class="sd">    :returns: The same dataset but with each TargetText object containing those </span>
<span class="sd">              four stated error keys and associated list of 1&#39;s or 0&#39;s denoting </span>
<span class="sd">              if the error key exists or not.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">get_third_n</span><span class="p">(</span><span class="n">third_sample_count</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> 
                    <span class="n">num_targets_count</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="n">start</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">start_n</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">end_n</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">total_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">num_targets</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">num_targets_count</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">start</span><span class="p">:</span>
                <span class="n">start</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">start_n</span> <span class="o">=</span> <span class="n">num_targets</span>
            <span class="n">total_count</span> <span class="o">+=</span> <span class="n">count</span>
            <span class="k">if</span> <span class="n">total_count</span> <span class="o">&gt;=</span> <span class="n">third_sample_count</span><span class="p">:</span>
                <span class="n">end_n</span> <span class="o">=</span> <span class="n">num_targets</span>
                <span class="k">break</span>
            <span class="n">end_n</span> <span class="o">=</span> <span class="n">num_targets</span>
        <span class="k">if</span> <span class="n">start_n</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">end_n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The start nor end can be zero&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">start_n</span><span class="p">,</span> <span class="n">end_n</span><span class="p">)</span> 

    <span class="k">def</span> <span class="nf">error_func</span><span class="p">(</span><span class="n">target</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> 
                   <span class="n">train_target_sentiments</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
                   <span class="n">filtered_test</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
                   <span class="n">target_sentiment</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> 
                   <span class="n">target_data</span><span class="p">:</span> <span class="n">TargetText</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_data</span><span class="p">[</span><span class="s1">&#39;targets&#39;</span><span class="p">])</span> <span class="ow">in</span> <span class="n">filtered_test</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>
    
    <span class="c1"># Get num targets in sentence and associated counts</span>
    <span class="n">num_targets_count</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">dataset</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="n">num_targets_in_text</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">target</span><span class="p">[</span><span class="s1">&#39;targets&#39;</span><span class="p">])</span>
        <span class="n">num_targets_count</span><span class="p">[</span><span class="n">num_targets_in_text</span><span class="p">]</span> <span class="o">+=</span> <span class="n">num_targets_in_text</span>
    <span class="n">one_filter</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
    <span class="n">number_samples_left</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">count</span> <span class="k">for</span> <span class="n">num_targets</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">num_targets_count</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">num_targets</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">third_samples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">number_samples_left</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">filter_dict</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="p">(</span><span class="n">one_filter</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))}</span>

    <span class="n">num_targets_count</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">num_targets_count</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">num_targets_count</span> <span class="o">=</span> <span class="p">[(</span><span class="n">num_target</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span> <span class="k">for</span> <span class="n">num_target</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">num_targets_count</span> <span class="k">if</span> <span class="n">num_target</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">):</span>
        <span class="n">start_num</span><span class="p">,</span> <span class="n">end_num</span> <span class="o">=</span> <span class="n">get_third_n</span><span class="p">(</span><span class="n">third_samples</span><span class="p">,</span> <span class="n">num_targets_count</span><span class="p">)</span>
        <span class="n">n_range</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">start_num</span><span class="p">,</span> <span class="n">end_num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">n_filter</span> <span class="o">=</span> <span class="p">{</span><span class="n">n</span><span class="p">:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">n_range</span><span class="p">}</span>
        <span class="n">filter_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">n_filter</span><span class="p">,</span> <span class="p">(</span><span class="n">start_num</span><span class="p">,</span> <span class="n">end_num</span><span class="p">))</span>
        <span class="n">num_targets_count</span> <span class="o">=</span> <span class="p">[(</span><span class="n">num_target</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span> <span class="k">for</span> <span class="n">num_target</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">num_targets_count</span> <span class="k">if</span> <span class="n">num_target</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">n_range</span><span class="p">]</span>
        <span class="n">number_samples_left</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">count</span> <span class="k">for</span> <span class="n">num_targets</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">num_targets_count</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">third_samples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">number_samples_left</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">last_target</span> <span class="o">=</span> <span class="n">num_targets_count</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">number_samples_left</span> <span class="o">-</span> <span class="n">last_target</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">third_samples</span><span class="p">:</span>
                <span class="n">third_samples</span> <span class="o">=</span> <span class="n">number_samples_left</span> <span class="o">-</span> <span class="n">last_target</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">third_samples</span> <span class="o">=</span> <span class="n">number_samples_left</span>
    <span class="n">filter_name_dict</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="s1">&#39;1-target&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s1">&#39;low-targets&#39;</span><span class="p">,</span> 
                        <span class="mi">3</span><span class="p">:</span> <span class="s1">&#39;med-targets&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span> <span class="s1">&#39;high-targets&#39;</span><span class="p">}</span>

    <span class="n">n_ranges</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">):</span>
        <span class="n">filter_con</span><span class="p">,</span> <span class="n">n_range</span> <span class="o">=</span> <span class="n">filter_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">error_name</span> <span class="o">=</span> <span class="n">filter_name_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">dataset</span> <span class="o">=</span> <span class="n">_pre_post_subsampling</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> 
                                        <span class="n">error_name</span><span class="p">,</span> <span class="n">error_func</span><span class="p">,</span> <span class="n">train_dict</span><span class="o">=</span><span class="p">{},</span>
                                        <span class="n">test_dict</span><span class="o">=</span><span class="n">filter_con</span><span class="p">)</span>
        <span class="n">n_ranges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n_range</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_n_values</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">n_ranges</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">dataset</span></div>

<div class="viewcode-block" id="tssr_target_value"><a class="viewcode-back" href="../../../target_extraction.analysis.html#target_extraction.analysis.sentiment_error_analysis.tssr_target_value">[docs]</a><span class="k">def</span> <span class="nf">tssr_target_value</span><span class="p">(</span><span class="n">target_data</span><span class="p">:</span> <span class="n">TargetText</span><span class="p">,</span> 
                      <span class="n">current_target_sentiment</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
                      <span class="n">subset_values</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Need to insert the TSSR value equation below:</span>
<span class="sd">    `</span>
<span class="sd">    `</span>

<span class="sd">    :param target_data: The TargetText object that contains the target </span>
<span class="sd">                        associated to the `current_target_sentiment`</span>
<span class="sd">    :param current_target_sentiment: The sentiment value associated to the </span>
<span class="sd">                                        target you want the TSSR value for.</span>
<span class="sd">    :param subset_values: If True it produceds to different values for when the</span>
<span class="sd">                          TSSR value is 1.0. It produces just 1.0 when there </span>
<span class="sd">                          is only one target in the sentence and </span>
<span class="sd">                          1.1 when there is more than one target in the sentence </span>
<span class="sd">                          but all of them are 1.0 TSSR value i.e. the sentence </span>
<span class="sd">                          only contains one sentiment.</span>
<span class="sd">    :returns: The TSSR value for a target within `target_data` with </span>
<span class="sd">                `current_target_sentiment` sentiment value.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">number_targets</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_data</span><span class="p">[</span><span class="s1">&#39;targets&#39;</span><span class="p">])</span>
    <span class="n">sentiment_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">sentiment</span> <span class="k">for</span> <span class="n">sentiment</span> <span class="ow">in</span> 
                        <span class="n">target_data</span><span class="p">[</span><span class="s1">&#39;target_sentiments&#39;</span><span class="p">]]</span>
    <span class="n">sentiment_counts</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">sentiment_values</span><span class="p">)</span>
    <span class="n">current_target_senti_count</span> <span class="o">=</span> <span class="n">sentiment_counts</span><span class="p">[</span><span class="n">current_target_sentiment</span><span class="p">]</span>
    <span class="n">tssr_value</span> <span class="o">=</span> <span class="n">current_target_senti_count</span> <span class="o">/</span> <span class="n">number_targets</span>
    <span class="n">tssr_value</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">tssr_value</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">subset_values</span> <span class="ow">and</span> <span class="n">tssr_value</span> <span class="o">==</span> <span class="mf">1.0</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_data</span><span class="p">[</span><span class="s1">&#39;targets&#39;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">tssr_value</span> <span class="o">=</span> <span class="mf">1.1</span>
    <span class="k">return</span> <span class="n">tssr_value</span></div>

<div class="viewcode-block" id="tssr_subset"><a class="viewcode-back" href="../../../target_extraction.analysis.html#target_extraction.analysis.sentiment_error_analysis.tssr_subset">[docs]</a><span class="k">def</span> <span class="nf">tssr_subset</span><span class="p">(</span><span class="n">dataset</span><span class="p">:</span> <span class="n">TargetTextCollection</span><span class="p">,</span> 
                <span class="n">return_tssr_boundaries</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">TargetTextCollection</span><span class="p">,</span>
                           <span class="n">Tuple</span><span class="p">[</span><span class="n">TargetTextCollection</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]]]:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Given a dataset it will add either `1-multi-TSSR`, `1-TSSR`, `high-TSSR` or `low-TSSR` </span>
<span class="sd">    error keys to each target text object. Each value associated to the error </span>
<span class="sd">    keys are a list of 1&#39;s or 0&#39;s the length of the number of samples where 1 </span>
<span class="sd">    denotes the error key is True and 0 otherwise. For more information on how </span>
<span class="sd">    TSSR is calculated see </span>
<span class="sd">    :py:func`target_extraction.error_analysis.tssr_target_value`. Once you know </span>
<span class="sd">    what TSSR is: `1-TSSR` contains all of the targets that have a TSSR value of  </span>
<span class="sd">    1 but each one is the only target in the sentence, `1-multi-TSSR` contains </span>
<span class="sd">    all of the targets that have a TSSR value of 1 and the sentence it comes </span>
<span class="sd">    from contain more than one target. `high-TSSR` are targets that are in the </span>
<span class="sd">    top 50% of the TSSR values for this dataset excluding the `1-TSSR` samples, </span>
<span class="sd">    `low-TSSR` are the bottom 50% of the TSSR values.</span>

<span class="sd">    :param dataset: The dataset to add the continuos TSSR error keys too.</span>
<span class="sd">    :param return_tssr_boundaries: If to return the TSSR value boundaries for the </span>
<span class="sd">                                   `1-TSSR`, `high-TSSR`, and `low-TSSR` </span>
<span class="sd">                                   subsets. NOTE that `1-multi-TSSR` is not </span>
<span class="sd">                                   in that list as it would have the same </span>
<span class="sd">                                   TSSR value boundaries as `1-TSSR`.</span>
<span class="sd">    :returns: The same dataset but with each TargetText object containing the </span>
<span class="sd">              TSSR subset error keys and associated list of 1&#39;s or 0&#39;s </span>
<span class="sd">              denoting if the error key exists or not. The optional second </span>
<span class="sd">              Tuple return are a list of the tssr boundaries.</span>
<span class="sd">    :raises NoSamplesError: If there are no samples within a subset.</span>
<span class="sd">    &#39;&#39;&#39;</span> 
    <span class="k">def</span> <span class="nf">error_func</span><span class="p">(</span><span class="n">target</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> 
                   <span class="n">train_target_sentiments</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
                   <span class="n">filtered_values</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
                   <span class="n">target_sentiment</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> 
                   <span class="n">target_data</span><span class="p">:</span> <span class="n">TargetText</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">tssr_value</span> <span class="o">=</span> <span class="n">tssr_target_value</span><span class="p">(</span><span class="n">target_data</span><span class="p">,</span> <span class="n">target_sentiment</span><span class="p">,</span> 
                                       <span class="n">subset_values</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tssr_value</span> <span class="ow">in</span> <span class="n">filtered_values</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="c1"># Possible values for the given dataset</span>
    <span class="n">tssr_values_count</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">target_data</span> <span class="ow">in</span> <span class="n">dataset</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="n">tssr_values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">target_sentiment</span> <span class="ow">in</span> <span class="n">target_data</span><span class="p">[</span><span class="s1">&#39;target_sentiments&#39;</span><span class="p">]:</span>
            <span class="n">tssr_value</span> <span class="o">=</span> <span class="n">tssr_target_value</span><span class="p">(</span><span class="n">target_data</span><span class="p">,</span> <span class="n">target_sentiment</span><span class="p">,</span> 
                                           <span class="n">subset_values</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">tssr_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tssr_value</span><span class="p">)</span>
        <span class="n">tssr_values_count</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">tssr_values</span><span class="p">)</span>
    <span class="c1"># Split the TSSR values into low and high after removing the one values</span>
    <span class="n">tssr_error_name_condition</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">tssr_error_name_condition</span><span class="p">[</span><span class="s1">&#39;1-TSSR&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
    <span class="n">tssr_error_name_condition</span><span class="p">[</span><span class="s1">&#39;1-multi-TSSR&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mf">1.1</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
    <span class="k">del</span> <span class="n">tssr_values_count</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">del</span> <span class="n">tssr_values_count</span><span class="p">[</span><span class="mf">1.1</span><span class="p">]</span>
    <span class="n">tssr_values_count</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">tssr_values_count</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> 
                               <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">total_samples</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">count</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">tssr_values_count</span><span class="p">])</span>
    <span class="n">half_samples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">total_samples</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">high_count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">high_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">temp_tssr_values_count</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">tssr_values_count</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">tssr_value</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">tssr_values_count</span><span class="p">:</span>
        <span class="n">high_count</span> <span class="o">+=</span> <span class="n">count</span>
        <span class="k">if</span> <span class="n">high_count</span> <span class="o">&gt;</span> <span class="n">half_samples</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">high_dict</span><span class="p">[</span><span class="n">tssr_value</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">del</span> <span class="n">temp_tssr_values_count</span><span class="p">[</span><span class="n">tssr_value</span><span class="p">]</span>
    <span class="n">tssr_error_name_condition</span><span class="p">[</span><span class="s1">&#39;high-TSSR&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">high_dict</span>
    <span class="n">tssr_values_count</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">temp_tssr_values_count</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> 
                               <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">low_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">tssr_value</span><span class="p">:</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">tssr_value</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">tssr_values_count</span><span class="p">}</span>
    <span class="n">tssr_error_name_condition</span><span class="p">[</span><span class="s1">&#39;low-TSSR&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">low_dict</span>
    
    <span class="c1"># Raise ValueError if not enough samples in any of the subsets.</span>
    <span class="k">for</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">tssr_error_name_condition</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">enough_sample_err</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Not enough samples in the &#39;</span>
                                 <span class="sa">f</span><span class="s1">&#39;TargetTextCollection </span><span class="si">{</span><span class="n">dataset</span><span class="si">}</span><span class="s1"> to generate &#39;</span>
                                 <span class="s1">&#39;low, high, 1-TSSR, or 1-multi-TSSR subsets. &#39;</span>
                                 <span class="s1">&#39;The subsets within TSSR that were generated &#39;</span>
                                 <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">tssr_error_name_condition</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">NoSamplesError</span><span class="p">(</span><span class="n">enough_sample_err</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">error_name</span><span class="p">,</span> <span class="n">tssr_values</span> <span class="ow">in</span> <span class="n">tssr_error_name_condition</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">dataset</span> <span class="o">=</span> <span class="n">_pre_post_subsampling</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> 
                                        <span class="n">error_name</span><span class="p">,</span> <span class="n">error_func</span><span class="p">,</span> 
                                        <span class="n">train_dict</span><span class="o">=</span><span class="p">{},</span> <span class="n">test_dict</span><span class="o">=</span><span class="n">tssr_values</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">return_tssr_boundaries</span><span class="p">:</span>
        <span class="n">high_tssr_values</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">high_dict</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> 
                                  <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">high_values</span> <span class="o">=</span> <span class="p">(</span><span class="n">high_tssr_values</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">high_tssr_values</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">low_tssr_values</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">low_dict</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> 
                                 <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">low_values</span> <span class="o">=</span> <span class="p">(</span><span class="n">low_tssr_values</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">low_tssr_values</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">dataset</span><span class="p">,</span> <span class="p">[(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span> <span class="n">high_values</span><span class="p">,</span> <span class="n">low_values</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">dataset</span></div>

<div class="viewcode-block" id="tssr_raw"><a class="viewcode-back" href="../../../target_extraction.analysis.html#target_extraction.analysis.sentiment_error_analysis.tssr_raw">[docs]</a><span class="k">def</span> <span class="nf">tssr_raw</span><span class="p">(</span><span class="n">dataset</span><span class="p">:</span> <span class="n">TargetTextCollection</span>
             <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">TargetTextCollection</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Given a dataset it will add a continuos number of error keys to each target text </span>
<span class="sd">    object, where each key represents the TSSR value that the associated target </span>
<span class="sd">    is within. Each value associated to the error keys are a list of 1&#39;s or 0&#39;s </span>
<span class="sd">    the length of the number of samples where 1 denotes the error key is True </span>
<span class="sd">    and 0 otherwise. See </span>
<span class="sd">    :py:func`target_extraction.error_analysis.tssr_target_value` for an </span>
<span class="sd">    explanation of how the TSSR value is calculated.</span>

<span class="sd">    :param dataset: The dataset to add the continuos TSSR error keys too.</span>
<span class="sd">    :returns: The same dataset but with each TargetText object containing the </span>
<span class="sd">              continuos TSSR error keys and associated list of 1&#39;s or 0&#39;s </span>
<span class="sd">              denoting if the error key exists or not. The dictionary contains </span>
<span class="sd">              keys which are the TSSR values detected in the dataset and the </span>
<span class="sd">              values are the number of targets that contain that TSSR value.</span>
<span class="sd">    &#39;&#39;&#39;</span> 
    <span class="k">def</span> <span class="nf">error_func</span><span class="p">(</span><span class="n">target</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> 
                   <span class="n">train_target_sentiments</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
                   <span class="n">filtered_values</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
                   <span class="n">target_sentiment</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> 
                   <span class="n">target_data</span><span class="p">:</span> <span class="n">TargetText</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">tssr_value</span> <span class="o">=</span> <span class="n">tssr_target_value</span><span class="p">(</span><span class="n">target_data</span><span class="p">,</span> <span class="n">target_sentiment</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tssr_value</span> <span class="ow">in</span> <span class="n">filtered_values</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="c1"># Possible values for the given dataset</span>
    <span class="n">tssr_values_count</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">target_data</span> <span class="ow">in</span> <span class="n">dataset</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="n">tssr_values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">target_sentiment</span> <span class="ow">in</span> <span class="n">target_data</span><span class="p">[</span><span class="s1">&#39;target_sentiments&#39;</span><span class="p">]:</span>
            <span class="n">tssr_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tssr_target_value</span><span class="p">(</span><span class="n">target_data</span><span class="p">,</span> <span class="n">target_sentiment</span><span class="p">))</span>
        <span class="n">tssr_values_count</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">tssr_values</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">tssr_value</span> <span class="ow">in</span> <span class="n">tssr_values_count</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">dataset</span> <span class="o">=</span> <span class="n">_pre_post_subsampling</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> 
                                        <span class="nb">str</span><span class="p">(</span><span class="n">tssr_value</span><span class="p">),</span> <span class="n">error_func</span><span class="p">,</span> 
                                        <span class="n">train_dict</span><span class="o">=</span><span class="p">{},</span> <span class="n">test_dict</span><span class="o">=</span><span class="p">{</span><span class="n">tssr_value</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span>
    <span class="n">tssr_values_count</span> <span class="o">=</span> <span class="p">{</span><span class="nb">str</span><span class="p">(</span><span class="n">tssr_value</span><span class="p">):</span> <span class="n">count</span> 
                         <span class="k">for</span> <span class="n">tssr_value</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">tssr_values_count</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="k">return</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">tssr_values_count</span></div>

<div class="viewcode-block" id="swap_list_dimensions"><a class="viewcode-back" href="../../../target_extraction.analysis.html#target_extraction.analysis.sentiment_error_analysis.swap_list_dimensions">[docs]</a><span class="k">def</span> <span class="nf">swap_list_dimensions</span><span class="p">(</span><span class="n">collection</span><span class="p">:</span> <span class="n">TargetTextCollection</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span>
                                  <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TargetTextCollection</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    :param collection: The TargetTextCollection to change</span>
<span class="sd">    :param key: The key within the TargetText objects in the collection that </span>
<span class="sd">                contain a List Value of shape (dim 1, dim 2)</span>
<span class="sd">    :returns: The collection but with the `key` values shape changed from </span>
<span class="sd">              (dim 1, dim 2) to (dim 2, dim 1)</span>

<span class="sd">    :Note: This is a useful function when you need to change the predicted </span>
<span class="sd">           values from shape (number runs, number targets) to </span>
<span class="sd">           (number target, number runs) before using the following </span>
<span class="sd">           function `reduce_collection_by_key_occurrence` where one of the </span>
<span class="sd">           `associated_keys` are predicted values. It is required that the </span>
<span class="sd">           sentiment predictions are of shape (number runs, number targets) </span>
<span class="sd">           for the `sentiment_metrics` functions.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">new_target_objects</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">anonymised</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">for</span> <span class="n">target_object</span> <span class="ow">in</span> <span class="n">collection</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="n">target_object</span><span class="p">:</span> <span class="n">TargetText</span>
        <span class="n">target_object</span><span class="o">.</span><span class="n">_key_error</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">new_target_object_dict</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">target_object</span><span class="p">))</span>
        <span class="n">value_to_change</span> <span class="o">=</span> <span class="n">new_target_object_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="n">new_value</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">dim_1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">value_to_change</span><span class="p">)</span>
        <span class="n">dim_2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">value_to_change</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">index_1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim_1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">index_2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim_2</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">index_1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">new_value</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                <span class="n">new_value</span><span class="p">[</span><span class="n">index_2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value_to_change</span><span class="p">[</span><span class="n">index_1</span><span class="p">][</span><span class="n">index_2</span><span class="p">])</span>
        <span class="n">new_target_object_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_value</span>
        <span class="k">if</span> <span class="s1">&#39;text&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">new_target_object_dict</span><span class="p">:</span>
            <span class="n">new_target_object_dict</span><span class="p">[</span><span class="s1">&#39;text&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">new_target_object_dict</span><span class="p">[</span><span class="s1">&#39;text&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">anonymised</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">new_target_object_dict</span><span class="p">[</span><span class="s1">&#39;anonymised&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">new_target_objects</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">TargetText</span><span class="p">(</span><span class="o">**</span><span class="n">new_target_object_dict</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">TargetTextCollection</span><span class="p">(</span><span class="n">new_target_objects</span><span class="p">,</span> <span class="n">anonymised</span><span class="o">=</span><span class="n">anonymised</span><span class="p">)</span></div>

<div class="viewcode-block" id="error_analysis_wrapper"><a class="viewcode-back" href="../../../target_extraction.analysis.html#target_extraction.analysis.sentiment_error_analysis.error_analysis_wrapper">[docs]</a><span class="k">def</span> <span class="nf">error_analysis_wrapper</span><span class="p">(</span><span class="n">error_function_name</span><span class="p">:</span> <span class="nb">str</span>
                           <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">TargetTextCollection</span><span class="p">,</span> 
                                          <span class="n">TargetTextCollection</span><span class="p">,</span> 
                                          <span class="nb">bool</span><span class="p">],</span> <span class="n">TargetTextCollection</span><span class="p">]:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    To get a list of all possible function names easily use the `keys` of </span>
<span class="sd">    `target_extraction.analysis.sentiment_error_analysis.ERROR_SPLIT_SUBSET_NAMES`</span>
<span class="sd">    dictionary.</span>

<span class="sd">    :param error_function_name: This can be either 1. `DS`, 2. `NT`, 3. `TSSR`, </span>
<span class="sd">                                4. `n-shot`, 5. `TSR`</span>
<span class="sd">    :returns: The relevant error function where all error functions have the same </span>
<span class="sd">                function signature where the input is:</span>
<span class="sd">                1. Train TargetTextCollection, 2. Test TargetTextCollection, and </span>
<span class="sd">                3. Lower bool - whether to lower the targets.</span>
<span class="sd">                This then returns a the Test TargetTextCollection with the relevant </span>
<span class="sd">                new keys. From the inputs only the Train and Lower are applicable </span>
<span class="sd">                to `n-shot` and `TSR` error function due to them both being </span>
<span class="sd">                global functions and relying on target text information.</span>
<span class="sd">    :raises ValueError: If the `error_function_name` is not one of the 5 listed. </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">ds_wrapper</span><span class="p">(</span><span class="n">train_collection</span><span class="p">:</span> <span class="n">TargetTextCollection</span><span class="p">,</span> 
                    <span class="n">test_collection</span><span class="p">:</span> <span class="n">TargetTextCollection</span><span class="p">,</span> 
                    <span class="n">lower</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TargetTextCollection</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        :param train_collection: Not Applicable</span>
<span class="sd">        :param test_collection: The collection that is to be analysed</span>
<span class="sd">        :param lower: Lowering the target words Not Applicable</span>
<span class="sd">        :returns: A TargetTextCollection with the follwoing extra keys:</span>
<span class="sd">                `distinct_sentiment_1` `distinct_sentiment_2`, and</span>
<span class="sd">                `distinct_sentiment_3` </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="n">distinct_sentiment</span><span class="p">(</span><span class="n">test_collection</span><span class="p">,</span> <span class="n">separate_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">tssr_wrapper</span><span class="p">(</span><span class="n">train_collection</span><span class="p">:</span> <span class="n">TargetTextCollection</span><span class="p">,</span> 
                    <span class="n">test_collection</span><span class="p">:</span> <span class="n">TargetTextCollection</span><span class="p">,</span> 
                    <span class="n">lower</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TargetTextCollection</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        :param train_collection: Not Applicable</span>
<span class="sd">        :param test_collection: The collection that is to be analysed</span>
<span class="sd">        :param lower: Lowering the target words Not Applicable</span>
<span class="sd">        :returns: A TargetTextCollection with the follwoing extra keys:</span>
<span class="sd">                `1-TSSR` `1-multi-TSSR`, `low-TSSR`, and</span>
<span class="sd">                `high-TSSR` </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="n">tssr_subset</span><span class="p">(</span><span class="n">test_collection</span><span class="p">,</span> <span class="n">return_tssr_boundaries</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">nt_wrapper</span><span class="p">(</span><span class="n">train_collection</span><span class="p">:</span> <span class="n">TargetTextCollection</span><span class="p">,</span> 
                    <span class="n">test_collection</span><span class="p">:</span> <span class="n">TargetTextCollection</span><span class="p">,</span> 
                    <span class="n">lower</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TargetTextCollection</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        :param train_collection: Not Applicable</span>
<span class="sd">        :param test_collection: The collection that is to be analysed</span>
<span class="sd">        :param lower: Lowering the target words Not Applicable</span>
<span class="sd">        :returns: A TargetTextCollection with the follwoing extra keys:</span>
<span class="sd">                `1-target` `low-targets`, `med-targets`, and</span>
<span class="sd">                `high-targets` </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="n">num_targets_subset</span><span class="p">(</span><span class="n">test_collection</span><span class="p">,</span> <span class="n">return_n_values</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">tsr_wrapper</span><span class="p">(</span><span class="n">train_collection</span><span class="p">:</span> <span class="n">TargetTextCollection</span><span class="p">,</span> 
                    <span class="n">test_collection</span><span class="p">:</span> <span class="n">TargetTextCollection</span><span class="p">,</span> 
                    <span class="n">lower</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TargetTextCollection</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        :param train_collection: The collection to compare the Test collection with.</span>
<span class="sd">        :param test_collection: The collection that is to be analysed</span>
<span class="sd">        :param lower: Lowering the target words</span>
<span class="sd">        :returns: A TargetTextCollection with the follwoing extra keys:</span>
<span class="sd">                `unknown_sentiment_known_target` `unknown_targets`, and</span>
<span class="sd">                `known_sentiment_known_target` </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">subset_functions</span> <span class="o">=</span> <span class="p">[</span><span class="n">unknown_targets</span><span class="p">,</span> <span class="n">unknown_sentiment_known_target</span><span class="p">,</span> 
                            <span class="n">known_sentiment_known_target</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">subset_function</span> <span class="ow">in</span> <span class="n">subset_functions</span><span class="p">:</span>
            <span class="n">test_collection</span> <span class="o">=</span> <span class="n">subset_function</span><span class="p">(</span><span class="n">test_collection</span><span class="p">,</span> <span class="n">train_collection</span><span class="p">,</span> 
                                              <span class="n">lower</span><span class="o">=</span><span class="n">lower</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">test_collection</span>
    
    <span class="k">def</span> <span class="nf">n_shot_wrapper</span><span class="p">(</span><span class="n">train_collection</span><span class="p">:</span> <span class="n">TargetTextCollection</span><span class="p">,</span> 
                        <span class="n">test_collection</span><span class="p">:</span> <span class="n">TargetTextCollection</span><span class="p">,</span> 
                        <span class="n">lower</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TargetTextCollection</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        :param train_collection: The collection to compare the Test collection with.</span>
<span class="sd">        :param test_collection: The collection that is to be analysed</span>
<span class="sd">        :param lower: Lowering the target words</span>
<span class="sd">        :returns: A TargetTextCollection with the follwoing extra keys:</span>
<span class="sd">                `zero-shot` `low-shot`, `med-shot`, and</span>
<span class="sd">                `high-shot` </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="n">n_shot_subsets</span><span class="p">(</span><span class="n">test_collection</span><span class="p">,</span> <span class="n">train_collection</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="n">lower</span><span class="p">,</span> 
                              <span class="n">return_n_values</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    
    <span class="n">acceptable_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">ERROR_SPLIT_SUBSET_NAMES</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">error_function_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">acceptable_names</span><span class="p">:</span>
        <span class="n">value_error</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;This error function name is not allowed &#39;</span>
                    <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">error_function_name</span><span class="si">}</span><span class="s1">. These names are allowed &#39;</span>
                    <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">acceptable_names</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">value_error</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">error_function_name</span> <span class="o">==</span> <span class="s1">&#39;DS&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ds_wrapper</span>
    <span class="k">elif</span> <span class="n">error_function_name</span> <span class="o">==</span> <span class="s1">&#39;TSSR&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">tssr_wrapper</span>
    <span class="k">elif</span> <span class="n">error_function_name</span> <span class="o">==</span> <span class="s1">&#39;NT&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">nt_wrapper</span>
    <span class="k">elif</span> <span class="n">error_function_name</span> <span class="o">==</span> <span class="s1">&#39;n-shot&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">n_shot_wrapper</span>
    <span class="k">elif</span> <span class="n">error_function_name</span> <span class="o">==</span> <span class="s1">&#39;TSR&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">tsr_wrapper</span></div>

<div class="viewcode-block" id="subset_metrics"><a class="viewcode-back" href="../../../target_extraction.analysis.html#target_extraction.analysis.sentiment_error_analysis.subset_metrics">[docs]</a><span class="k">def</span> <span class="nf">subset_metrics</span><span class="p">(</span><span class="n">target_collection</span><span class="p">:</span> <span class="n">TargetTextCollection</span><span class="p">,</span> 
                   <span class="n">subset_error_key</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
                   <span class="n">metric_funcs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">TargetTextCollection</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> 
                                                <span class="nb">bool</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">bool</span><span class="p">],</span> 
                                               <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]]],</span>
                   <span class="n">metric_names</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> 
                   <span class="n">metric_kwargs</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span><span class="nb">bool</span><span class="p">,</span><span class="nb">int</span><span class="p">]],</span>
                   <span class="n">include_dataset_size</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
                   <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    This is most useful to find the metric score of an error subset</span>
<span class="sd">     </span>
<span class="sd">    :param target_collection: TargetTextCollection that contains the </span>
<span class="sd">                              `subset_error_key` in each TargetText within the </span>
<span class="sd">                              collection</span>
<span class="sd">    :param subset_error_key: The error key(s) to reduce the collection by. The samples </span>
<span class="sd">                             left will only be those where the error key is True.</span>
<span class="sd">                             An example of a `subset_error_key` would be </span>
<span class="sd">                             `zero-shot` from the :py:func:`n_shot_targets`. This </span>
<span class="sd">                             can also be a list of keys e.g. </span>
<span class="sd">                             [`zero-shot`, `low-shot`] from the </span>
<span class="sd">                             :py:func:`n_shot_targets`.</span>
<span class="sd">    :param metric_funcs: A list of metric functions from </span>
<span class="sd">                         `target_extraction.analysis.sentiment_metrics`. Example</span>
<span class="sd">                         metric function is </span>
<span class="sd">                         :py:func:`target_extraction.analysis.sentiment_metrics.accuracy`</span>
<span class="sd">    :param metric_names: Names to give to each `metric_funcs`</span>
<span class="sd">    :param metric_kwargs: Keywords argument to give to the `metric_funcs` the only </span>
<span class="sd">                          argument given is the first argument which will always </span>
<span class="sd">                          be `target_collection`</span>
<span class="sd">    :param include_dataset_size: If True the returned dictionary will also include </span>
<span class="sd">                                 a key `dataset size` that will contain an integer</span>
<span class="sd">                                 specifying the size of the dataset the metric(s) </span>
<span class="sd">                                 was calculated on.</span>
<span class="sd">    :returns: A dictionary where the keys are the `metric_names` and the values </span>
<span class="sd">              are the respective metric applied to the reduced/subsetted dataset.</span>
<span class="sd">              Thus if `average` in `metric_kwargs` is True then the return </span>
<span class="sd">              will be Dict[str, float] where as if `array_scores` is True then </span>
<span class="sd">              the return will be Dict[str, List[float]]. If no targets exist in </span>
<span class="sd">              the collection through subsetting then the metric returned is 0.0</span>
<span class="sd">              or [0.0] if `array_scores` is true in `metric_kwargs`.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">true_sentiment_key</span> <span class="o">=</span> <span class="n">metric_kwargs</span><span class="p">[</span><span class="s1">&#39;true_sentiment_key&#39;</span><span class="p">]</span>
    <span class="n">predicted_sentiment_key</span> <span class="o">=</span> <span class="n">metric_kwargs</span><span class="p">[</span><span class="s1">&#39;predicted_sentiment_key&#39;</span><span class="p">]</span>
    <span class="n">target_collection</span> <span class="o">=</span> <span class="n">swap_and_reduce</span><span class="p">(</span><span class="n">target_collection</span><span class="p">,</span> <span class="n">subset_error_key</span><span class="p">,</span> 
                                        <span class="n">true_sentiment_key</span><span class="p">,</span> 
                                        <span class="p">[</span><span class="n">predicted_sentiment_key</span><span class="p">])</span>
    <span class="n">metric_name_score</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">include_dataset_size</span><span class="p">:</span>
        <span class="n">metric_name_score</span><span class="p">[</span><span class="s1">&#39;dataset size&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">target_collection</span><span class="o">.</span><span class="n">number_targets</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">metric_name</span><span class="p">,</span> <span class="n">metric_func</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">metric_names</span><span class="p">,</span> <span class="n">metric_funcs</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_collection</span><span class="p">):</span>
            <span class="k">if</span> <span class="s1">&#39;array_scores&#39;</span> <span class="ow">in</span> <span class="n">metric_kwargs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">metric_kwargs</span><span class="p">[</span><span class="s1">&#39;array_scores&#39;</span><span class="p">]:</span>
                    <span class="n">metric_score</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">metric_score</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">metric_score</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">metric_score</span> <span class="o">=</span> <span class="n">metric_func</span><span class="p">(</span><span class="n">target_collection</span><span class="p">,</span> <span class="o">**</span><span class="n">metric_kwargs</span><span class="p">)</span>
        <span class="n">metric_name_score</span><span class="p">[</span><span class="n">metric_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">metric_score</span>
    <span class="k">return</span> <span class="n">metric_name_score</span></div>


<span class="k">def</span> <span class="nf">_subset_and_score</span><span class="p">(</span><span class="n">arguments</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">TargetTextCollection</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> 
                                       <span class="n">Callable</span><span class="p">[[</span><span class="n">TargetTextCollection</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> 
                                                 <span class="nb">bool</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">bool</span><span class="p">],</span> 
                                                <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]],</span> 
                                       <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="nb">bool</span><span class="p">]</span>
                      <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
                                 <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    :param arguments: A tuple of 1. data, 2. subset name, 3. metric function,</span>
<span class="sd">                      4. Keyword arguments to give to the metric function, 5.</span>
<span class="sd">                      include_dataset_size whether or not to return the dataset</span>
<span class="sd">                      size that the metric was performed on. The metric function</span>
<span class="sd">                      should be one from </span>
<span class="sd">                      `target_extraction.analysis.sentiment_metrics`. The only </span>
<span class="sd">                      argument given to the metric function is the first argument </span>
<span class="sd">                      (data collection) as that argument comes from `data`</span>
<span class="sd">                      argument. This function in affect subsets the `data` by </span>
<span class="sd">                      the `subset name` and then provides the metric scores on</span>
<span class="sd">                      that subset.</span>
<span class="sd">    :returns: A tuple of 1. List of metric scores, 2. List of run numbers,</span>
<span class="sd">              3. List of subset names, 4. List of predictions keys, 5. IF</span>
<span class="sd">              include_dataset_size is True then the size of the subset dataset. The</span>
<span class="sd">              run number is essentially range(0,len(metric_scores)). The </span>
<span class="sd">              list of subset names and prediction keys are the same value </span>
<span class="sd">              as given just multipled by the number of runs. Thus all of the </span>
<span class="sd">              list are of the same length.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># Metirc name is only required if there will be more than one metric function </span>
    <span class="c1"># which at the moment cannot happen but could be a useful future improvement</span>
    <span class="n">metric_name</span> <span class="o">=</span> <span class="s1">&#39;A Name&#39;</span>
    <span class="c1"># un-pack arguments</span>
    <span class="n">data_collection</span><span class="p">,</span> <span class="n">subset_name</span><span class="p">,</span> <span class="n">_metric_function</span><span class="p">,</span> <span class="n">metric_kwargs</span><span class="p">,</span> <span class="n">include_dataset_size</span> <span class="o">=</span> <span class="n">arguments</span>
    <span class="n">prediction_key</span> <span class="o">=</span> <span class="n">metric_kwargs</span><span class="p">[</span><span class="s1">&#39;predicted_sentiment_key&#39;</span><span class="p">]</span>
    <span class="n">metric_values</span> <span class="o">=</span> <span class="n">subset_metrics</span><span class="p">(</span><span class="n">data_collection</span><span class="p">,</span> <span class="n">subset_name</span><span class="p">,</span> 
                                    <span class="p">[</span><span class="n">_metric_function</span><span class="p">],</span> 
                                    <span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">metric_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">],</span> <span class="n">metric_kwargs</span><span class="p">,</span> 
                                    <span class="n">include_dataset_size</span><span class="o">=</span><span class="n">include_dataset_size</span><span class="p">)</span>
    <span class="n">metric_scores</span> <span class="o">=</span> <span class="n">metric_values</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">metric_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">]</span>
    <span class="n">pd_run_numbers</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">pd_subset_names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">pd_prediction_keys</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">run_number</span><span class="p">,</span> <span class="n">metric_score</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">metric_scores</span><span class="p">):</span>
        <span class="n">pd_run_numbers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">run_number</span><span class="p">)</span>
        <span class="n">pd_subset_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subset_name</span><span class="p">)</span>
        <span class="n">pd_prediction_keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prediction_key</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">include_dataset_size</span><span class="p">:</span>
        <span class="n">subset_dataset_size</span> <span class="o">=</span> <span class="p">[</span><span class="n">metric_values</span><span class="p">[</span><span class="s1">&#39;dataset size&#39;</span><span class="p">]]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">metric_scores</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">metric_scores</span><span class="p">,</span> <span class="n">pd_run_numbers</span><span class="p">,</span> <span class="n">pd_subset_names</span><span class="p">,</span> <span class="n">pd_prediction_keys</span><span class="p">,</span>
                <span class="n">subset_dataset_size</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">metric_scores</span><span class="p">,</span> <span class="n">pd_run_numbers</span><span class="p">,</span> <span class="n">pd_subset_names</span><span class="p">,</span> <span class="n">pd_prediction_keys</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_subset_and_score_args_generator</span><span class="p">(</span><span class="n">target_collection</span><span class="p">:</span> <span class="n">TargetTextCollection</span><span class="p">,</span>
                                     <span class="n">prediction_keys</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
                                     <span class="n">error_split_subset_names</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
                                     <span class="n">metric_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">TargetTextCollection</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> 
                                                            <span class="nb">bool</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">bool</span><span class="p">],</span> 
                                                           <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]],</span> 
                                     <span class="n">metric_kwargs</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span><span class="nb">int</span><span class="p">,</span><span class="nb">bool</span><span class="p">]],</span>
                                     <span class="n">include_dataset_size</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
                                     <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">TargetTextCollection</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> 
                                                         <span class="n">Callable</span><span class="p">[[</span><span class="n">TargetTextCollection</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> 
                                                                   <span class="nb">bool</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">bool</span><span class="p">],</span> 
                                                                  <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]],</span> 
                                                         <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]]:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    This is used to generate arguments to pass to the :py:func:`_subset_and_score`</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">metric_kwargs_copy</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">metric_kwargs</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">prediction_key</span> <span class="ow">in</span> <span class="n">prediction_keys</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">error_split_name</span><span class="p">,</span> <span class="n">subset_names</span> <span class="ow">in</span> <span class="n">error_split_subset_names</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">subset_name</span> <span class="ow">in</span> <span class="n">subset_names</span><span class="p">:</span>
                <span class="n">metric_kwargs_copy</span><span class="p">[</span><span class="s1">&#39;predicted_sentiment_key&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">prediction_key</span>
                <span class="k">yield</span> <span class="p">(</span><span class="n">target_collection</span><span class="p">,</span> <span class="n">subset_name</span><span class="p">,</span> 
                       <span class="n">metric_func</span><span class="p">,</span> <span class="n">metric_kwargs_copy</span><span class="p">,</span>
                       <span class="n">include_dataset_size</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_error_split_df</span><span class="p">(</span><span class="n">target_collection</span><span class="p">:</span> <span class="n">TargetTextCollection</span><span class="p">,</span> 
                    <span class="n">prediction_keys</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">true_sentiment_key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> 
                    <span class="n">error_split_subset_names</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
                    <span class="n">metric_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">TargetTextCollection</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> 
                                           <span class="nb">bool</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">bool</span><span class="p">],</span> 
                                          <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]],</span>
                    <span class="n">metric_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">num_cpus</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">collection_subsetting</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">include_dataset_size</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                    <span class="n">table_format_return</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    This will require the `target_collection` having been pre-processed with the</span>
<span class="sd">    relevant error analysis functions within this module. A useful function to </span>
<span class="sd">    perform the error analysis would be :py:func:`error_analysis_wrapper`</span>

<span class="sd">    :param target_collection: The collection where all TargetText&#39;s contain </span>
<span class="sd">                              all `prediction_keys`, `true_sentiment_key`, and </span>
<span class="sd">                              `subset_names` from the `error_split_subset_names`.</span>
<span class="sd">    :param prediction_keys: A list of keys that contain the predicted sentiment </span>
<span class="sd">                            scores for each target in the TargetTextCollection</span>
<span class="sd">    :param true_sentiment_key: Key that contains the true sentiment scores </span>
<span class="sd">                               for each target in the TargetTextCollection</span>
<span class="sd">    :param error_split_subset_names: The keys do not matter but the List values </span>
<span class="sd">                                     must represent error subset names. An </span>
<span class="sd">                                     example dictionary would be:</span>
<span class="sd">                                     `ERROR_SPLIT_SUBSET_NAMES`</span>
<span class="sd">    :param metric_func: A Metric function from</span>
<span class="sd">                        `target_extraction.analysis.sentiment_metrics`. Example</span>
<span class="sd">                         metric function is </span>
<span class="sd">                         :py:func:`target_extraction.analysis.sentiment_metrics.accuracy`</span>
<span class="sd">    :param metric_kwargs: Keyword arguments to give to the `metric_func` the </span>
<span class="sd">                          arguments given are: 1. `target_collection`, 2. `true_sentiment_key`,</span>
<span class="sd">                          3. `predicted_sentiment_key`, 4. `average`, and </span>
<span class="sd">                          5. `array_scores`</span>
<span class="sd">    :param num_cpus: Number of cpus to use for multiprocessing. The task of </span>
<span class="sd">                     subsetting and metric scoring is split down into one </span>
<span class="sd">                     task and all tasks are then multiprocessed. This is also </span>
<span class="sd">                     done in a Lazy fashion.   </span>
<span class="sd">    :param collection_subsetting: A list of lists where the outer list represents </span>
<span class="sd">                                  the order of subsetting where as the inner list</span>
<span class="sd">                                  specifies the subset names to subset on. For example</span>
<span class="sd">                                  `[[&#39;1-TSSR&#39;, &#39;high-shot&#39;], [&#39;distinct_sentiment_2&#39;]]`</span>
<span class="sd">                                  would first subset the `test_collection` so that </span>
<span class="sd">                                  only samples that are within [&#39;1-TSSR&#39;, &#39;high-shot&#39;]</span>
<span class="sd">                                  subsets are in the collection and then it would </span>
<span class="sd">                                  subset that collection further so that only </span>
<span class="sd">                                  &#39;distinct_sentiment_2&#39; samples exist in the collection.</span>
<span class="sd">    :param include_dataset_size: The returned DataFrame will have two values the </span>
<span class="sd">                                 metric associated with the error splits and the </span>
<span class="sd">                                 size of the dataset from that subset.</span>
<span class="sd">    :param table_format_return: If this is True then the return will not be a </span>
<span class="sd">                                pivot table but the raw dataframe. This can be </span>
<span class="sd">                                more useful as a return format if `include_dataset_size`</span>
<span class="sd">                                is True. The columns for the DataFrame will be </span>
<span class="sd">                                1. `prediction key`, 2. `run number`, 3. `subset names`</span>
<span class="sd">                                4. `Metric` and 5. Optional `Dataset Size`</span>
<span class="sd">    :returns: A dataframe that has a multi index of [`prediction key`, `run number`]</span>
<span class="sd">              and the columns are the error split subset names and the values are </span>
<span class="sd">              the metric associated to those error splits given the prediction </span>
<span class="sd">              key and the model run (run number). If any of the error subsets </span>
<span class="sd">              do not have any targets that are relevant the accuracy will be </span>
<span class="sd">              0.0</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">pd_run_numbers</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">pd_prediction_keys</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">pd_subset_names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">pd_metric_values</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">pd_dataset_size</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">metric_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">metric_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">metric_kwargs</span><span class="p">[</span><span class="s1">&#39;average&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">metric_kwargs</span><span class="p">[</span><span class="s1">&#39;array_scores&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">metric_kwargs</span><span class="p">[</span><span class="s1">&#39;true_sentiment_key&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">true_sentiment_key</span>

    <span class="k">if</span> <span class="n">collection_subsetting</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">subset_names</span> <span class="ow">in</span> <span class="n">collection_subsetting</span><span class="p">:</span>
            <span class="n">target_collection</span> <span class="o">=</span> <span class="n">swap_and_reduce</span><span class="p">(</span><span class="n">target_collection</span><span class="p">,</span> <span class="n">subset_names</span><span class="p">,</span> 
                                                <span class="n">true_sentiment_key</span><span class="p">,</span> <span class="n">prediction_keys</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">Pool</span><span class="p">(</span><span class="n">num_cpus</span><span class="p">)</span> <span class="k">as</span> <span class="n">p</span><span class="p">:</span>
        <span class="n">args_gen</span> <span class="o">=</span> <span class="n">_subset_and_score_args_generator</span><span class="p">(</span><span class="n">target_collection</span><span class="p">,</span> 
                                                    <span class="n">prediction_keys</span><span class="p">,</span> 
                                                    <span class="n">error_split_subset_names</span><span class="p">,</span> 
                                                    <span class="n">metric_func</span><span class="p">,</span> <span class="n">metric_kwargs</span><span class="p">,</span>
                                                    <span class="n">include_dataset_size</span><span class="o">=</span><span class="n">include_dataset_size</span><span class="p">)</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">imap</span><span class="p">(</span><span class="n">_subset_and_score</span><span class="p">,</span> <span class="n">args_gen</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
            <span class="n">pd_metric_values</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">pd_run_numbers</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">pd_subset_names</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">pd_prediction_keys</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">include_dataset_size</span><span class="p">:</span>
                <span class="n">pd_dataset_size</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>


    <span class="n">data_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;prediction key&#39;</span><span class="p">:</span> <span class="n">pd_prediction_keys</span><span class="p">,</span> 
                            <span class="s1">&#39;run number&#39;</span><span class="p">:</span> <span class="n">pd_run_numbers</span><span class="p">,</span> 
                            <span class="s1">&#39;subset names&#39;</span><span class="p">:</span> <span class="n">pd_subset_names</span><span class="p">,</span> 
                            <span class="s1">&#39;Metric&#39;</span><span class="p">:</span> <span class="n">pd_metric_values</span><span class="p">})</span>
    <span class="k">if</span> <span class="n">include_dataset_size</span><span class="p">:</span>
        <span class="n">data_df</span><span class="p">[</span><span class="s1">&#39;Dataset Size&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd_dataset_size</span>
        <span class="n">table</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">pivot_table</span><span class="p">(</span><span class="n">data_df</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Metric&#39;</span><span class="p">,</span> <span class="s1">&#39;Dataset Size&#39;</span><span class="p">],</span> 
                               <span class="n">columns</span><span class="o">=</span><span class="s1">&#39;subset names&#39;</span><span class="p">,</span>
                               <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;prediction key&#39;</span><span class="p">,</span> <span class="s1">&#39;run number&#39;</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">table</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">pivot_table</span><span class="p">(</span><span class="n">data_df</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="s1">&#39;Metric&#39;</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="s1">&#39;subset names&#39;</span><span class="p">,</span>
                               <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;prediction key&#39;</span><span class="p">,</span> <span class="s1">&#39;run number&#39;</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">table_format_return</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">table</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">data_df</span>

<div class="viewcode-block" id="error_split_df"><a class="viewcode-back" href="../../../target_extraction.analysis.html#target_extraction.analysis.sentiment_error_analysis.error_split_df">[docs]</a><span class="k">def</span> <span class="nf">error_split_df</span><span class="p">(</span><span class="n">train_collection</span><span class="p">:</span> <span class="n">TargetTextCollection</span><span class="p">,</span> 
                   <span class="n">test_collection</span><span class="p">:</span> <span class="n">TargetTextCollection</span><span class="p">,</span>
                   <span class="n">prediction_keys</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">true_sentiment_key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> 
                   <span class="n">error_split_and_subset_names</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
                   <span class="n">metric_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">TargetTextCollection</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> 
                                          <span class="nb">bool</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">bool</span><span class="p">],</span> 
                                         <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]],</span>
                   <span class="n">metric_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                   <span class="n">num_cpus</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                   <span class="n">lower_targets</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                   <span class="n">collection_subsetting</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                   <span class="n">include_dataset_size</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                   <span class="n">table_format_return</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
                   <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    This will perform `error_analysis_wrapper` over all `error_split_subset_names`</span>
<span class="sd">    keys and then returns the output from `_error_split_df`</span>

<span class="sd">    :param train_collection: The collection that was used to train the models </span>
<span class="sd">                             that have made the predictions within </span>
<span class="sd">                             `test_collection`</span>
<span class="sd">    :param test_collection: The collection where all TargetText&#39;s contain </span>
<span class="sd">                            all `prediction_keys`, and `true_sentiment_key`.</span>
<span class="sd">    :param prediction_keys: A list of keys that contain the predicted sentiment </span>
<span class="sd">                            scores for each target in the TargetTextCollection</span>
<span class="sd">    :param true_sentiment_key: Key that contains the true sentiment scores </span>
<span class="sd">                               for each target in the TargetTextCollection</span>
<span class="sd">    :param error_split_and_subset_names: The keys do not matter but the List values </span>
<span class="sd">                                         must represent error subset names. An </span>
<span class="sd">                                         example dictionary would be:</span>
<span class="sd">                                         `ERROR_SPLIT_SUBSET_NAMES`</span>
<span class="sd">    :param metric_func: A Metric function from</span>
<span class="sd">                        `target_extraction.analysis.sentiment_metrics`. Example</span>
<span class="sd">                         metric function is </span>
<span class="sd">                         :py:func:`target_extraction.analysis.sentiment_metrics.accuracy`</span>
<span class="sd">    :param metric_kwargs: Keyword arguments to give to the `metric_func` the </span>
<span class="sd">                          arguments given are: 1. `target_collection`, 2. `true_sentiment_key`,</span>
<span class="sd">                          3. `predicted_sentiment_key`, 4. `average`, and </span>
<span class="sd">                          5. `array_scores`</span>
<span class="sd">    :param num_cpus: Number of cpus to use for multiprocessing. The task of </span>
<span class="sd">                     subsetting and metric scoring is split down into one </span>
<span class="sd">                     task and all tasks are then multiprocessed. This is also </span>
<span class="sd">                     done in a Lazy fashion.</span>
<span class="sd">    :param lower_targets: Whether or not the targets should be lowered during the </span>
<span class="sd">                          `error_analysis_wrapper` function.   </span>
<span class="sd">    :param collection_subsetting: A list of lists where the outer list represents </span>
<span class="sd">                                  the order of subsetting where as the inner list</span>
<span class="sd">                                  specifies the subset names to subset on. For example</span>
<span class="sd">                                  `[[&#39;1-TSSR&#39;, &#39;high-shot&#39;], [&#39;distinct_sentiment_2&#39;]]`</span>
<span class="sd">                                  would first subset the `test_collection` so that </span>
<span class="sd">                                  only samples that are within [&#39;1-TSSR&#39;, &#39;high-shot&#39;]</span>
<span class="sd">                                  subsets are in the collection and then it would </span>
<span class="sd">                                  subset that collection further so that only </span>
<span class="sd">                                  &#39;distinct_sentiment_2&#39; samples exist in the collection.</span>
<span class="sd">    :param include_dataset_size: The returned DataFrame will have two values the </span>
<span class="sd">                                 metric associated with the error splits and the </span>
<span class="sd">                                 size of the dataset from that subset.</span>
<span class="sd">    :param table_format_return: If this is True then the return will not be a </span>
<span class="sd">                                pivot table but the raw dataframe. This can be </span>
<span class="sd">                                more useful as a return format if `include_dataset_size`</span>
<span class="sd">                                is True. </span>
<span class="sd">    :returns: A dataframe that has a multi index of [`prediction key`, `run number`]</span>
<span class="sd">              and the columns are the error split subset names and the values are </span>
<span class="sd">              the metric associated to those error splits given the prediction </span>
<span class="sd">              key and the model run (run number)</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">for</span> <span class="n">error_split</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">error_split_and_subset_names</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">error_function</span> <span class="o">=</span> <span class="n">error_analysis_wrapper</span><span class="p">(</span><span class="n">error_split</span><span class="p">)</span>
        <span class="n">test_collection</span> <span class="o">=</span> <span class="n">error_function</span><span class="p">(</span><span class="n">train_collection</span><span class="p">,</span> <span class="n">test_collection</span><span class="p">,</span> 
                                         <span class="n">lower</span><span class="o">=</span><span class="n">lower_targets</span><span class="p">)</span>
    <span class="n">error_analysis_df</span> <span class="o">=</span> <span class="n">_error_split_df</span><span class="p">(</span><span class="n">test_collection</span><span class="p">,</span> <span class="n">prediction_keys</span><span class="p">,</span> 
                                        <span class="n">true_sentiment_key</span><span class="p">,</span> 
                                        <span class="n">error_split_and_subset_names</span><span class="p">,</span> 
                                        <span class="n">metric_func</span><span class="p">,</span> <span class="n">metric_kwargs</span><span class="p">,</span> <span class="n">num_cpus</span><span class="p">,</span>
                                        <span class="n">collection_subsetting</span><span class="p">,</span> 
                                        <span class="n">include_dataset_size</span><span class="o">=</span><span class="n">include_dataset_size</span><span class="p">,</span>
                                        <span class="n">table_format_return</span><span class="o">=</span><span class="n">table_format_return</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">error_analysis_df</span></div>

<div class="viewcode-block" id="subset_name_to_error_split"><a class="viewcode-back" href="../../../target_extraction.analysis.html#target_extraction.analysis.sentiment_error_analysis.subset_name_to_error_split">[docs]</a><span class="k">def</span> <span class="nf">subset_name_to_error_split</span><span class="p">(</span><span class="n">subset_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    This in affect inverts the `ERROR_SPLIT_SUBSET_NAMES` dictionary and </span>
<span class="sd">    returns the relevant error split name. It also initialises</span>
<span class="sd">    ERROR_SPLIT_SUBSET_NAMES.</span>

<span class="sd">    :param subset_name: Name of the subset you want to know which error split</span>
<span class="sd">                        it has come from.</span>
<span class="sd">    :returns: Associated error split name that the subset name has come from.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">SUBSET_NAMES_ERROR_SPLIT</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">error_split</span><span class="p">,</span> <span class="n">subset_names</span> <span class="ow">in</span> <span class="n">ERROR_SPLIT_SUBSET_NAMES</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">_subset_name</span> <span class="ow">in</span> <span class="n">subset_names</span><span class="p">:</span>
                <span class="n">SUBSET_NAMES_ERROR_SPLIT</span><span class="p">[</span><span class="n">_subset_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">error_split</span>
    <span class="k">return</span> <span class="n">SUBSET_NAMES_ERROR_SPLIT</span><span class="p">[</span><span class="n">subset_name</span><span class="p">]</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Andrew Moore

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>