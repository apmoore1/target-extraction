

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>target_extraction.data_types &mdash; Target Extraction 0.0.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> Target Extraction
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <!-- Local TOC -->
              <div class="local-toc"></div>
            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Target Extraction</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>target_extraction.data_types</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for target_extraction.data_types</h1><div class="highlight"><pre>
<span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Moudle that contains the two main data types </span>
<span class="sd">`target_extraction.data_types.TargetText` and </span>
<span class="sd">`target_extraction.data_types.TargetTextCollection` where the later is a</span>
<span class="sd">container for the former.</span>

<span class="sd">classes:</span>

<span class="sd">1. `target_extraction.data_types.TargetText`</span>
<span class="sd">2. `target_extraction.data_types.TargetTextCollection`</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">MutableMapping</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span><span class="p">,</span> <span class="n">Counter</span><span class="p">,</span> <span class="n">defaultdict</span><span class="p">,</span> <span class="n">deque</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">NamedTuple</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Callable</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Set</span>
<span class="kn">import</span> <span class="nn">traceback</span>
<span class="kn">import</span> <span class="nn">random</span>

<span class="kn">from</span> <span class="nn">target_extraction.tokenizers</span> <span class="kn">import</span> <span class="n">is_character_preserving</span><span class="p">,</span> <span class="n">token_index_alignment</span>
<span class="kn">from</span> <span class="nn">target_extraction.data_types_util</span> <span class="kn">import</span> <span class="p">(</span><span class="n">Span</span><span class="p">,</span> <span class="n">OverLappingTargetsError</span><span class="p">,</span>
                                               <span class="n">AnonymisedError</span><span class="p">,</span> <span class="n">OverwriteError</span><span class="p">)</span>

<div class="viewcode-block" id="check_anonymised"><a class="viewcode-back" href="../../target_extraction.html#target_extraction.data_types.check_anonymised">[docs]</a><span class="k">def</span> <span class="nf">check_anonymised</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Assumes the first argument in the given function is a TargetText object </span>
<span class="sd">    defined by self.</span>

<span class="sd">    :raises AnonymisedError: If the TargetText object given to `func` </span>
<span class="sd">                             `anonymised` attribute is True.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapper_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">target_text_object</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">target_text_object</span><span class="o">.</span><span class="n">anonymised</span><span class="p">:</span>
            <span class="n">anonymised_err</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Cannot perform this function as the Target &#39;</span>
                              <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">target_text_object</span><span class="si">}</span><span class="s1"> has been anonymised &#39;</span>
                              <span class="s1">&#39;and therefore has no `text`&#39;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">AnonymisedError</span><span class="p">(</span><span class="n">anonymised_err</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper_func</span></div>


<div class="viewcode-block" id="TargetText"><a class="viewcode-back" href="../../target_extraction.html#target_extraction.data_types.TargetText">[docs]</a><span class="k">class</span> <span class="nc">TargetText</span><span class="p">(</span><span class="n">MutableMapping</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    This is a data structure that inherits from MutableMapping which is </span>
<span class="sd">    essentially a python dictionary.</span>

<span class="sd">    The following are the default keys that are in all `TargetText` </span>
<span class="sd">    objects, additional items can be added through __setitem__</span>

<span class="sd">    1. text - The text associated to all of the other items</span>
<span class="sd">    2. text_id -- The unique ID associated to this object </span>
<span class="sd">    3. targets -- List of all target words that occur in the text. A special </span>
<span class="sd">                  placeholder of None (python None value) can exist where the </span>
<span class="sd">                  target does not exist but a related Category does this would </span>
<span class="sd">                  mean though that the related span is Span(0, 0), this type of </span>
<span class="sd">                  special placeholder is in place for the SemEval 2016 Restaurant </span>
<span class="sd">                  dataset where they link the categories to the targets but </span>
<span class="sd">                  not all categories have related targets thus None.</span>
<span class="sd">    4. spans -- List of Span NamedTuples where each one specifies the start and </span>
<span class="sd">       end of the respective targets within the text.</span>
<span class="sd">    5. target_sentiments -- List sepcifying the sentiment of the respective </span>
<span class="sd">       targets within the text.</span>
<span class="sd">    6. categories -- List of categories that exist in the data which may or </span>
<span class="sd">       may not link to the targets (this is dataset speicific). NOTE: </span>
<span class="sd">       depending on the dataset and how it is parsed the category can exist </span>
<span class="sd">       but the target does not as the category is a latent variable, in </span>
<span class="sd">       these cases the category and category sentiments will be the same size </span>
<span class="sd">       which would be a different size to the target and target sentiments </span>
<span class="sd">       size. E.g. can happen where the dataset has targets and categories </span>
<span class="sd">       but they do not map to each other in a one to one manner e.g </span>
<span class="sd">       SemEval 2014 restuarant dataset, there are some samples that contain </span>
<span class="sd">       categories but no targets. Another word for category can be aspect.</span>
<span class="sd">    7. category_sentiments -- List of the sentiments associated to the </span>
<span class="sd">       categories. If the categories and targets map to each other then </span>
<span class="sd">       this will be empty and you will only use the target_sentiments.</span>

<span class="sd">    Attributes:</span>

<span class="sd">    1. anonymised -- If True then the data within the TargetText object has </span>
<span class="sd">       no text but the rest of the metadata should exist.</span>

<span class="sd">    Methods:</span>

<span class="sd">    1. to_json -- Returns the object as a dictionary and then encoded using </span>
<span class="sd">       json.dumps</span>
<span class="sd">    2. to_conll -- Returns a CONLL formatted string where the formatt will be the </span>
<span class="sd">       following: `TOKEN#GOLD LABEL#PREDICTION 1# PREDICTION 2`. Where each </span>
<span class="sd">       token and relevant labels are on separate new lines. The first line will </span>
<span class="sd">       always contain the following: `# {text_id: `value`}` where the `text_id` </span>
<span class="sd">       represents the `text_id` of this TargetText, this will allow the CONLL</span>
<span class="sd">        string to be uniquely identified back this TargetText object.</span>
<span class="sd">    3. from_conll -- Adds the gold labels and/or predicted sequence labels from </span>
<span class="sd">       the CONLL formatted string.</span>
<span class="sd">    4. tokenize -- This will add a new key `tokenized_text` to this TargetText </span>
<span class="sd">       instance that will store the tokens of the text that is associated to </span>
<span class="sd">       this TargetText instance.</span>
<span class="sd">    5. pos_text -- This will add a new key `pos_tags` to this TargetText </span>
<span class="sd">       instance. This key will store the pos tags of the text that is </span>
<span class="sd">       associated to this Target Text instance.</span>
<span class="sd">    6. force_targets -- Does not return anything but modifies the `spans` and </span>
<span class="sd">       `text` values as whitespace is prefixed and suffixed the target unless </span>
<span class="sd">       the prefix or suffix is whitespace. NOTE that this is the only method </span>
<span class="sd">       that currently can change the `spans` and `text` key values after they </span>
<span class="sd">       have been set.</span>
<span class="sd">    7. sequence_labels -- Adds the `sequence_labels` key to this TargetText </span>
<span class="sd">       instance which can be used to train a machine learning algorthim to </span>
<span class="sd">       detect targets.</span>
<span class="sd">    8. get_sequence_indexs -- The indexs related to the tokens, pos tags etc </span>
<span class="sd">       for each labelled sequence span.</span>
<span class="sd">    9. get_sequence_spans -- The span indexs from the sequence labels given </span>
<span class="sd">       assuming that the sequence labels are in BIO format.</span>
<span class="sd">    10. get_targets_from_sequence_labels -- Retrives the target words given the </span>
<span class="sd">        sequence labels.</span>
<span class="sd">    11. one_sample_per_span -- This returns a similar TargetText instance </span>
<span class="sd">        where the new instance will only contain one target per span.</span>
<span class="sd">    12. left_right_target_contexts -- This will return the sentence that is </span>
<span class="sd">        left and right of the target as well as the words in the target for </span>
<span class="sd">        each target in the sentence.</span>
<span class="sd">    13. replace_target -- Given an index and a new target word it will replace </span>
<span class="sd">        the target at the index with the new target word and return a new </span>
<span class="sd">        TargetText object with everything the same apart from this new target.</span>
<span class="sd">    14. de_anonymise -- This will set the `anonymised` attribute to False </span>
<span class="sd">        from True and set the `text` key value to the value in the `text` </span>
<span class="sd">        key within the `text_dict` argument. </span>
<span class="sd">    15. in_order -- True if all the `targets` within this TargetText </span>
<span class="sd">        are in sequential left to right order within the text.</span>
<span class="sd">    16. re_order -- Re-Orders the TargetText object targets so that they are in </span>
<span class="sd">        a left to right order within the text, this will then re-order all </span>
<span class="sd">        values within this object that are in a list format into this order. </span>
<span class="sd">        Once the TargetText has been re-ordered it will return True when </span>
<span class="sd">        :py:meth`target_extraction.data_types.TargetText.in_order` is called.</span>
<span class="sd">    17. add_unique_key -- Given a key e.g. `targets` it will create a new value </span>
<span class="sd">        in the TargetText object that is a list of strings which are unique IDs</span>
<span class="sd">        based on the `text_id` and the index the `targets` occur in e.g. </span>
<span class="sd">        if the `targets` contain [`food`, `service`] and the `text_id` is </span>
<span class="sd">        `12a5` then the `target_id` created will contain `[`12a5$$0`,`12a5$$1`]`  </span>
<span class="sd">    </span>
<span class="sd">    Static Functions:</span>

<span class="sd">    1. from_json -- Returns a TargetText object given a json string. For </span>
<span class="sd">       example the json string can be the return of TargetText.to_json.</span>
<span class="sd">    2. targets_from_spans -- Given a sequence of spans and the associated text </span>
<span class="sd">       it will return the targets that are within the text based on the spans</span>
<span class="sd">    3. target_text_from_prediction -- Creates a TargetText object from data </span>
<span class="sd">       that has come from predictions of a Target Extract tagger</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span> <span class="nf">_check_is_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="n">item_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        This will check that the argument given is a List and if not will raise </span>
<span class="sd">        a TypeError.</span>

<span class="sd">        :param item: The argument that is going to be checked to ensure it is a</span>
<span class="sd">                     list.</span>
<span class="sd">        :param item_name: Name of the item. This is used within the raised </span>
<span class="sd">                          error message, if an error is raised.</span>
<span class="sd">        :raises TypeError: If any of the items are not of type List.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">type_err</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">item_name</span><span class="si">}</span><span class="s1"> should be a list not </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">item</span><span class="p">)</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">item</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">type_err</span><span class="p">)</span>

<div class="viewcode-block" id="TargetText.sanitize"><a class="viewcode-back" href="../../target_extraction.html#target_extraction.data_types.TargetText.sanitize">[docs]</a>    <span class="k">def</span> <span class="nf">sanitize</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        This performs a check on all of the lists that can be given at </span>
<span class="sd">        object construction time to ensure that the following conditions are </span>
<span class="sd">        met:</span>
<span class="sd">        </span>
<span class="sd">        1. The target, spans and target_sentiments lists are all of the same </span>
<span class="sd">           size if set.</span>
<span class="sd">        2. The categories and the category_sentiments lists are all of the </span>
<span class="sd">           same size if set. </span>

<span class="sd">        Further more it checks the following:</span>

<span class="sd">        1. If targets or spans are set then both have to exist.</span>
<span class="sd">        2. If targets and spans are set that the spans text match the </span>
<span class="sd">           associated target words e.g. if the target is `barry davies` in </span>
<span class="sd">           `today barry davies went` then the spans should be [[6,18]]</span>
<span class="sd">        3. If anonymised esures that the `text` key does not exist.</span>

<span class="sd">        The 2nd check is not performed if `self.anonymised` is False.</span>
<span class="sd">    </span>
<span class="sd">        :raises ValueError: If any of the above conditions are not True.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">def</span> <span class="nf">length_mis_match</span><span class="p">(</span><span class="n">lists_to_check</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> 
                             <span class="n">text_id_msg</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">length_mismatch_msg</span> <span class="o">=</span> <span class="s1">&#39;The following lists do not match &#39;</span>\
                                  <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">lists_to_check</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="n">list_lengths</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">_list</span><span class="p">)</span> <span class="k">for</span> <span class="n">_list</span> <span class="ow">in</span> <span class="n">lists_to_check</span> 
                            <span class="k">if</span> <span class="n">_list</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
            <span class="n">current_list_size</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">for</span> <span class="n">list_length</span> <span class="ow">in</span> <span class="n">list_lengths</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">current_list_size</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">current_list_size</span> <span class="o">=</span> <span class="n">list_length</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">current_list_size</span> <span class="o">!=</span> <span class="n">list_length</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">text_id_msg</span> <span class="o">+</span> <span class="n">length_mismatch_msg</span><span class="p">)</span>

        <span class="n">targets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="p">[</span><span class="s1">&#39;targets&#39;</span><span class="p">]</span>
        <span class="n">target_sentiments</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="p">[</span><span class="s1">&#39;target_sentiments&#39;</span><span class="p">]</span>
        <span class="n">spans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="p">[</span><span class="s1">&#39;spans&#39;</span><span class="p">]</span>
        <span class="n">categories</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="p">[</span><span class="s1">&#39;categories&#39;</span><span class="p">]</span>
        <span class="n">category_sentiments</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="p">[</span><span class="s1">&#39;category_sentiments&#39;</span><span class="p">]</span>

        <span class="n">text_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="p">[</span><span class="s1">&#39;text_id&#39;</span><span class="p">]</span>
        <span class="n">text_id_msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Text id that this error refers to </span><span class="si">{</span><span class="n">text_id</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>

        <span class="c1"># Checking the length mismatches for the two different lists</span>
        <span class="n">length_mis_match</span><span class="p">([</span><span class="n">targets</span><span class="p">,</span> <span class="n">target_sentiments</span><span class="p">,</span> <span class="n">spans</span><span class="p">],</span> <span class="n">text_id_msg</span><span class="p">)</span>
        <span class="n">length_mis_match</span><span class="p">([</span><span class="n">categories</span><span class="p">,</span> <span class="n">category_sentiments</span><span class="p">],</span> <span class="n">text_id_msg</span><span class="p">)</span>
        

        <span class="c1"># Checking that if targets are set than so are spans</span>
        <span class="k">if</span> <span class="n">targets</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">spans</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">spans_none_msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;If the targets are a list: </span><span class="si">{</span><span class="n">targets</span><span class="si">}</span><span class="s1"> then spans&#39;</span>\
                             <span class="sa">f</span><span class="s1">&#39; should also be a list and not None: </span><span class="si">{</span><span class="n">spans</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">text_id_msg</span> <span class="o">+</span> <span class="n">spans_none_msg</span><span class="p">)</span>
        <span class="c1"># Checking that the words Spans reference in the text match the </span>
        <span class="c1"># respective target words. Edge case is the case of None targets which </span>
        <span class="c1"># should have a Span value of (0, 0)</span>
        <span class="k">if</span> <span class="n">targets</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">target</span><span class="p">,</span> <span class="n">span</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">targets</span><span class="p">,</span> <span class="n">spans</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">target</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">target_span_msg</span> <span class="o">=</span> <span class="s1">&#39;As the target value is None the span &#39;</span>\
                                      <span class="s1">&#39;it refers to should be of value &#39;</span>\
                                      <span class="sa">f</span><span class="s1">&#39;Span(0, 0) and not </span><span class="si">{</span><span class="n">span</span><span class="si">}</span><span class="s1">&#39;</span>
                    <span class="k">if</span> <span class="n">span</span> <span class="o">!=</span> <span class="n">Span</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">text_id_msg</span> <span class="o">+</span> <span class="n">target_span_msg</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">span</span> <span class="o">==</span> <span class="n">Span</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="n">target</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
                        <span class="n">target_span_msg</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s1">&#39;The Span is </span><span class="si">{</span><span class="n">Span</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="si">}</span><span class="s1"> and the &#39;</span>
                                           <span class="sa">f</span><span class="s1">&#39;target is </span><span class="si">{</span><span class="n">target</span><span class="si">}</span><span class="s1"> therefore the &#39;</span>
                                           <span class="s1">&#39;span must be in-correct for this&#39;</span>
                                           <span class="sa">f</span><span class="s1">&#39; target </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">target_span_msg</span><span class="p">)</span>
                    <span class="c1"># Cannot check the text value when the data has been anonymised</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">anonymised</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">text</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="p">[</span><span class="s1">&#39;text&#39;</span><span class="p">]</span> 
                    <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">span</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">span</span><span class="o">.</span><span class="n">end</span>
                    <span class="n">text_target</span> <span class="o">=</span> <span class="n">text</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>
                    <span class="n">target_span_msg</span> <span class="o">=</span> <span class="s1">&#39;The target the spans reference in the &#39;</span>\
                                      <span class="sa">f</span><span class="s1">&#39;text: </span><span class="si">{</span><span class="n">text_target</span><span class="si">}</span><span class="s1"> does not match &#39;</span>\
                                      <span class="sa">f</span><span class="s1">&#39;the target in the targets list: </span><span class="si">{</span><span class="n">target</span><span class="si">}</span><span class="s1">&#39;</span>
                    <span class="k">if</span> <span class="n">text_target</span> <span class="o">!=</span> <span class="n">target</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">text_id_msg</span> <span class="o">+</span> <span class="n">target_span_msg</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">anonymised</span> <span class="ow">and</span> <span class="s1">&#39;text&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The TargetText object is anonymised and therefore&#39;</span>
                             <span class="sa">f</span><span class="s1">&#39; should not contain a `text` key. </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">text_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                 <span class="n">targets</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                 <span class="n">spans</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Span</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                 <span class="n">target_sentiments</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                 <span class="n">categories</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">category_sentiments</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">anonymised</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">additional_data</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        :param additional_data: Any other data that is to be added to the </span>
<span class="sd">                                object at construction.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># Ensure that the arguments that should be lists are lists.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_list_argument_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;targets&#39;</span><span class="p">,</span> <span class="s1">&#39;spans&#39;</span><span class="p">,</span> <span class="s1">&#39;target_sentiments&#39;</span><span class="p">,</span> 
                                     <span class="s1">&#39;categories&#39;</span><span class="p">,</span> <span class="s1">&#39;category_sentiments&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_list_arguments</span> <span class="o">=</span> <span class="p">[</span><span class="n">targets</span><span class="p">,</span> <span class="n">spans</span><span class="p">,</span> <span class="n">target_sentiments</span><span class="p">,</span> <span class="n">categories</span><span class="p">,</span>
                                <span class="n">category_sentiments</span><span class="p">]</span>
        <span class="n">names_arguments</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_list_argument_names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_list_arguments</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">argument_name</span><span class="p">,</span> <span class="n">list_argument</span> <span class="ow">in</span> <span class="n">names_arguments</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">list_argument</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_is_list</span><span class="p">(</span><span class="n">list_argument</span><span class="p">,</span> <span class="n">argument_name</span><span class="p">)</span>
        <span class="c1"># anonymised data will have no text</span>
        <span class="n">temp_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="n">text</span><span class="p">,</span> <span class="n">text_id</span><span class="o">=</span><span class="n">text_id</span><span class="p">,</span> <span class="n">targets</span><span class="o">=</span><span class="n">targets</span><span class="p">,</span>
                         <span class="n">spans</span><span class="o">=</span><span class="n">spans</span><span class="p">,</span> <span class="n">target_sentiments</span><span class="o">=</span><span class="n">target_sentiments</span><span class="p">,</span> 
                         <span class="n">categories</span><span class="o">=</span><span class="n">categories</span><span class="p">,</span> 
                         <span class="n">category_sentiments</span><span class="o">=</span><span class="n">category_sentiments</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">anonymised</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">temp_dict</span><span class="p">[</span><span class="s1">&#39;text&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_protected_keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="s1">&#39;text_id&#39;</span><span class="p">,</span> <span class="s1">&#39;targets&#39;</span><span class="p">,</span> <span class="s1">&#39;spans&#39;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_protected_keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="s1">&#39;text&#39;</span><span class="p">,</span> <span class="s1">&#39;text_id&#39;</span><span class="p">,</span> <span class="s1">&#39;targets&#39;</span><span class="p">,</span> <span class="s1">&#39;spans&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_storage</span> <span class="o">=</span> <span class="n">temp_dict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_storage</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="p">,</span> <span class="o">**</span><span class="n">additional_data</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_anonymised</span> <span class="o">=</span> <span class="n">anonymised</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sanitize</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">anonymised</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        :returns: True if the data within the TargetText has been anonymised.</span>
<span class="sd">                  Anonymised data means that there is no text associated with</span>
<span class="sd">                  the TargetText object but all of the metadata is there.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_anonymised</span>

    <span class="nd">@anonymised</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">anonymised</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Sets whether or not `anonymised` attribute is True or False. Either </span>
<span class="sd">        which way when set it performs the `sanitize` check to ensure that </span>
<span class="sd">        the attribute can be set to this value else it is reverted.</span>

<span class="sd">        :param value: If True then the `text` key will be deleted. In all </span>
<span class="sd">                      cases the TargetText object is subjected to the </span>
<span class="sd">                      :py:meth:`sanitize` to ensure that the anonymised </span>
<span class="sd">                      process is correct.</span>
<span class="sd">        :raises AnonymisedError: If the TargetText object cannot be set to the </span>
<span class="sd">                                 `anonymised` value given. If this Error occurs </span>
<span class="sd">                                 then the object will have kept the original </span>
<span class="sd">                                 `anonymised` value.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># If want to anonymise all the </span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">anonymised</span> <span class="ow">and</span> <span class="n">value</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="p">[</span><span class="s1">&#39;text&#39;</span><span class="p">]</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_anonymised</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sanitize</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_anonymised</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">value</span>
            <span class="n">sanitize_err</span> <span class="o">=</span> <span class="n">traceback</span><span class="o">.</span><span class="n">format_exc</span><span class="p">()</span>
            <span class="k">raise</span> <span class="n">AnonymisedError</span><span class="p">(</span><span class="s1">&#39;Cannot de-anonymise this TargetText &#39;</span>
                                    <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s1"> as it cannot pass the `sanitize`&#39;</span>
                                    <span class="s1">&#39; check of which the following is the &#39;</span>
                                    <span class="sa">f</span><span class="s1">&#39;error from said check </span><span class="si">{</span><span class="n">sanitize_err</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        :returns: One of the values from the self._storage dictionary. e.g. </span>
<span class="sd">                  if the key is `text` it will return the string representing </span>
<span class="sd">                  the text associated to this object.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns an interator over the keys in self._storage which are the </span>
<span class="sd">        following Strings by default additional keys can be added:</span>

<span class="sd">        1. text</span>
<span class="sd">        2. text_id</span>
<span class="sd">        3. targets</span>
<span class="sd">        4. spans</span>
<span class="sd">        5. target_sentiments</span>
<span class="sd">        6. categories</span>
<span class="sd">        7. category_sentiments</span>

<span class="sd">        :returns: The keys in self._storage</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        :returns: The number of items in self._storage.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        :returns: String returned is what user see when the instance is </span>
<span class="sd">                  printed or printed within a interpreter.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;TargetText(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="si">}</span><span class="s1">)&#39;</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s1">&#39;TargetText&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Two TargetText instances are equal if they both have the same `text_id`</span>
<span class="sd">        value.</span>

<span class="sd">        :param other: Another TargetText object that is being compared to this </span>
<span class="sd">                      TargetText object.</span>
<span class="sd">        :returns: True if they have the same `text_id` value else False.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">TargetText</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;text_id&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">other</span><span class="p">[</span><span class="s1">&#39;text_id&#39;</span><span class="p">]:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Given a key that matches a key within self._storage or self.keys() </span>
<span class="sd">        it will delete that key and value from this object.</span>

<span class="sd">        NOTE: Currently  &#39;text&#39;, &#39;text_id&#39;, &#39;spans&#39;, and &#39;targets&#39; are keys </span>
<span class="sd">        that cannot be deleted.</span>

<span class="sd">        :param key: Key and its respective value to delete from this object.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_protected_keys</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;Cannot delete a key that is protected, list of &#39;</span>
                           <span class="sa">f</span><span class="s1">&#39; protected keys: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_protected_keys</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Given a key and a respected value it will either change that current </span>
<span class="sd">        keys value to the one gien here or create a new key with that value.</span>

<span class="sd">        NOTE: Currently  &#39;text&#39;, &#39;text_id&#39;, &#39;spans&#39;, and &#39;targets&#39; are keys </span>
<span class="sd">        that cannot be changed.</span>

<span class="sd">        :param key: Key to be added or changed</span>
<span class="sd">        :param value: Value associated to the given key.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_protected_keys</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;Cannot change a key that is protected, list of &#39;</span>
                           <span class="sa">f</span><span class="s1">&#39; protected keys: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_protected_keys</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="c1"># If the key value should be a list ensure that the new value is a </span>
        <span class="c1"># list as well.</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_list_argument_names</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_is_list</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sanitize</span><span class="p">()</span>

<div class="viewcode-block" id="TargetText.to_json"><a class="viewcode-back" href="../../target_extraction.html#target_extraction.data_types.TargetText.to_json">[docs]</a>    <span class="k">def</span> <span class="nf">to_json</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Required as TargetText is not json serlizable due to the &#39;spans&#39;.</span>

<span class="sd">        :returns: The object as a dictionary and then encoded using json.dumps</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="p">)</span></div>

<div class="viewcode-block" id="TargetText.to_conll"><a class="viewcode-back" href="../../target_extraction.html#target_extraction.data_types.TargetText.to_conll">[docs]</a>    <span class="nd">@check_anonymised</span>
    <span class="k">def</span> <span class="nf">to_conll</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gold_label_key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> 
                 <span class="n">prediction_key</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        :param gold_label: A key that contains a sequence of labels e.g. </span>
<span class="sd">                           [`B`, `I`, `O`]. This can come from the return </span>
<span class="sd">                           of the :py:meth:`sequence_labels`</span>
<span class="sd">        :param prediction_key: Key to the predicted labels of the `gold_label`. </span>
<span class="sd">                               Where the prediction key values is a list of a </span>
<span class="sd">                               list of predicted labels. Each list is therefore </span>
<span class="sd">                               a different model run hence creating the </span>
<span class="sd">                               `PREDICTION 1`, &#39;PREDICTION 2&#39; etc. Thus the </span>
<span class="sd">                               values of `prediction_key` must be of shape </span>
<span class="sd">                               (number runs, number tokens)</span>
<span class="sd">        :returns: A CONLL formatted string where the format will be the </span>
<span class="sd">                  following: `TOKEN#GOLD LABEL#PREDICTION 1# PREDICTION 2`</span>
<span class="sd">                  Where each token and relevant labels are on separate new </span>
<span class="sd">                  lines. The first line will always contain the following:</span>
<span class="sd">                  `# {text_id: `value`}` where the text_id represents the </span>
<span class="sd">                  `text_id` of this TargetText, this will allow the CONLL</span>
<span class="sd">                  string to be uniquely identified back this TargetText </span>
<span class="sd">                  object.</span>
<span class="sd">        :raises AnonymisedError: If the object has been anonymised then this </span>
<span class="sd">                                 method cannot be used.</span>
<span class="sd">        :raises KeyError: If the the object has not be tokenized using </span>
<span class="sd">                          :py:meth:`tokenize`</span>
<span class="sd">        :raises KeyError: If the `prediction_key` or `gold_label_key` do not </span>
<span class="sd">                          exist.</span>
<span class="sd">        :raises ValueError: If the `gold_label_key` or `prediction_key` values </span>
<span class="sd">                            are not of the same length as the tokens, as the </span>
<span class="sd">                            labels will not be able to match tokens etc.</span>
<span class="sd">        :raises ValueError: If the values in `prediction_key` are not of shape </span>
<span class="sd">                            (number runs, number tokens)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">keys_to_check</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;tokenized_text&#39;</span><span class="p">,</span> <span class="n">gold_label_key</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">prediction_key</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">keys_to_check</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prediction_key</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys_to_check</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_key_error</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">number_tokens</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;tokenized_text&#39;</span><span class="p">])</span>
        <span class="c1"># ensure number of labels same as number of tokens</span>
        <span class="n">value_err</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Number of tokens </span><span class="si">{</span><span class="n">number_tokens</span><span class="si">}</span><span class="s1"> does not match the &#39;</span>
                     <span class="sa">f</span><span class="s1">&#39;number of labels &#39;</span><span class="p">)</span>
        <span class="n">number_gold_labels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">gold_label_key</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">number_tokens</span> <span class="o">!=</span> <span class="n">number_gold_labels</span><span class="p">:</span>
            <span class="n">gold_err</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">number_gold_labels</span><span class="si">}</span><span class="s1"> for gold label &#39;</span>
                        <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">gold_label_key</span><span class="si">}</span><span class="s1"> in </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">gold_err</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">value_err</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">gold_err</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">gold_err</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">prediction_key</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">prediction_labels</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[</span><span class="n">prediction_key</span><span class="p">]:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">prediction_labels</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="n">pred_list_shape_error</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;The predictions should be a list &#39;</span>
                                             <span class="s1">&#39;of a list of labels of shape &#39;</span>
                                             <span class="s1">&#39;(number runs, number tokens) not &#39;</span>
                                             <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="p">[</span><span class="n">prediction_key</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">pred_list_shape_error</span><span class="p">)</span>
                <span class="n">number_labels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">prediction_labels</span><span class="p">)</span>
                <span class="n">pred_err</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">number_labels</span><span class="si">}</span><span class="s1"> for prediction &#39;</span>
                            <span class="sa">f</span><span class="s1">&#39;label </span><span class="si">{</span><span class="n">prediction_key</span><span class="si">}</span><span class="s1"> in </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">pred_err</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">value_err</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">pred_err</span><span class="si">}</span><span class="s1">&#39;</span>
                <span class="k">if</span> <span class="n">number_tokens</span> <span class="o">!=</span> <span class="n">number_labels</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">pred_err</span><span class="p">)</span>
        <span class="c1"># End of checks now creating the CONLL string</span>
        <span class="n">text_id_str</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">({</span><span class="s1">&#39;text_id&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;text_id&#39;</span><span class="p">]})</span>
        <span class="n">gold_labels</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">gold_label_key</span><span class="p">]</span>
        <span class="n">conll_string</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;# </span><span class="si">{</span><span class="n">text_id_str</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="k">for</span> <span class="n">token_index</span><span class="p">,</span> <span class="n">token</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;tokenized_text&#39;</span><span class="p">]):</span>
            <span class="n">gold_label</span> <span class="o">=</span> <span class="n">gold_labels</span><span class="p">[</span><span class="n">token_index</span><span class="p">]</span>
            <span class="n">token_string</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">token</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">gold_label</span><span class="si">}</span><span class="s1"> &#39;</span>
            <span class="k">if</span> <span class="n">prediction_key</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">prediction_labels</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[</span><span class="n">prediction_key</span><span class="p">]:</span>
                    <span class="n">prediction_label</span> <span class="o">=</span> <span class="n">prediction_labels</span><span class="p">[</span><span class="n">token_index</span><span class="p">]</span>
                    <span class="n">token_string</span> <span class="o">+=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">prediction_label</span><span class="si">}</span><span class="s1"> &#39;</span>                    
            <span class="n">token_string</span> <span class="o">=</span> <span class="n">token_string</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
            <span class="n">token_string</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\n</span><span class="si">{</span><span class="n">token_string</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="n">conll_string</span> <span class="o">+=</span> <span class="n">token_string</span>
        <span class="k">return</span> <span class="n">conll_string</span></div>

<div class="viewcode-block" id="TargetText.from_conll"><a class="viewcode-back" href="../../target_extraction.html#target_extraction.data_types.TargetText.from_conll">[docs]</a>    <span class="nd">@check_anonymised</span>
    <span class="k">def</span> <span class="nf">from_conll</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conll_str</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">tokens_key</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;tokenized_text&#39;</span><span class="p">,</span> 
                   <span class="n">gold_label_key</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                   <span class="n">prediction_key</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        :param conll_str: CONLL formatted string formatted like so: </span>
<span class="sd">                          `TOKEN#GOLD LABEL#PREDICTION 1# PREDICTION 2`</span>
<span class="sd">        :param tokens_key: Key to save the CONLL tokens too.</span>
<span class="sd">        :param gold_label_key: Key to save the gold labels too. Either </span>
<span class="sd">                               `gold_label_key` or `prediction_key` must not be </span>
<span class="sd">                               `None` or both not `None`</span>
<span class="sd">        :param prediction_key: Key to save the prediction labels too. The value </span>
<span class="sd">                               will be of shape (number runs, number tokens)</span>
<span class="sd">        :raises AnonymisedError: If the object has been anonymised then this </span>
<span class="sd">                                 method cannot be used.</span>
<span class="sd">        :raises ValueError: If both `gold_label_key` and `prediction_key` are </span>
<span class="sd">                            `None`.</span>
<span class="sd">        :raises ValueError: If the number of labels are not consistent in the </span>
<span class="sd">                            CONLL string e.g. the first token has 3 predicted </span>
<span class="sd">                            labels and the second token has 2 predicted labels.</span>
<span class="sd">        :raises ValueError: If the text within this TargetText does not match </span>
<span class="sd">                            the tokens in the CONLL string. (CASE SENSITIVE)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">prediction_key</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">gold_label_key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Either `prediction_key` or `gold_label_key` or &#39;</span>
                             <span class="s1">&#39;both need to be a String not None&#39;</span><span class="p">)</span>
        <span class="c1"># Predicted labels is of shape (number runs, number tokens)</span>
        <span class="n">predicted_labels</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">gold_labels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">conll_token_labels</span> <span class="o">=</span> <span class="n">conll_str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        
        <span class="n">conll_string_length</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">conll_token_label</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">conll_token_labels</span><span class="p">):</span>
            <span class="n">token_labels</span> <span class="o">=</span> <span class="n">conll_token_label</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
            <span class="n">number_token_labels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">token_labels</span><span class="p">)</span>
            <span class="c1"># Ensure legnth of CONLL same each time</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">conll_string_length</span> <span class="o">=</span> <span class="n">number_token_labels</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">conll_string_length</span> <span class="o">!=</span> <span class="n">number_token_labels</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Number of labels are not consistent. &#39;</span>
                                     <span class="sa">f</span><span class="s1">&#39;Index </span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s1">. CONLL String: &#39;</span>
                                     <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">conll_token_labels</span><span class="si">}</span><span class="se">\n</span><span class="s1"> Self </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">number_token_labels</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;CONLL String does not contain any labels &#39;</span>
                                 <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">conll_token_labels</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            
            <span class="n">tokens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">token_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">gold_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">token_labels</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">number_token_labels</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">predicted_values</span> <span class="o">=</span> <span class="n">token_labels</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
            <span class="k">for</span> <span class="n">pred_index</span><span class="p">,</span> <span class="n">predicted_tokens</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">predicted_values</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">predicted_labels</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                <span class="n">predicted_labels</span><span class="p">[</span><span class="n">pred_index</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">predicted_tokens</span><span class="p">)</span>
        <span class="c1"># Ensure that the tokens match the text</span>
        <span class="n">text</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;text&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_character_preserving</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">tokens</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;The tokens </span><span class="si">{</span><span class="n">tokens</span><span class="si">}</span><span class="s1"> do not match the text </span><span class="si">{</span><span class="n">text</span><span class="si">}</span><span class="s1">&#39;</span>
                             <span class="sa">f</span><span class="s1">&#39; for </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">tokens_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">tokens</span>
        <span class="k">if</span> <span class="n">gold_label_key</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">gold_label_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">gold_labels</span>
        <span class="k">if</span> <span class="n">prediction_key</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">prediction_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">predicted_labels</span></div>
        
    <span class="k">def</span> <span class="nf">_shift_spans</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_span</span><span class="p">:</span> <span class="n">Span</span><span class="p">,</span> <span class="n">prefix</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> 
                     <span class="n">suffix</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        This only affects the current state of the TargetText attributes. </span>
<span class="sd">        The attributes this affects is the `spans` attribute.</span>

<span class="sd">        NOTE: This is only used within self.force_targets method.</span>

<span class="sd">        :param prefix: Whether it affects the prefix of the target_span</span>
<span class="sd">        :param suffix: Whether it affects the suffix of the target_span</span>
<span class="sd">        :param spans: The current target span indexs that are having extra </span>
<span class="sd">                        whitespace added either prefix or suffix.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">target_span_start</span> <span class="o">=</span> <span class="n">target_span</span><span class="o">.</span><span class="n">start</span>
        <span class="n">target_span_end</span> <span class="o">=</span> <span class="n">target_span</span><span class="o">.</span><span class="n">end</span>
        <span class="k">for</span> <span class="n">span_index</span><span class="p">,</span> <span class="n">other_target_span</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;spans&#39;</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">other_target_span</span> <span class="o">==</span> <span class="n">target_span</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;spans&#39;</span><span class="p">][</span><span class="n">span_index</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">prefix</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">other_target_span</span><span class="o">.</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="n">target_span_start</span><span class="p">:</span>
                    <span class="n">start</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">other_target_span</span><span class="o">.</span><span class="n">end</span> <span class="o">&gt;=</span> <span class="n">target_span_start</span><span class="p">:</span>
                    <span class="n">end</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">suffix</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">other_target_span</span><span class="o">.</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="n">target_span_end</span><span class="p">:</span>
                    <span class="n">start</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">other_target_span</span><span class="o">.</span><span class="n">end</span> <span class="o">&gt;=</span> <span class="n">target_span_end</span><span class="p">:</span>
                    <span class="n">end</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="p">[</span><span class="s1">&#39;spans&#39;</span><span class="p">][</span><span class="n">span_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">Span</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>

<div class="viewcode-block" id="TargetText.force_targets"><a class="viewcode-back" href="../../target_extraction.html#target_extraction.data_types.TargetText.force_targets">[docs]</a>    <span class="nd">@check_anonymised</span>
    <span class="k">def</span> <span class="nf">force_targets</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        :NOTE: As this affects the following attributes `spans`, `text`, and `targets` </span>
<span class="sd">               it therefore has to modify these through self._storage as both of  </span>
<span class="sd">               these attributes are within self._protected_keys.</span>

<span class="sd">        Does not return anything but modifies the `spans` and `text` values </span>
<span class="sd">        as whitespace is prefixed and suffixed the target unless the prefix </span>
<span class="sd">        or suffix is whitespace.</span>

<span class="sd">        Motivation:</span>
<span class="sd">        Ensure that the target tokens are not within another separate String </span>
<span class="sd">        e.g. target = `priced` but the sentence is `the laptop;priced is high` </span>
<span class="sd">        and the tokenizer is on whitespace it will not have `priced` seperated </span>
<span class="sd">        therefore the BIO tagging is not deterministic thus force will add </span>
<span class="sd">        whitespace around the target word e.g. `the laptop; priced`. This was </span>
<span class="sd">        mainly added for the TargetText.sequence_tags method.</span>

<span class="sd">        :raises AnonymisedError: If the object has been anonymised then this </span>
<span class="sd">                                 method cannot be used.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">span_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;spans&#39;</span><span class="p">])):</span>
            <span class="n">text</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="p">[</span><span class="s1">&#39;text&#39;</span><span class="p">]</span>
            <span class="n">last_token_index</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>

            <span class="n">span</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="p">[</span><span class="s1">&#39;spans&#39;</span><span class="p">][</span><span class="n">span_index</span><span class="p">]</span>
            <span class="n">prefix</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">suffix</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">span</span>
            <span class="k">if</span> <span class="n">start</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">text</span><span class="p">[</span><span class="n">start</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39; &#39;</span><span class="p">:</span>
                    <span class="n">prefix</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="n">end</span> <span class="o">&lt;</span> <span class="n">last_token_index</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">text</span><span class="p">[</span><span class="n">end</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39; &#39;</span><span class="p">:</span>
                    <span class="n">suffix</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="n">text_before</span> <span class="o">=</span> <span class="n">text</span><span class="p">[:</span><span class="n">start</span><span class="p">]</span>
            <span class="n">text_after</span> <span class="o">=</span> <span class="n">text</span><span class="p">[</span><span class="n">end</span><span class="p">:]</span>
            <span class="n">target</span> <span class="o">=</span> <span class="n">text</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">prefix</span> <span class="ow">and</span> <span class="n">suffix</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="p">[</span><span class="s1">&#39;text&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">text_before</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">target</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">text_after</span><span class="si">}</span><span class="s1">&#39;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_shift_spans</span><span class="p">(</span><span class="n">span</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="p">[</span><span class="s1">&#39;spans&#39;</span><span class="p">][</span><span class="n">span_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">Span</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">prefix</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="p">[</span><span class="s1">&#39;text&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">text_before</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">target</span><span class="si">}{</span><span class="n">text_after</span><span class="si">}</span><span class="s1">&#39;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_shift_spans</span><span class="p">(</span><span class="n">span</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="p">[</span><span class="s1">&#39;spans&#39;</span><span class="p">][</span><span class="n">span_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">Span</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">suffix</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="p">[</span><span class="s1">&#39;text&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">text_before</span><span class="si">}{</span><span class="n">target</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">text_after</span><span class="si">}</span><span class="s1">&#39;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_shift_spans</span><span class="p">(</span><span class="n">span</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># Get the targets from the re-aligned spans</span>
        <span class="n">updated_targets</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">text</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="p">[</span><span class="s1">&#39;text&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">span</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="p">[</span><span class="s1">&#39;spans&#39;</span><span class="p">]:</span>
            <span class="n">target</span> <span class="o">=</span> <span class="n">text</span><span class="p">[</span><span class="n">span</span><span class="o">.</span><span class="n">start</span><span class="p">:</span> <span class="n">span</span><span class="o">.</span><span class="n">end</span><span class="p">]</span>
            <span class="n">updated_targets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="p">[</span><span class="s1">&#39;targets&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">updated_targets</span></div>

<div class="viewcode-block" id="TargetText.tokenize"><a class="viewcode-back" href="../../target_extraction.html#target_extraction.data_types.TargetText.tokenize">[docs]</a>    <span class="nd">@check_anonymised</span>
    <span class="k">def</span> <span class="nf">tokenize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokenizer</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">str</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
                 <span class="n">perform_type_checks</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        This will add a new key `tokenized_text` to this TargetText instance</span>
<span class="sd">        that will store the tokens of the text that is associated to this </span>
<span class="sd">        TargetText instance.</span>

<span class="sd">        For a set of tokenizers that are definitely comptable see </span>
<span class="sd">        target_extraction.tokenizers module.</span>

<span class="sd">        Ensures that the tokenization is character preserving.</span>

<span class="sd">        :param tokenizer: The tokenizer to use tokenize the text for each </span>
<span class="sd">                          TargetText instance in the current collection</span>
<span class="sd">        :param perform_type_checks: Whether or not to perform type checks </span>
<span class="sd">                                    to ensure the tokenizer returns a List of </span>
<span class="sd">                                    Strings</span>
<span class="sd">        :raises AnonymisedError: If the object has been anonymised then this </span>
<span class="sd">                                 method cannot be used.</span>
<span class="sd">        :raises TypeError: If the tokenizer given does not return a List of </span>
<span class="sd">                           Strings.</span>
<span class="sd">        :raises ValueError: This is raised if the TargetText instance contains</span>
<span class="sd">                            empty text.</span>
<span class="sd">        :raises ValueError: If the tokenization is not character preserving.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">text</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;text&#39;</span><span class="p">]</span>
        <span class="n">tokenized_text</span> <span class="o">=</span> <span class="n">tokenizer</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">perform_type_checks</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tokenized_text</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;The return type of the tokenizer function &#39;</span><span class="p">,</span>
                                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">tokenizer</span><span class="si">}</span><span class="s1"> should be a list and not &#39;</span>
                                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">tokenized_text</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">tokenized_text</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;The return type of the tokenizer function &#39;</span><span class="p">,</span>
                                    <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">tokenizer</span><span class="si">}</span><span class="s1"> should be a list of Strings&#39;</span>
                                    <span class="sa">f</span><span class="s1">&#39; and not a list of </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">token</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tokenized_text</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;There are no tokens for this TargetText &#39;</span>
                             <span class="sa">f</span><span class="s1">&#39;instance </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_character_preserving</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">tokenized_text</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The tokenization method used is not character&#39;</span>
                             <span class="sa">f</span><span class="s1">&#39; preserving. Original text `</span><span class="si">{</span><span class="n">text</span><span class="si">}</span><span class="s1">`</span><span class="se">\n</span><span class="s1">&#39;</span>
                             <span class="sa">f</span><span class="s1">&#39;Tokenized text `</span><span class="si">{</span><span class="n">tokenized_text</span><span class="si">}</span><span class="s1">`&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;tokenized_text&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tokenized_text</span></div>

<div class="viewcode-block" id="TargetText.pos_text"><a class="viewcode-back" href="../../target_extraction.html#target_extraction.data_types.TargetText.pos_text">[docs]</a>    <span class="nd">@check_anonymised</span>
    <span class="k">def</span> <span class="nf">pos_text</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tagger</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]],</span> 
                 <span class="n">perform_type_checks</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        This will add a new key `pos_tags` to this TargetText instance.</span>
<span class="sd">        This key will store the pos tags of the text that is associated to </span>
<span class="sd">        this Target Text instance. NOTE: It will also replace the current </span>
<span class="sd">        tokens in the `tokenized_text` key with the tokens produced </span>
<span class="sd">        from the pos tagger.</span>

<span class="sd">        For a set of pos taggers that are definetly comptable see </span>
<span class="sd">        target_extraction.pos_taggers module. The pos tagger will have to </span>
<span class="sd">        produce both a list of tokens and pos tags.</span>

<span class="sd">        :param tagger: POS tagger.</span>
<span class="sd">        :param perform_type_checks: Whether or not to perform type checks </span>
<span class="sd">                                    to ensure the POS tagger returns a </span>
<span class="sd">                                    tuple containing two lists both containing </span>
<span class="sd">                                    Strings.</span>
<span class="sd">        :raises AnonymisedError: If the object has been anonymised then this </span>
<span class="sd">                                 method cannot be used.</span>
<span class="sd">        :raises TypeError: If the POS tagger given does not return a Tuple</span>
<span class="sd">        :raises TypeError: If the POS tagger given does not return a List of </span>
<span class="sd">                           Strings for both the tokens and the pos tags.</span>
<span class="sd">        :raises TypeError: If the POS tagger tokens or pos tags are not lists</span>
<span class="sd">        :raises ValueError: If the POS tagger return is not a tuple of length </span>
<span class="sd">                            2</span>
<span class="sd">        :raises ValueError: This is raised if the Target Text text is empty</span>
<span class="sd">        :raises ValueError: If the number of pos tags for this instance</span>
<span class="sd">                            does not have the same number of tokens that has </span>
<span class="sd">                            been generated by the tokenizer function.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">text</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;text&#39;</span><span class="p">]</span>
        <span class="n">tokens_pos_tags</span> <span class="o">=</span> <span class="n">tagger</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">perform_type_checks</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tokens_pos_tags</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;The return type for the pos tagger should be&#39;</span>
                                <span class="sa">f</span><span class="s1">&#39; a tuple not </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">tokens_pos_tags</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tokens_pos_tags</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The return of the POS tagger should be a &#39;</span>
                                 <span class="sa">f</span><span class="s1">&#39;tuple of length 2 not </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">tokens_pos_tags</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tokens_pos_tags</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;The return type of the tagger function &#39;</span><span class="p">,</span>
                                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">tagger</span><span class="si">}</span><span class="s1"> should be a list and not &#39;</span>
                                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">tokens_pos_tags</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="si">}</span><span class="s1"> for the tokens&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tokens_pos_tags</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;The return type of the tagger function &#39;</span><span class="p">,</span>
                                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">tagger</span><span class="si">}</span><span class="s1"> should be a list and not &#39;</span>
                                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">tokens_pos_tags</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="si">}</span><span class="s1"> for the POS tags&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">tags</span> <span class="ow">in</span> <span class="p">[(</span><span class="s1">&#39;tokens&#39;</span><span class="p">,</span> <span class="n">tokens_pos_tags</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                               <span class="p">(</span><span class="s1">&#39;pos_tags&#39;</span><span class="p">,</span> <span class="n">tokens_pos_tags</span><span class="p">[</span><span class="mi">1</span><span class="p">])]:</span>
                <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">tags</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;The return type of the tagger function &#39;</span><span class="p">,</span>
                                        <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">tagger</span><span class="si">}</span><span class="s1"> should be a list of Strings&#39;</span>
                                        <span class="sa">f</span><span class="s1">&#39; and not a list of </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span><span class="si">}</span><span class="s1"> for &#39;</span>
                                        <span class="sa">f</span><span class="s1">&#39;the </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">tokens</span><span class="p">,</span> <span class="n">pos_tags</span> <span class="o">=</span> <span class="n">tokens_pos_tags</span>
        <span class="n">num_pos_tags</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos_tags</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos_tags</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;There are no tags for this TargetText &#39;</span>
                             <span class="sa">f</span><span class="s1">&#39;instance </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">num_tokens</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">num_tokens</span> <span class="o">!=</span> <span class="n">num_pos_tags</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Number of POS tags </span><span class="si">{</span><span class="n">pos_tags</span><span class="si">}</span><span class="s1"> should be the &#39;</span>
                             <span class="sa">f</span><span class="s1">&#39;same as the number of tokens </span><span class="si">{</span><span class="n">tokens</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;pos_tags&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pos_tags</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;tokenized_text&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tokens</span></div>

<div class="viewcode-block" id="TargetText.sequence_labels"><a class="viewcode-back" href="../../target_extraction.html#target_extraction.data_types.TargetText.sequence_labels">[docs]</a>    <span class="nd">@check_anonymised</span>
    <span class="k">def</span> <span class="nf">sequence_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">per_target</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 
                        <span class="n">label_key</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Adds the `sequence_labels` key to this TargetText instance which can </span>
<span class="sd">        be used to train a machine learning algorthim to detect targets. The </span>
<span class="sd">        value associated to the `sequence_labels` key will be a list of </span>
<span class="sd">        `B`, `I`, or `O` labels, where each label is associated to a token.</span>

<span class="sd">        The `force_targets` method might come in useful here for training </span>
<span class="sd">        and validation data to ensure that more of the targets are not </span>
<span class="sd">        affected by tokenization error as only tokens that are fully within </span>
<span class="sd">        the target span are labelled with `B` or `I` tags. Another use for the </span>
<span class="sd">        `force_targets` is so to ensure that targets are not affected by </span>
<span class="sd">        tokenisation and therefore can be used to state where the targets are </span>
<span class="sd">        in the sequence for sentiment classification e.g. in the case of </span>
<span class="sd">        getting contextualised target tokens or to create [TD-BERT </span>
<span class="sd">        Gao et al. 2019](https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8864964).</span>

<span class="sd">        Currently the only sequence labels supported is IOB-2 labels for the </span>
<span class="sd">        targets only. Future plans look into different sequence label order</span>
<span class="sd">        e.g. IOB see link below for more details of the difference between the </span>
<span class="sd">        two sequence, of which there are more sequence again.</span>
<span class="sd">        https://en.wikipedia.org/wiki/Inside%E2%80%93outside%E2%80%93beginning_(tagging)</span>

<span class="sd">        :param per_target: Whether the the value of associated to the </span>
<span class="sd">                           `sequence_labels` key should be one list for all </span>
<span class="sd">                           of the targets False. Or if True should be a list </span>
<span class="sd">                           of a labels per target where the labels will only </span>
<span class="sd">                           be associated to the represented target.</span>
<span class="sd">        :param label_key: Optional label key. Where the key represents a list of </span>
<span class="sd">                          values that are associated with each token. These list </span>
<span class="sd">                          of values are then the class labels to attach to </span>
<span class="sd">                          each `B`, `I`, `O` tag. E.g. the label key could be </span>
<span class="sd">                          `target_sentiments` therefore creating the sequence </span>
<span class="sd">                          labelling task of target extraction and predicting </span>
<span class="sd">                          sentiment. For example if the label key is `target_sentiments`</span>
<span class="sd">                          it would make the `B`, `I`, `O` task extraction </span>
<span class="sd">                          and sentiment prediction.</span>
<span class="sd">        :raises AnonymisedError: If the object has been anonymised then this </span>
<span class="sd">                                 method cannot be used.</span>
<span class="sd">        :raises KeyError: If the current TargetText has not been tokenized. Or </span>
<span class="sd">                          if `label_key` is not None then `label_key` must be </span>
<span class="sd">                          a key in self else KeyError.</span>
<span class="sd">        :raises ValueError: If `label_key` not None. Raises if number of labels </span>
<span class="sd">                            does not match the number of targets that the labels </span>
<span class="sd">                            should be associated too.</span>
<span class="sd">        :raises ValueError: If two targets overlap the same token(s) e.g </span>
<span class="sd">                            `Laptop cover was great` if `Laptop` and </span>
<span class="sd">                            `Laptop cover` are two separate targets this should </span>
<span class="sd">                            raise a ValueError as a token should only be </span>
<span class="sd">                            associated to one target.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">text</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;text&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s1">&#39;tokenized_text&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Expect the current TargetText </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s1"> to have &#39;</span>
                           <span class="s1">&#39;been tokenized using the self.tokenize method.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sanitize</span><span class="p">()</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;tokenized_text&#39;</span><span class="p">]</span>
        <span class="n">sequence_labels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;O&#39;</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">))]</span>

        <span class="k">if</span> <span class="n">per_target</span><span class="p">:</span>
            <span class="n">sequence_labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">sequence_labels</span><span class="p">]</span>
        <span class="c1"># This is the case where there are no targets thus all sequence labels </span>
        <span class="c1"># are `O`</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;spans&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;targets&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;sequence_labels&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sequence_labels</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">per_target</span><span class="p">:</span>
            <span class="n">sequence_labels</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;targets&#39;</span><span class="p">]:</span>
                <span class="n">sequence_labels</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="s1">&#39;O&#39;</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">))])</span>

        <span class="c1"># Setting up the labels that might be part of the sequence labels</span>
        <span class="n">target_spans</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Span</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;spans&#39;</span><span class="p">]</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">label_key</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_key_error</span><span class="p">(</span><span class="n">label_key</span><span class="p">)</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">label_key</span><span class="p">]</span>
            <span class="n">number_targets</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_spans</span><span class="p">)</span>
            <span class="n">number_labels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">number_labels</span> <span class="o">!=</span> <span class="n">number_targets</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;The number of labels </span><span class="si">{</span><span class="n">number_labels</span><span class="si">}</span><span class="s1"> does &#39;</span>
                                 <span class="sa">f</span><span class="s1">&#39;not match the number of targets </span><span class="si">{</span><span class="n">number_targets</span><span class="si">}</span><span class="s1">.&#39;</span>
                                 <span class="sa">f</span><span class="s1">&#39; Labels </span><span class="si">{</span><span class="n">labels</span><span class="si">}</span><span class="s1">, target spans </span><span class="si">{</span><span class="n">target_spans</span><span class="si">}</span><span class="s1">.&#39;</span>
                                 <span class="sa">f</span><span class="s1">&#39; For </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        
        <span class="n">tokens_index</span> <span class="o">=</span> <span class="n">token_index_alignment</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">tokens</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">target_index</span><span class="p">,</span> <span class="n">target_span</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">target_spans</span><span class="p">):</span>
            <span class="n">target_span_range</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="o">*</span><span class="n">target_span</span><span class="p">))</span>
            <span class="n">same_target</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">current_sequence_labels</span> <span class="o">=</span> <span class="n">sequence_labels</span>
            <span class="k">if</span> <span class="n">per_target</span><span class="p">:</span>
                <span class="n">current_sequence_labels</span> <span class="o">=</span> <span class="n">sequence_labels</span><span class="p">[</span><span class="n">target_index</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">sequence_index</span><span class="p">,</span> <span class="n">token_index</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tokens_index</span><span class="p">):</span>
                <span class="n">token_start</span><span class="p">,</span> <span class="n">token_end</span> <span class="o">=</span> <span class="n">token_index</span>
                <span class="n">token_end</span> <span class="o">=</span> <span class="n">token_end</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">token_start</span> <span class="ow">in</span> <span class="n">target_span_range</span> <span class="ow">and</span>
                    <span class="n">token_end</span> <span class="ow">in</span> <span class="n">target_span_range</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">current_sequence_labels</span><span class="p">[</span><span class="n">sequence_index</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;O&#39;</span><span class="p">:</span>
                        <span class="n">err_msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Cannot have two sequence labels for one &#39;</span>
                                    <span class="sa">f</span><span class="s1">&#39;token, text </span><span class="si">{</span><span class="n">text</span><span class="si">}</span><span class="se">\n</span><span class="s1">tokens </span><span class="si">{</span><span class="n">tokens</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>
                                    <span class="sa">f</span><span class="s1">&#39;token indexs </span><span class="si">{</span><span class="n">tokens_index</span><span class="si">}</span><span class="se">\n</span><span class="s1">Target &#39;</span>
                                    <span class="sa">f</span><span class="s1">&#39;spans </span><span class="si">{</span><span class="n">target_spans</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">same_target</span><span class="p">:</span>
                        <span class="n">current_sequence_labels</span><span class="p">[</span><span class="n">sequence_index</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;I&#39;</span>
                        <span class="k">if</span> <span class="n">label_key</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">label</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="n">target_index</span><span class="p">]</span>
                            <span class="n">current_sequence_labels</span><span class="p">[</span><span class="n">sequence_index</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;I-</span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s1">&#39;</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">current_sequence_labels</span><span class="p">[</span><span class="n">sequence_index</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;B&#39;</span>
                        <span class="k">if</span> <span class="n">label_key</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">label</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="n">target_index</span><span class="p">]</span>
                            <span class="n">current_sequence_labels</span><span class="p">[</span><span class="n">sequence_index</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;B-</span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s1">&#39;</span>
                    <span class="n">same_target</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;sequence_labels&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sequence_labels</span></div>

    <span class="k">def</span> <span class="nf">_key_error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        :param key: The key to check for within this TargetText instance.</span>
<span class="sd">        :raises KeyError: If the key given does not exist within this </span>
<span class="sd">                          TargetText instance.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s1">&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Requires that this TargetText contains </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s1"> for &#39;</span>
                           <span class="sa">f</span><span class="s1">&#39;instance </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="TargetText.get_sequence_indexs"><a class="viewcode-back" href="../../target_extraction.html#target_extraction.data_types.TargetText.get_sequence_indexs">[docs]</a>    <span class="nd">@check_anonymised</span>
    <span class="k">def</span> <span class="nf">get_sequence_indexs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sequence_key</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        The following sequence label tags are supported: IOB-2. These are the </span>
<span class="sd">        tags that are currently generated by `sequence_labels`. </span>

<span class="sd">        :param sequence_key: Key to sequence labels such as a BIO sequence </span>
<span class="sd">                             labels. Example key name would be `sequence_labels`</span>
<span class="sd">                             after `sequence_labels` function has been called </span>
<span class="sd">                             or more appropiately `predicted_sequence_labels` </span>
<span class="sd">                             when you have predicted sequence labels.</span>
<span class="sd">        :returns: A list of a list of intergers where each list of integers </span>
<span class="sd">                  represent the token/pos tag/sequence label index of each </span>
<span class="sd">                  sequence label span.</span>
<span class="sd">                  :Example: These sequence labels [`O`, `B`, `I`, `O`, `B`] </span>
<span class="sd">                            would return the following integers list [[1, 2], [4]]</span>
<span class="sd">        :raises AnonymisedError: If the object has been anonymised then this </span>
<span class="sd">                                 method cannot be used.</span>
<span class="sd">        :raises ValueError: If the sequence labels that are contained in the </span>
<span class="sd">                            sequence key value contain values other than </span>
<span class="sd">                            `B`, `I`, or `O`.</span>
<span class="sd">        :raises ValueError: If then number of tokens in the current TargetText </span>
<span class="sd">                            object is not the same as the number of sequence </span>
<span class="sd">                            labels.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># number of tokens and sequence labels, should </span>
        <span class="c1"># all be the same, it is if the `sequence_labels` function is used</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;tokenized_text&#39;</span><span class="p">]</span>
        <span class="n">sequence_labels</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">sequence_key</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sequence_labels</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;The number of tokens in the TargetText object </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s1">&#39;</span>
                             <span class="sa">f</span><span class="s1">&#39; is not the same as the number of sequence labels&#39;</span><span class="p">)</span>

        <span class="n">same_target</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">start_index</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">end_index</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">sequence_indexs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">label_index</span><span class="p">,</span> <span class="n">sequence_label</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sequence_labels</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">sequence_label</span> <span class="o">==</span> <span class="s1">&#39;B&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">same_target</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">sequence_index</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">start_index</span><span class="p">,</span> <span class="n">end_index</span><span class="p">))</span>
                    <span class="n">sequence_indexs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sequence_index</span><span class="p">)</span>
                    <span class="n">same_target</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="n">start_index</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">end_index</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="n">same_target</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">start_index</span> <span class="o">=</span> <span class="n">label_index</span>
                <span class="n">end_index</span> <span class="o">=</span> <span class="n">label_index</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">sequence_label</span> <span class="o">==</span> <span class="s1">&#39;I&#39;</span><span class="p">:</span>
                <span class="n">end_index</span> <span class="o">=</span> <span class="n">label_index</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">sequence_label</span> <span class="o">==</span> <span class="s1">&#39;O&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">same_target</span><span class="p">:</span>
                    <span class="n">sequence_index</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">start_index</span><span class="p">,</span> <span class="n">end_index</span><span class="p">))</span>
                    <span class="n">sequence_indexs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sequence_index</span><span class="p">)</span>
                    <span class="n">same_target</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="n">start_index</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">end_index</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Sequence labels should be `B` `I` or `O` &#39;</span>
                                 <span class="sa">f</span><span class="s1">&#39;and not </span><span class="si">{</span><span class="n">sequence_label</span><span class="si">}</span><span class="s1">. Sequence label &#39;</span>
                                 <span class="sa">f</span><span class="s1">&#39;key used </span><span class="si">{</span><span class="n">sequence_key</span><span class="si">}</span><span class="se">\n</span><span class="s1">TargetText </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">end_index</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">sequence_index</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">start_index</span><span class="p">,</span> <span class="n">end_index</span><span class="p">))</span>
            <span class="n">sequence_indexs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sequence_index</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sequence_indexs</span></div>

<div class="viewcode-block" id="TargetText.get_sequence_spans"><a class="viewcode-back" href="../../target_extraction.html#target_extraction.data_types.TargetText.get_sequence_spans">[docs]</a>    <span class="nd">@check_anonymised</span>
    <span class="k">def</span> <span class="nf">get_sequence_spans</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sequence_key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                           <span class="n">confidence</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Span</span><span class="p">]:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        The following sequence label tags are supported: IOB-2. These are the </span>
<span class="sd">        tags that are currently generated by `sequence_labels`</span>

<span class="sd">        :param sequence_key: Key to sequence labels such as a BIO sequence </span>
<span class="sd">                             labels. Example key name would be `sequence_labels`</span>
<span class="sd">                             after `sequence_labels` function has been called </span>
<span class="sd">                             or more appropiately `predicted_sequence_labels` </span>
<span class="sd">                             when you have predicted sequence labels.</span>
<span class="sd">        :param confidence: Optional argument that will return only spans </span>
<span class="sd">                           that have been predicted with a confidence </span>
<span class="sd">                           higher than this. </span>
<span class="sd">                           :NOTE: As it is BIO labelling in the case where </span>
<span class="sd">                                  all but one of the B and I&#39;s is greater than </span>
<span class="sd">                                  the threshold that span would not be </span>
<span class="sd">                                  returned, as one of the words in the multi </span>
<span class="sd">                                  word target word is less than the threshold.</span>
<span class="sd">        :returns: The span indexs from the sequence labels given assuming that </span>
<span class="sd">                  the sequence labels are in BIO format.</span>
<span class="sd">        :raises AnonymisedError: If the object has been anonymised then this </span>
<span class="sd">                                 method cannot be used.</span>
<span class="sd">        :raises KeyError: If no `confidence` key are found. However `confidence` </span>
<span class="sd">                          is only required if the confidence argument is set.</span>
<span class="sd">        :raises ValueError: If the sequence labels that are contained in the </span>
<span class="sd">                            sequence key value contain values other than </span>
<span class="sd">                            `B`, `I`, or `O`.</span>
<span class="sd">        :raises ValueError: If the confidence value is not between 0 and 1</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># number of tokens, sequence labels, and token text indexs should </span>
        <span class="c1"># all be the same, it is if the `sequence_labels` function is used</span>
        <span class="k">if</span> <span class="n">confidence</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_key_error</span><span class="p">(</span><span class="s1">&#39;confidence&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">confidence</span> <span class="o">&gt;</span> <span class="mf">1.0</span> <span class="ow">or</span> <span class="n">confidence</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Confidence value has to be bounded between &#39;</span>
                                 <span class="sa">f</span><span class="s1">&#39;1 and 0 and not </span><span class="si">{</span><span class="n">confidence</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="n">sequence_indexs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sequence_indexs</span><span class="p">(</span><span class="n">sequence_key</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">sequence_indexs</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;tokenized_text&#39;</span><span class="p">]</span>
        <span class="n">token_text_indexs</span> <span class="o">=</span> <span class="n">token_index_alignment</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;text&#39;</span><span class="p">],</span> <span class="n">tokens</span><span class="p">)</span>
        <span class="n">sequence_spans</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Span</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">confidences</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">confidence</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">confidences</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;confidence&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">span_sequence_index</span> <span class="ow">in</span> <span class="n">sequence_indexs</span><span class="p">:</span>
            <span class="c1"># Test that each sequence label was predicted with enough confidence </span>
            <span class="k">if</span> <span class="n">confidence</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">next_span</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">span_sequence_index</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">confidences</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">confidence</span><span class="p">:</span>
                        <span class="n">next_span</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="n">next_span</span><span class="p">:</span>
                    <span class="k">continue</span>
            <span class="n">start_index</span> <span class="o">=</span> <span class="n">span_sequence_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">start_span</span> <span class="o">=</span> <span class="n">token_text_indexs</span><span class="p">[</span><span class="n">start_index</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            
            <span class="n">end_index</span> <span class="o">=</span> <span class="n">span_sequence_index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">end_span</span> <span class="o">=</span> <span class="n">token_text_indexs</span><span class="p">[</span><span class="n">end_index</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">sequence_spans</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Span</span><span class="p">(</span><span class="n">start_span</span><span class="p">,</span> <span class="n">end_span</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">sequence_spans</span></div>

<div class="viewcode-block" id="TargetText.get_targets_from_sequence_labels"><a class="viewcode-back" href="../../target_extraction.html#target_extraction.data_types.TargetText.get_targets_from_sequence_labels">[docs]</a>    <span class="nd">@check_anonymised</span>
    <span class="k">def</span> <span class="nf">get_targets_from_sequence_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sequence_key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> 
                                         <span class="n">confidence</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                                         <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        This function mains use is when the sequence labels have been </span>
<span class="sd">        predicted on a piece of text that has no gold annotations.</span>

<span class="sd">        :param sequence_key: Key to sequence labels such as a BIO sequence </span>
<span class="sd">                             labels. Example key name would be `sequence_labels`</span>
<span class="sd">                             after `sequence_labels` function has been called </span>
<span class="sd">                             or more appropiately `predicted_sequence_labels` </span>
<span class="sd">                             when you have predicted sequence labels.</span>
<span class="sd">        :param confidence: Optional argument that will return only target </span>
<span class="sd">                           texts that have been predicted with a confidence </span>
<span class="sd">                           higher than this. </span>
<span class="sd">                           :NOTE: As it is BIO labelling in the case where </span>
<span class="sd">                                  all but one of the B and I&#39;s is greater than </span>
<span class="sd">                                  the threshold that target word would not be </span>
<span class="sd">                                  returned as one of the words in the multi </span>
<span class="sd">                                  word target word is less than the threshold.</span>
<span class="sd">        :returns: The target text&#39;s that the sequence labels have predcited.</span>
<span class="sd">        :raises AnonymisedError: If the object has been anonymised then this </span>
<span class="sd">                                 method cannot be used.</span>
<span class="sd">        :raises KeyError: If no `tokenized_text` or `confidence` key are found.</span>
<span class="sd">                          However `confidence` is only required if the </span>
<span class="sd">                          confidence argument is set.</span>
<span class="sd">        :raises ValueError: If the confidence value is not between 0 and 1</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">confidence</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_key_error</span><span class="p">(</span><span class="s1">&#39;confidence&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">confidence</span> <span class="o">&gt;</span> <span class="mf">1.0</span> <span class="ow">or</span> <span class="n">confidence</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Confidence value has to be bounded between &#39;</span>
                                 <span class="sa">f</span><span class="s1">&#39;1 and 0 and not </span><span class="si">{</span><span class="n">confidence</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_key_error</span><span class="p">(</span><span class="s1">&#39;tokenized_text&#39;</span><span class="p">)</span>
        <span class="n">sequence_indexs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sequence_indexs</span><span class="p">(</span><span class="n">sequence_key</span><span class="p">)</span>
        <span class="c1"># No targets to extract</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">sequence_indexs</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;tokenized_text&#39;</span><span class="p">]</span>
        <span class="n">confidences</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">confidence</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">confidences</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;confidence&#39;</span><span class="p">]</span>
        <span class="n">targets</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">span_sequence_index</span> <span class="ow">in</span> <span class="n">sequence_indexs</span><span class="p">:</span>
            <span class="n">start_index</span> <span class="o">=</span> <span class="n">span_sequence_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">end_index</span> <span class="o">=</span> <span class="n">span_sequence_index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">target_tokens</span> <span class="o">=</span> <span class="n">tokens</span><span class="p">[</span><span class="n">start_index</span><span class="p">:</span> <span class="n">end_index</span><span class="p">]</span>
            <span class="c1"># Test that each token in target tokens was predicted with a </span>
            <span class="c1"># great enough confidence</span>
            <span class="k">if</span> <span class="n">confidence</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">next_span</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">span_sequence_index</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">confidences</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">confidence</span><span class="p">:</span>
                        <span class="n">next_span</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="n">next_span</span><span class="p">:</span>
                    <span class="k">continue</span>
            <span class="n">target</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">target_tokens</span><span class="p">)</span>
            <span class="n">targets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">targets</span></div>

<div class="viewcode-block" id="TargetText.one_sample_per_span"><a class="viewcode-back" href="../../target_extraction.html#target_extraction.data_types.TargetText.one_sample_per_span">[docs]</a>    <span class="nd">@check_anonymised</span>
    <span class="k">def</span> <span class="nf">one_sample_per_span</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">remove_empty</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;TargetText&#39;</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        This returns a similar TargetText instance where the new instance </span>
<span class="sd">        will only contain one target per span. </span>
<span class="sd">        </span>
<span class="sd">        This is for the cases where you can have a target e.g. `food` that has </span>
<span class="sd">        a different related category attached to it e.g.</span>
<span class="sd">        TargetText(text=`$8 and there is much nicer, food, all of it great and </span>
<span class="sd">                  continually refilled.`, text_id=`1`, </span>
<span class="sd">                  targets=[`food`, `food`, `food`], </span>
<span class="sd">                  categories=[`style`, `quality`, `price`], </span>
<span class="sd">                  target_sentiments=[`pos`,`pos`,`pos`], </span>
<span class="sd">                  spans=[Span(27, 31),Span(27, 31),Span(27, 31)])</span>
<span class="sd">        As we can see the targets and the categories are linked, this is only </span>
<span class="sd">        really the case in SemEval 2016 datasets from what I know currently. </span>
<span class="sd">        In the example case above it will transform it to the following:</span>
<span class="sd">        TargetText(text=`$8 and there is much nicer, food, all of it great and </span>
<span class="sd">                   continually refilled.`, text_id=`1`, </span>
<span class="sd">                   targets=[`food`],spans=[Span(27,31)])</span>
<span class="sd">        This type of pre-processing is perfect for the Target Extraction </span>
<span class="sd">        task.</span>

<span class="sd">        :param remove_empty: If the TargetText instance contains any None </span>
<span class="sd">                             targets then these will be removed along with </span>
<span class="sd">                             their respective Spans.</span>
<span class="sd">        :returns: This returns a similar TargetText instance where the new </span>
<span class="sd">                  instance will only contain one target per span.</span>
<span class="sd">        :raises AnonymisedError: If the object has been anonymised then this </span>
<span class="sd">                                 method cannot be used.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">text</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;text&#39;</span><span class="p">]</span>
        <span class="n">text_id</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;text_id&#39;</span><span class="p">]</span>
        <span class="n">targets</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">spans</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Span</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;spans&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">TargetText</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="n">text</span><span class="p">,</span> <span class="n">text_id</span><span class="o">=</span><span class="n">text_id</span><span class="p">)</span>

        <span class="n">current_spans</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;spans&#39;</span><span class="p">]</span>
        <span class="n">unique_spans</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">current_spans</span><span class="p">)</span>
        <span class="n">spans</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">unique_spans</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">temp_spans</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Span</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">span</span> <span class="ow">in</span> <span class="n">spans</span><span class="p">:</span>
            <span class="n">targets_text</span> <span class="o">=</span> <span class="n">text</span><span class="p">[</span><span class="n">span</span><span class="o">.</span><span class="n">start</span><span class="p">:</span> <span class="n">span</span><span class="o">.</span><span class="n">end</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">span</span><span class="o">.</span><span class="n">start</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">span</span><span class="o">.</span><span class="n">end</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">remove_empty</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">temp_spans</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">span</span><span class="p">)</span>
                <span class="n">targets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">targets_text</span><span class="p">)</span>
        <span class="n">spans</span> <span class="o">=</span> <span class="n">temp_spans</span>
        <span class="k">return</span> <span class="n">TargetText</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="n">text</span><span class="p">,</span> <span class="n">text_id</span><span class="o">=</span><span class="n">text_id</span><span class="p">,</span> 
                          <span class="n">targets</span><span class="o">=</span><span class="n">targets</span><span class="p">,</span> <span class="n">spans</span><span class="o">=</span><span class="n">spans</span><span class="p">)</span></div>

<div class="viewcode-block" id="TargetText.left_right_target_contexts"><a class="viewcode-back" href="../../target_extraction.html#target_extraction.data_types.TargetText.left_right_target_contexts">[docs]</a>    <span class="nd">@check_anonymised</span>
    <span class="k">def</span> <span class="nf">left_right_target_contexts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">incl_target</span><span class="p">:</span> <span class="nb">bool</span>
                                   <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        :param incl_target: Whether or not the left and right sentences should </span>
<span class="sd">                            also include the target word.</span>
<span class="sd">        :returns: The sentence that is left and right of the target as well as </span>
<span class="sd">                  the words in the target for each target in the sentence.</span>
<span class="sd">        :raises AnonymisedError: If the object has been anonymised then this </span>
<span class="sd">                                 method cannot be used.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">left_right_target_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">text</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;text&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;spans&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">span</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;spans&#39;</span><span class="p">]:</span>
                <span class="n">span</span><span class="p">:</span> <span class="n">Span</span>
                <span class="n">span_start</span> <span class="o">=</span> <span class="n">span</span><span class="o">.</span><span class="n">start</span>
                <span class="n">span_end</span> <span class="o">=</span> <span class="n">span</span><span class="o">.</span><span class="n">end</span>
                <span class="k">if</span> <span class="n">incl_target</span><span class="p">:</span>
                    <span class="n">left_context</span> <span class="o">=</span> <span class="n">text</span><span class="p">[:</span><span class="n">span_end</span><span class="p">]</span>
                    <span class="n">right_context</span> <span class="o">=</span> <span class="n">text</span><span class="p">[</span><span class="n">span_start</span><span class="p">:]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">left_context</span> <span class="o">=</span> <span class="n">text</span><span class="p">[:</span><span class="n">span_start</span><span class="p">]</span>
                    <span class="n">right_context</span> <span class="o">=</span> <span class="n">text</span><span class="p">[</span><span class="n">span_end</span><span class="p">:]</span>
                <span class="n">target_context</span> <span class="o">=</span> <span class="n">text</span><span class="p">[</span><span class="n">span_start</span><span class="p">:</span><span class="n">span_end</span><span class="p">]</span>
                <span class="n">contexts</span> <span class="o">=</span> <span class="p">(</span><span class="n">left_context</span><span class="p">,</span> <span class="n">right_context</span><span class="p">,</span> <span class="n">target_context</span><span class="p">)</span>
                <span class="n">left_right_target_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">contexts</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">left_right_target_list</span>  </div>

<div class="viewcode-block" id="TargetText.replace_target"><a class="viewcode-back" href="../../target_extraction.html#target_extraction.data_types.TargetText.replace_target">[docs]</a>    <span class="nd">@check_anonymised</span>
    <span class="k">def</span> <span class="nf">replace_target</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">replacement_target_word</span><span class="p">:</span> <span class="nb">str</span>
                       <span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;TargetText&#39;</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        :params target_index: The target index of the target word to replace</span>
<span class="sd">        :param replacement_target_word: The target word to replace the target </span>
<span class="sd">                                        word at the given index</span>
<span class="sd">        :returns: Given the target index and replacement target word it will </span>
<span class="sd">                  replace the target at the index with the new target word and </span>
<span class="sd">                  return a new TargetText object with everything the same apart </span>
<span class="sd">                  from this new target.</span>
<span class="sd">        :raises ValueError: If the target_index is less than 0 or an index </span>
<span class="sd">                            number that does not exist.</span>
<span class="sd">        :raises OverLappingTargetsError: If the target to replace is contained </span>
<span class="sd">                                         within another target e.g. </span>
<span class="sd">                                         `what a great day` if this has two </span>
<span class="sd">                                         targets `great` and `great day` then </span>
<span class="sd">                                         it will raise this error if you </span>
<span class="sd">                                         replace either word as each is </span>
<span class="sd">                                         within the other.</span>
<span class="sd">        :raises AnonymisedError: If the object has been anonymised then this </span>
<span class="sd">                                 method cannot be used.</span>
<span class="sd">        :Example: Given the following TargetText Object </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">self_dict</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

        <span class="n">number_targets</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">self_dict</span><span class="p">[</span><span class="s1">&#39;targets&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">target_index</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">target_index</span> <span class="o">&gt;=</span> <span class="n">number_targets</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Not a valid target_index number. Number of targets&#39;</span>
                             <span class="sa">f</span><span class="s1">&#39;in the current object </span><span class="si">{</span><span class="n">number_targets</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="c1"># Change the target word</span>
        <span class="n">targets</span> <span class="o">=</span> <span class="n">self_dict</span><span class="p">[</span><span class="s1">&#39;targets&#39;</span><span class="p">]</span>
        <span class="n">target_to_be_replaced</span> <span class="o">=</span> <span class="n">targets</span><span class="p">[</span><span class="n">target_index</span><span class="p">]</span>
        <span class="n">targets</span><span class="p">[</span><span class="n">target_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">replacement_target_word</span>

        <span class="c1"># Change the target spans</span>
        <span class="n">spans</span> <span class="o">=</span> <span class="n">self_dict</span><span class="p">[</span><span class="s1">&#39;spans&#39;</span><span class="p">]</span>
        <span class="n">span_to_change</span> <span class="o">=</span> <span class="n">spans</span><span class="p">[</span><span class="n">target_index</span><span class="p">]</span>
        <span class="n">spans_to_change</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">span_index</span><span class="p">,</span> <span class="n">span</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">spans</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">span_index</span> <span class="o">==</span> <span class="n">target_index</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">span</span><span class="p">:</span> <span class="n">Span</span>
            
            <span class="c1"># Check that there are no overlapping targets</span>
            <span class="n">raise_in_target_error</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">span</span><span class="o">.</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="n">span_to_change</span><span class="o">.</span><span class="n">start</span> <span class="ow">and</span> <span class="n">span</span><span class="o">.</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">span_to_change</span><span class="o">.</span><span class="n">end</span><span class="p">:</span>
                <span class="n">raise_in_target_error</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="n">span</span><span class="o">.</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">span_to_change</span><span class="o">.</span><span class="n">start</span> <span class="ow">and</span> <span class="n">span</span><span class="o">.</span><span class="n">end</span> <span class="o">&lt;=</span> <span class="n">span_to_change</span><span class="o">.</span><span class="n">end</span><span class="p">:</span>
                <span class="n">raise_in_target_error</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="n">raise_in_target_error</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">OverLappingTargetsError</span><span class="p">(</span><span class="s1">&#39;There are targets that share &#39;</span>
                                              <span class="sa">f</span><span class="s1">&#39;the same context </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">span</span><span class="o">.</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="n">span_to_change</span><span class="o">.</span><span class="n">end</span><span class="p">:</span>
                <span class="n">spans_to_change</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">span_index</span><span class="p">)</span>
        
        <span class="n">difference_in_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">replacement_target_word</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_to_be_replaced</span><span class="p">)</span> 
        <span class="c1"># Change all of the spans</span>
        <span class="k">for</span> <span class="n">span_index</span> <span class="ow">in</span> <span class="n">spans_to_change</span><span class="p">:</span>
            <span class="n">span</span> <span class="o">=</span> <span class="n">spans</span><span class="p">[</span><span class="n">span_index</span><span class="p">]</span>
            <span class="n">new_start</span> <span class="o">=</span> <span class="n">span</span><span class="o">.</span><span class="n">start</span> <span class="o">+</span> <span class="n">difference_in_length</span>
            <span class="n">new_end</span> <span class="o">=</span> <span class="n">span</span><span class="o">.</span><span class="n">end</span> <span class="o">+</span> <span class="n">difference_in_length</span>
            <span class="n">spans</span><span class="p">[</span><span class="n">span_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">Span</span><span class="p">(</span><span class="n">new_start</span><span class="p">,</span> <span class="n">new_end</span><span class="p">)</span>
        <span class="c1"># Change the target that is being replaced span by only the end</span>
        <span class="n">new_end</span> <span class="o">=</span> <span class="n">span_to_change</span><span class="o">.</span><span class="n">end</span> <span class="o">+</span> <span class="n">difference_in_length</span>
        <span class="n">spans</span><span class="p">[</span><span class="n">target_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">Span</span><span class="p">(</span><span class="n">span_to_change</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">new_end</span><span class="p">)</span>
        <span class="c1"># Change the text</span>
        <span class="n">text</span> <span class="o">=</span> <span class="n">self_dict</span><span class="p">[</span><span class="s1">&#39;text&#39;</span><span class="p">]</span>
        <span class="n">span_to_change_start</span> <span class="o">=</span> <span class="n">span_to_change</span><span class="o">.</span><span class="n">start</span>
        <span class="n">span_to_change_end</span> <span class="o">=</span> <span class="n">span_to_change</span><span class="o">.</span><span class="n">end</span>
        <span class="n">start_text</span> <span class="o">=</span> <span class="n">text</span><span class="p">[:</span><span class="n">span_to_change_start</span><span class="p">]</span>
        <span class="n">end_text</span> <span class="o">=</span> <span class="n">text</span><span class="p">[</span><span class="n">span_to_change_end</span><span class="p">:]</span>
        <span class="n">text</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">start_text</span><span class="si">}{</span><span class="n">replacement_target_word</span><span class="si">}{</span><span class="n">end_text</span><span class="si">}</span><span class="s1">&#39;</span>
        
        <span class="n">self_dict</span><span class="p">[</span><span class="s1">&#39;targets&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">targets</span>
        <span class="n">self_dict</span><span class="p">[</span><span class="s1">&#39;spans&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">spans</span>
        <span class="n">self_dict</span><span class="p">[</span><span class="s1">&#39;text&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">text</span>
        <span class="k">return</span> <span class="n">TargetText</span><span class="p">(</span><span class="o">**</span><span class="n">self_dict</span><span class="p">)</span></div>

<div class="viewcode-block" id="TargetText.de_anonymise"><a class="viewcode-back" href="../../target_extraction.html#target_extraction.data_types.TargetText.de_anonymise">[docs]</a>    <span class="k">def</span> <span class="nf">de_anonymise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        This will set the `anonymised` attribute to False from True and </span>
<span class="sd">        set the `text` key value to the value in the `text` key within the </span>
<span class="sd">        `text_dict` argument.</span>

<span class="sd">        :param text_dict: A dictionary that contain the following two keys: </span>
<span class="sd">                          1. `text` and 2. `text_id` where the `text_id` has </span>
<span class="sd">                          to match the current TargetText object `text_id` and </span>
<span class="sd">                          the `text` value will become the new value in the </span>
<span class="sd">                          `text` key for this TargetText object.</span>
<span class="sd">        :raises ValueError: If the TargetText object `text_id` does not match </span>
<span class="sd">                            the `text_id` within `text_dict` argument.</span>
<span class="sd">        :raises AnonymisedError: If the `text` given does not pass the </span>
<span class="sd">                                 :py:meth:`sanitize` test.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">current_text_id</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;text_id&#39;</span><span class="p">]</span>
        <span class="n">other_text_id</span> <span class="o">=</span> <span class="n">text_dict</span><span class="p">[</span><span class="s1">&#39;text_id&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">current_text_id</span> <span class="o">!=</span> <span class="n">other_text_id</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The current `text_id` </span><span class="si">{</span><span class="n">current_text_id</span><span class="si">}</span><span class="s2"> &quot;</span>
                             <span class="s2">&quot;does not match that of the argument&#39;s `text_id`&quot;</span>
                             <span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="n">other_text_id</span><span class="si">}</span><span class="s2">. For TargetText </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">text</span> <span class="o">=</span> <span class="n">text_dict</span><span class="p">[</span><span class="s1">&#39;text&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="p">[</span><span class="s1">&#39;text&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">text</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">anonymised</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">except</span> <span class="n">AnonymisedError</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="p">[</span><span class="s1">&#39;text&#39;</span><span class="p">]</span>
            <span class="n">sanitize_err</span> <span class="o">=</span> <span class="n">traceback</span><span class="o">.</span><span class="n">format_exc</span><span class="p">()</span>
            <span class="k">raise</span> <span class="n">AnonymisedError</span><span class="p">(</span><span class="s1">&#39;Cannot de-anonymise this TargetText &#39;</span>
                                  <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s1"> as it cannot pass the `sanitize`&#39;</span>
                                  <span class="s1">&#39; check of which the following is the &#39;</span>
                                  <span class="sa">f</span><span class="s1">&#39;error from said check </span><span class="si">{</span><span class="n">sanitize_err</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="TargetText.in_order"><a class="viewcode-back" href="../../target_extraction.html#target_extraction.data_types.TargetText.in_order">[docs]</a>    <span class="k">def</span> <span class="nf">in_order</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        :returns: True if all the `targets` within this TargetText </span>
<span class="sd">                  are in sequential left to right order within the text.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">spans</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;spans&#39;</span><span class="p">]</span>
        <span class="n">ordered_spans</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">spans</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ordered_spans</span> <span class="o">!=</span> <span class="n">spans</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="TargetText.re_order"><a class="viewcode-back" href="../../target_extraction.html#target_extraction.data_types.TargetText.re_order">[docs]</a>    <span class="k">def</span> <span class="nf">re_order</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys_not_to_order</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Re-orders the TargetText object so that the targets are in a left to </span>
<span class="sd">        right order within the text, this will then re-order all values within </span>
<span class="sd">        this object that are in a list format into this order. Once the </span>
<span class="sd">        TargetText has been re-ordered it will return True when </span>
<span class="sd">        :py:meth`target_extraction.data_types.TargetText.in_order` is called.</span>

<span class="sd">        :param keys_not_to_order: Any key values not to re-order using this </span>
<span class="sd">                                  function e.g. `pos_tags`, `tokenized_text`, </span>
<span class="sd">                                  etc</span>
<span class="sd">        :raises AssertionError: If running :py:meth`target_extraction.data_types.TargetText.in_order`</span>
<span class="sd">                                after being re-ordered does not return True.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">def</span> <span class="nf">sorting_by_index</span><span class="p">(</span><span class="n">index_order</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> 
                             <span class="n">value_to_sort</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">]:</span>
            <span class="n">sorted_value</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">index_order</span><span class="p">:</span>
                <span class="n">sorted_value</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value_to_sort</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">sorted_value</span>

        <span class="k">if</span> <span class="n">keys_not_to_order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">keys_not_to_order</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">spans</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Span</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;spans&#39;</span><span class="p">]</span>
        <span class="n">index_order</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">spans</span><span class="p">)),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="n">spans</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> 
                             <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">new_key_values</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">keys_not_to_order</span><span class="p">:</span>
                    <span class="c1"># Edge case where the list can be just an empty list</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">value</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="c1"># Need to check if the first instance of the value is a </span>
                    <span class="c1"># list and if so then that needs to be sorted and not the </span>
                    <span class="c1"># outer list</span>
                    <span class="n">sorted_value</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">inner_value</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
                            <span class="n">sorted_inner_value</span> <span class="o">=</span> <span class="n">sorting_by_index</span><span class="p">(</span><span class="n">index_order</span><span class="p">,</span> 
                                                                  <span class="n">inner_value</span><span class="p">)</span>
                            <span class="n">sorted_value</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sorted_inner_value</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">sorted_value</span> <span class="o">=</span> <span class="n">sorting_by_index</span><span class="p">(</span><span class="n">index_order</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
                    <span class="k">assert</span> <span class="n">sorted_value</span>
                    <span class="n">new_key_values</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">sorted_value</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">real_err</span> <span class="o">=</span> <span class="n">traceback</span><span class="o">.</span><span class="n">format_exc</span><span class="p">()</span>
                <span class="n">err_msg</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s1">&#39;The following error </span><span class="si">{</span><span class="n">real_err</span><span class="si">}</span><span class="s1"> has occured on the &#39;</span>
                           <span class="sa">f</span><span class="s1">&#39;following key </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s1"> and value </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s1"> for this &#39;</span>
                           <span class="sa">f</span><span class="s1">&#39;TargetText </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>
        <span class="c1"># Covers the rollback problem</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">new_key_values</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sanitize</span><span class="p">()</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_order</span><span class="p">(),</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;After re-ordering the object is &#39;</span>
                                      <span class="sa">f</span><span class="s1">&#39;still not in order:</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="TargetText.add_unique_key"><a class="viewcode-back" href="../../target_extraction.html#target_extraction.data_types.TargetText.add_unique_key">[docs]</a>    <span class="k">def</span> <span class="nf">add_unique_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">id_key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">id_key_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> 
                       <span class="n">id_delimiter</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;::&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        :param id_key: The name of the key within this TargetText that requires </span>
<span class="sd">                       unique ids that will be stored in `id_key_name`.</span>
<span class="sd">        :param id_key_name: The name of the key to associate to these new </span>
<span class="sd">                            unique ids.</span>
<span class="sd">        :param id_delimiter: The delimiter to seperate the `text_id` and the </span>
<span class="sd">                             index of the `id_key` that is being represented </span>
<span class="sd">                             by this unique id.</span>
<span class="sd">        :raises KeyError: If the `id_key_name` already exists within the </span>
<span class="sd">                          TargetText.</span>
<span class="sd">        :raises TypeError: If the value of `id_key` is not of type List.</span>
<span class="sd">        :Example: self.add_unique_key(`targets`, `targets_id`) where </span>
<span class="sd">                  `targets`=[`food`, `service`] and `text_id`=`12a5` the </span>
<span class="sd">                  following key will be added to self `targets_id` with the </span>
<span class="sd">                  following value = `[`12a5::0`, `12a5::1`]`</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_key_error</span><span class="p">(</span><span class="n">id_key</span><span class="p">)</span>
        <span class="n">text_id</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;text_id&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">id_key_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;The new id_key_name </span><span class="si">{</span><span class="n">id_key_name</span><span class="si">}</span><span class="s1"> &#39;</span>
                           <span class="sa">f</span><span class="s1">&#39;already exists within </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">id_key</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;The value of `id_key` </span><span class="si">{</span><span class="bp">self</span><span class="p">[</span><span class="n">id_key</span><span class="p">]</span><span class="si">}</span><span class="s1"> in </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s1"> &#39;</span>
                            <span class="sa">f</span><span class="s1">&#39;has to be of type List and not </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">id_key</span><span class="p">])</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">new_ids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">id_key</span><span class="p">])):</span>
            <span class="n">new_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">text_id</span><span class="si">}{</span><span class="n">id_delimiter</span><span class="si">}{</span><span class="n">index</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">id_key_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_ids</span></div>

<div class="viewcode-block" id="TargetText.from_json"><a class="viewcode-back" href="../../target_extraction.html#target_extraction.data_types.TargetText.from_json">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_json</span><span class="p">(</span><span class="n">json_text</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">anonymised</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;TargetText&#39;</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        This is required as the &#39;spans&#39; are Span objects which are not json </span>
<span class="sd">        serlizable and are required for TargetText therefore this handles </span>
<span class="sd">        that special case.</span>

<span class="sd">        This function is also required as we have had to avoid using the </span>
<span class="sd">        __set__ function and add objects via the _storage dictionary </span>
<span class="sd">        underneath so that we could add values to this object that are not </span>
<span class="sd">        within the constructor like `tokenized_text`. To ensure that it is </span>
<span class="sd">        compatable with the TargetText concept we call `TargetText.sanitize`</span>
<span class="sd">        method at the end.</span>

<span class="sd">        :param json_text: JSON representation of TargetText </span>
<span class="sd">                          (can be from TargetText.to_json)</span>
<span class="sd">        :param anonymised: Whether or not the TargetText object being loaded </span>
<span class="sd">                           is an anonymised version.</span>
<span class="sd">        :returns: A TargetText object</span>
<span class="sd">        :raises KeyError: If within the JSON representation there is no </span>
<span class="sd">                          `text_id` key. Or if anonymised is False raises a</span>
<span class="sd">                          KeyError if there is no `text` key in the JSON </span>
<span class="sd">                          representation.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">json_target_text</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">json_text</span><span class="p">)</span>
        <span class="n">text</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="s1">&#39;text_id&#39;</span> <span class="ow">in</span> <span class="n">json_target_text</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;The JSON text given does not contain a &#39;</span>
                           <span class="sa">f</span><span class="s1">&#39;`text_id` field: </span><span class="si">{</span><span class="n">json_target_text</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">anonymised</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="s1">&#39;text&#39;</span> <span class="ow">in</span> <span class="n">json_target_text</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;The JSON text given does not contain a `text`&#39;</span>
                               <span class="sa">f</span><span class="s1">&#39;field: </span><span class="si">{</span><span class="n">json_target_text</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">text</span> <span class="o">=</span> <span class="n">json_target_text</span><span class="p">[</span><span class="s1">&#39;text&#39;</span><span class="p">]</span>
    
        <span class="n">target_text</span> <span class="o">=</span> <span class="n">TargetText</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="n">text</span><span class="p">,</span> <span class="n">anonymised</span><span class="o">=</span><span class="n">anonymised</span><span class="p">,</span>
                                 <span class="n">text_id</span><span class="o">=</span><span class="n">json_target_text</span><span class="p">[</span><span class="s1">&#39;text_id&#39;</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">json_target_text</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;text&#39;</span> <span class="ow">or</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;text_id&#39;</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;spans&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">target_text</span><span class="o">.</span><span class="n">_storage</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">all_spans</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">span</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
                        <span class="n">all_spans</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Span</span><span class="p">(</span><span class="o">*</span><span class="n">span</span><span class="p">))</span>
                    <span class="n">target_text</span><span class="o">.</span><span class="n">_storage</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">all_spans</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">target_text</span><span class="o">.</span><span class="n">_storage</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="n">target_text</span><span class="o">.</span><span class="n">sanitize</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">target_text</span></div>

<div class="viewcode-block" id="TargetText.targets_from_spans"><a class="viewcode-back" href="../../target_extraction.html#target_extraction.data_types.TargetText.targets_from_spans">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">targets_from_spans</span><span class="p">(</span><span class="n">text</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span> <span class="n">spans</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Span</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        :param text: The text that the spans are associated too.</span>
<span class="sd">        :param spans: A list of Span values that represent the character index </span>
<span class="sd">                      of the target words to be returned.</span>
<span class="sd">        :returns: The target words that are associated to the spans and text </span>
<span class="sd">                  given.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">targets</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">spans</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">targets</span>
        <span class="k">for</span> <span class="n">span</span> <span class="ow">in</span> <span class="n">spans</span><span class="p">:</span>
            <span class="n">target</span> <span class="o">=</span> <span class="n">text</span><span class="p">[</span><span class="n">span</span><span class="o">.</span><span class="n">start</span><span class="p">:</span> <span class="n">span</span><span class="o">.</span><span class="n">end</span><span class="p">]</span>
            <span class="n">targets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">targets</span></div>

<div class="viewcode-block" id="TargetText.target_text_from_prediction"><a class="viewcode-back" href="../../target_extraction.html#target_extraction.data_types.TargetText.target_text_from_prediction">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">target_text_from_prediction</span><span class="p">(</span><span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">text_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> 
                                    <span class="n">sequence_labels</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> 
                                    <span class="n">tokenized_text</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
                                    <span class="n">confidence</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                    <span class="n">confidences</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                    <span class="o">**</span><span class="n">additional_data</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;TargetText&#39;</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Creates a TargetText object from data that has come from predictions</span>
<span class="sd">        of a Target Extract tagger e.g. the dictionaries that are returned </span>
<span class="sd">        from :meth:`target_extraction.allen.allennlp_model.predict_sequences`</span>

<span class="sd">        :param text: Text to give to the TargetText object</span>
<span class="sd">        :param text_id: Text ID to give to the TargetText object</span>
<span class="sd">        :param sequence_labels: The predicted sequence labels</span>
<span class="sd">        :param tokenized_text: The tokens that were used to produce the </span>
<span class="sd">                               predicted sequence labels (should be returned </span>
<span class="sd">                               by the Target Extract tagger predictor).</span>
<span class="sd">        :param confidence: The level of confidence from the tagger that is </span>
<span class="sd">                           required for a target to be a target e.g. 0.9</span>
<span class="sd">        :param confidences: The list of confidence values produced </span>
<span class="sd">                            by the Target Extract tagger predictor to be used </span>
<span class="sd">                            with the confidence argument. The list of confidence </span>
<span class="sd">                            values should be the same size as the sequence labels </span>
<span class="sd">                            list and tokenized text.</span>
<span class="sd">        :param additional_data: Any other keyword arguments to provide to the </span>
<span class="sd">                                TargetText object</span>
<span class="sd">        :returns: A TargetText object with spans and targets values</span>
<span class="sd">        :raises ValueError: If sequence labels, tokenized text and confidecnes </span>
<span class="sd">                            are not of the same length</span>
<span class="sd">        :raises ValueError: If the following keys are in the additional data;</span>
<span class="sd">                            1. confidence, 2. text, 3. text_id, 4. tokenized_text</span>
<span class="sd">                            5. sequence_labels, 6. targets, 7. spans. As these </span>
<span class="sd">                            keys will be populated by within the TargetText </span>
<span class="sd">                            object automatically.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sequence_labels</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tokenized_text</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Sequence labels and tokenized texts are not of &#39;</span>
                             <span class="sa">f</span><span class="s1">&#39;the same length:</span><span class="se">\n</span><span class="s1">Sequence labels </span><span class="si">{</span><span class="n">sequence_labels</span><span class="si">}</span><span class="s1">&#39;</span>
                             <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Tokenized text: </span><span class="si">{</span><span class="n">tokenized_text</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">confidence</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">sequence_labels</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">confidences</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Sequence labels and confidences are not of &#39;</span>
                             <span class="sa">f</span><span class="s1">&#39;the same length:</span><span class="se">\n</span><span class="s1">Sequence labels </span><span class="si">{</span><span class="n">sequence_labels</span><span class="si">}</span><span class="s1">&#39;</span>
                             <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">confidences: </span><span class="si">{</span><span class="n">confidences</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">not_allowed_additional_keys</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;confidence&#39;</span><span class="p">,</span> <span class="s1">&#39;text&#39;</span><span class="p">,</span> <span class="s1">&#39;text_id&#39;</span><span class="p">,</span> 
                                       <span class="s1">&#39;tokenized_text&#39;</span><span class="p">,</span> <span class="s1">&#39;sequence_labels&#39;</span><span class="p">,</span>
                                       <span class="s1">&#39;targets&#39;</span><span class="p">,</span> <span class="s1">&#39;spans&#39;</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">additional_data</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">not_allowed_additional_keys</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The following keys are not allowd in the &quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;additional data:</span><span class="se">\n</span><span class="si">{</span><span class="n">not_allowed_additional_keys</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">temp_target_text</span> <span class="o">=</span> <span class="n">TargetText</span><span class="p">(</span><span class="n">text_id</span><span class="o">=</span><span class="n">text_id</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="n">text</span><span class="p">,</span> 
                                      <span class="n">tokenized_text</span><span class="o">=</span><span class="n">tokenized_text</span><span class="p">,</span>
                                      <span class="n">sequence_labels</span><span class="o">=</span><span class="n">sequence_labels</span><span class="p">,</span>
                                      <span class="n">confidence</span><span class="o">=</span><span class="n">confidences</span><span class="p">)</span>
        <span class="n">target_spans</span> <span class="o">=</span> <span class="n">temp_target_text</span><span class="o">.</span><span class="n">get_sequence_spans</span><span class="p">(</span><span class="s1">&#39;sequence_labels&#39;</span><span class="p">,</span>
                                                           <span class="n">confidence</span><span class="o">=</span><span class="n">confidence</span><span class="p">)</span>
        <span class="n">targets</span> <span class="o">=</span> <span class="n">TargetText</span><span class="o">.</span><span class="n">targets_from_spans</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">target_spans</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">TargetText</span><span class="p">(</span><span class="n">text_id</span><span class="o">=</span><span class="n">text_id</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="n">text</span><span class="p">,</span> <span class="n">confidence</span><span class="o">=</span><span class="n">confidences</span><span class="p">,</span>
                          <span class="n">tokenized_text</span><span class="o">=</span><span class="n">tokenized_text</span><span class="p">,</span> <span class="n">targets</span><span class="o">=</span><span class="n">targets</span><span class="p">,</span>
                          <span class="n">spans</span><span class="o">=</span><span class="n">target_spans</span><span class="p">,</span> <span class="n">sequence_labels</span><span class="o">=</span><span class="n">sequence_labels</span><span class="p">,</span>
                          <span class="o">**</span><span class="n">additional_data</span><span class="p">)</span></div></div>



<div class="viewcode-block" id="TargetTextCollection"><a class="viewcode-back" href="../../target_extraction.html#target_extraction.data_types.TargetTextCollection">[docs]</a><span class="k">class</span> <span class="nc">TargetTextCollection</span><span class="p">(</span><span class="n">MutableMapping</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    This is a data structure that inherits from MutableMapping which is </span>
<span class="sd">    essentially a python dictionary, however the underlying storage is a </span>
<span class="sd">    OrderedDict therefore if you iterate over it, the iteration will always be </span>
<span class="sd">    in the same order.</span>

<span class="sd">    This structure only contains TargetText instances.</span>

<span class="sd">    Attributes:</span>
<span class="sd">    </span>
<span class="sd">    1. name -- Name associated to the TargetTextCollection.</span>
<span class="sd">    2. metadata -- Any metadata to associate to the object e.g. domain of the </span>
<span class="sd">       dataset, all metadata is stored in a dictionary. By default the </span>
<span class="sd">       metadata will always have the `name` attribute within </span>
<span class="sd">       the metadata under the key `name`. If `anonymised` is also True then </span>
<span class="sd">       this will also be in the metadata under the key `anonymised`</span>
<span class="sd">    3. anonymised -- If True then the data within the TargetText objects have </span>
<span class="sd">       no text but the rest of the metadata should exist.</span>

<span class="sd">    Methods:</span>
<span class="sd">    </span>
<span class="sd">    1. to_json -- Writes each TargetText instances as a dictionary using it&#39;s </span>
<span class="sd">       own to_json function on a new line within the returned String. The </span>
<span class="sd">       returned String is not json comptable but if split by new line it is and </span>
<span class="sd">       is also comptable with the from_json method of TargetText.</span>
<span class="sd">    2. to_conll -- A CONLL formatted string where the format will be the </span>
<span class="sd">       following: `TOKEN#GOLD LABEL#PREDICTION 1# PREDICTION 2` Where each </span>
<span class="sd">       token and relevant labels are on separate new lines. The first line </span>
<span class="sd">       will always contain the following: `# {text_id: `value`}` where the </span>
<span class="sd">       text_id represents the `text_id` of this TargetText, this will allow </span>
<span class="sd">       the CONLL string to be uniquely identified back this TargetText </span>
<span class="sd">       object. Also each TargetText CONLL string will be seperated </span>
<span class="sd">       by a new line.</span>
<span class="sd">    3. to_conll_file -- Saves the TargetTextCollection to CONLL format. Useful</span>
<span class="sd">       for Sequence Labelling tasks.</span>
<span class="sd">    4. load_conll -- Loads the CONLL information into the collection.</span>
<span class="sd">    5. add -- Wrapper around __setitem__. Given as an argument a TargetText </span>
<span class="sd">       instance it will be added to the collection.</span>
<span class="sd">    6. to_json_file -- Saves the current TargetTextCollection to a json file </span>
<span class="sd">       which won&#39;t be strictly json but each line in the file will be and each </span>
<span class="sd">       line in the file can be loaded in from String via TargetText.from_json. </span>
<span class="sd">       Also the file can be reloaded into a TargetTextCollection using </span>
<span class="sd">       TargetTextCollection.load_json.</span>
<span class="sd">    7. tokenize -- This applies the TargetText.tokenize method across all </span>
<span class="sd">       of the TargetText instances within the collection.</span>
<span class="sd">    8. pos_text -- This applies the TargetText.pos_text method across all of </span>
<span class="sd">        the TargetText instances within the collection.</span>
<span class="sd">    9. sequence_labels -- This applies the TargetText.sequence_labels </span>
<span class="sd">       method across all of the TargetText instances within the collection.</span>
<span class="sd">    10. force_targets -- This applies the TargetText.force_targets method </span>
<span class="sd">        across all of the TargetText instances within the collection.</span>
<span class="sd">    11. exact_match_score -- Recall, Precision, and F1 score in a Tuple. </span>
<span class="sd">        All of these measures are based on exact span matching rather than the </span>
<span class="sd">        matching of the sequence label tags, this is due to the annotation spans </span>
<span class="sd">        not always matching tokenization therefore this removes the tokenization </span>
<span class="sd">        error that can come from the sequence label measures.</span>
<span class="sd">    12. samples_with_targets -- Returns all of the samples that have target </span>
<span class="sd">        spans as a TargetTextCollection. </span>
<span class="sd">    13. target_count -- A dictionary of target text as key and values as the  </span>
<span class="sd">        number of times the target text occurs in this TargetTextCollection</span>
<span class="sd">    14. one_sample_per_span -- This applies the TargetText.one_sample_per_span </span>
<span class="sd">        method across all of the TargetText instances within the collection to </span>
<span class="sd">        create a new collection with those new TargetText instances within it.</span>
<span class="sd">    15. number_targets -- Returns the total number of targets.</span>
<span class="sd">    16. number_categories -- Returns the total number of categories.</span>
<span class="sd">    17. category_count -- Returns a dictionary of categories as keys and </span>
<span class="sd">        values as the number of times the category occurs.</span>
<span class="sd">    18. target_sentiments -- A dictionary where the keys are target texts and </span>
<span class="sd">        the values are a List of sentiment values that have been associated to </span>
<span class="sd">        that target.</span>
<span class="sd">    19. dict_iter -- Returns an interator of all of the TargetText objects </span>
<span class="sd">        within the collection as dictionaries.</span>
<span class="sd">    20. unique_distinct_sentiments -- A set of the distinct sentiments within </span>
<span class="sd">        the collection. The length of the set represents the number of distinct </span>
<span class="sd">        sentiments within the collection.</span>
<span class="sd">    21. de_anonymise -- This will set the `anonymised` attribute to False </span>
<span class="sd">        from True and set the `text` key value to the value in the `text` </span>
<span class="sd">        key within the `text_dict` argument for each of the TargetTexts in </span>
<span class="sd">        the collection. If any Error is raised this collection will revert back</span>
<span class="sd">        fully to being anonymised.</span>
<span class="sd">    22. sanitize -- This applies the TargetText.sanitize function to all of </span>
<span class="sd">        the TargetText instances within this collection, affectively ensures </span>
<span class="sd">        that all of the instances follow the specified rules that TargetText </span>
<span class="sd">        instances should follow.</span>
<span class="sd">    23. in_order -- This returns True if all TargetText objects within the </span>
<span class="sd">        collection contains a list of targets that are in order of appearance </span>
<span class="sd">        within the text from left to right e.g. if the only TargetText in the </span>
<span class="sd">        collection contains two targets where the first target in the `targets`</span>
<span class="sd">        list is the first (left most) target in the text then this method would </span>
<span class="sd">        return True.</span>
<span class="sd">    24. re_order -- This will apply :py:meth:`target_extraction.data_types.TargetText.re_order`</span>
<span class="sd">        to each TargetText within the collection.</span>
<span class="sd">    25. add_unique_key -- Applies the following </span>
<span class="sd">        :py:meth:`target_extraction.data_types.TargetText.add_unique_key` </span>
<span class="sd">        to each TargetText within this collection</span>
<span class="sd">    26. key_difference -- Given this collection and another it will return all</span>
<span class="sd">        of the keys that the other collection contains which this does not.</span>
<span class="sd">    27. combine_data_on_id -- Given this collection and another it will add all</span>
<span class="sd">        of the data from the other collection into this collection based on the </span>
<span class="sd">        unique key given. </span>
<span class="sd">    28. one_sentiment_text -- Adds the `text_sentiment_key` to each TargetText </span>
<span class="sd">        within the collection where the value will represent the sentiment value </span>
<span class="sd">        for the text based on the `sentiment_key` values and `average_sentiment` </span>
<span class="sd">        determining how to handle multiple sentiments. This will allow text level </span>
<span class="sd">        classifiers to be trained on target/aspect/category data.</span>

<span class="sd">    Static Functions:</span>

<span class="sd">    1. from_json -- Returns a TargetTextCollection object given the json like </span>
<span class="sd">       String from to_json. For example the json string can be the return of </span>
<span class="sd">       TargetTextCollection.to_json.</span>
<span class="sd">    2. load_json -- Returns a TargetTextCollection based on each new line in </span>
<span class="sd">       the given json file.</span>
<span class="sd">    3. combine -- Returns a TargetTextCollection that is the combination of all </span>
<span class="sd">       of those given.</span>
<span class="sd">    4. same_data -- Given a List of TargetTextCollections it will return a list </span>
<span class="sd">       of tuples specifying the overlap between the collections based on the </span>
<span class="sd">       samples `text_id` and `text` key values. If it returns an empty list </span>
<span class="sd">       then there are no overlap between the collections. This is useful to </span>
<span class="sd">       find duplicates beyond the `text_id` as it checks the `text` value as well.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_texts</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="s1">&#39;TargetText&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                 <span class="n">metadata</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">anonymised</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        :param target_texts: A list of TargetText instances to add to the </span>
<span class="sd">                             collection.</span>
<span class="sd">        :param name: Name to call the collection, this is added to the metadata </span>
<span class="sd">                     automatically and overrides the name key value in the </span>
<span class="sd">                     metadata if exists.</span>
<span class="sd">        :param metadata: Any data that you would like to associate to this </span>
<span class="sd">                         TargetTextCollection.</span>
<span class="sd">        :param anonymised: Wether or not the TargetText objects should be loaded </span>
<span class="sd">                           in and anonymised, as well as stating whether or not </span>
<span class="sd">                           the whole collection should be anonymised when </span>
<span class="sd">                           loading in new TargetText objects.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_storage</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_anonymised</span> <span class="o">=</span> <span class="n">anonymised</span>
        <span class="k">if</span> <span class="n">target_texts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">target_text</span> <span class="ow">in</span> <span class="n">target_texts</span><span class="p">:</span>
                <span class="n">target_text</span><span class="o">.</span><span class="n">sanitize</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">target_text</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">metadata</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="n">metadata</span>
        
        <span class="k">if</span> <span class="n">anonymised</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">metadata</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">metadata</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;anonymised&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">anonymised</span>

        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">metadata</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">metadata</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        :returns: The name attribute.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>

    <span class="nd">@name</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_string</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Sets the value of the name attribute, and also updates the `name` key </span>
<span class="sd">        value in the `metadata` attribute.</span>

<span class="sd">        :param name_string: New name to give to the name attribute.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name_string</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">anonymised</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        :returns: True if the data within the TargetTextCollection has been </span>
<span class="sd">                  anonymised. Anonymised data means that there is no text </span>
<span class="sd">                  associated with any of the TargetText objects within the </span>
<span class="sd">                  collection, but all of the metadata is there.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_anonymised</span>

    <span class="nd">@anonymised</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">anonymised</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Sets whether or not `anonymised` attribute is True or False. This in </span>
<span class="sd">        effect performs the </span>
<span class="sd">        :py:meth:`target_extraction.data_types.TargetText.anonymised`</span>
<span class="sd">        on each TargetText object within the collection if True. When you </span>
<span class="sd">        want to set this to False you need to perform </span>
<span class="sd">        :py:meth:`target_extraction.data_types.TargetTextCollection.de_anonymise`.</span>

<span class="sd">        :param value: True for anonymised, else False. If True this will </span>
<span class="sd">                      enforce that all the TargetText objects do not have a</span>
<span class="sd">                      `text` key/value and the attribute `anonymised` is True.</span>
<span class="sd">        :raises AnonymisedError: If the TargetText object within the collection </span>
<span class="sd">                                 cannot be set to the </span>
<span class="sd">                                 `anonymised` value given. If this Error occurs </span>
<span class="sd">                                 then the object will have kept the original </span>
<span class="sd">                                 `anonymised` value.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">target_text</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">target_text</span><span class="o">.</span><span class="n">anonymised</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;anonymised&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_anonymised</span> <span class="o">=</span> <span class="n">value</span> 

<div class="viewcode-block" id="TargetTextCollection.add"><a class="viewcode-back" href="../../target_extraction.html#target_extraction.data_types.TargetTextCollection.add">[docs]</a>    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s1">&#39;TargetText&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Wrapper around set item. Instead of having to add the value the </span>
<span class="sd">        usual way of finding the instances &#39;text_id&#39; and setting this containers</span>
<span class="sd">        key to this value, it does this for you.</span>

<span class="sd">        e.g. performs self[value[&#39;text_id&#39;]] = value</span>

<span class="sd">        :param value: The TargetText instance to store in the collection. Will </span>
<span class="sd">                      anonymise the TargetText object if the collection&#39;s </span>
<span class="sd">                      anonymised attribute is True.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">value</span><span class="o">.</span><span class="n">anonymised</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">anonymised</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">value</span><span class="p">[</span><span class="s1">&#39;text_id&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">value</span></div>

<div class="viewcode-block" id="TargetTextCollection.to_json"><a class="viewcode-back" href="../../target_extraction.html#target_extraction.data_types.TargetTextCollection.to_json">[docs]</a>    <span class="k">def</span> <span class="nf">to_json</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Required as TargetTextCollection is not json serlizable due to the </span>
<span class="sd">        &#39;spans&#39; in the TargetText instances.</span>

<span class="sd">        :returns: The object as a list of dictionaries where each the TargetText</span>
<span class="sd">                  instances are dictionaries. It will also JSON serialize any </span>
<span class="sd">                  meta data as well.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">json_text</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">target_text_instance</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">json_text</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="n">target_text_instance</span><span class="p">:</span> <span class="n">TargetText</span>
            <span class="n">json_text</span> <span class="o">+=</span> <span class="n">target_text_instance</span><span class="o">.</span><span class="n">to_json</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">json_text</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
                <span class="n">json_text</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="n">json_text</span> <span class="o">+=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">({</span><span class="s1">&#39;metadata&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">})</span>
        <span class="k">return</span> <span class="n">json_text</span></div>

<div class="viewcode-block" id="TargetTextCollection.to_conll"><a class="viewcode-back" href="../../target_extraction.html#target_extraction.data_types.TargetTextCollection.to_conll">[docs]</a>    <span class="k">def</span> <span class="nf">to_conll</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gold_label_key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> 
                 <span class="n">prediction_key</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        This in affect performs the `to_conll` function for each TargetText </span>
<span class="sd">        within the collection and seperates each on the CONLL strings with a </span>
<span class="sd">        new line.</span>

<span class="sd">        :param gold_label: A key that contains a sequence of labels e.g. </span>
<span class="sd">                           [`B`, `I`, `O`]. This can come from the return </span>
<span class="sd">                           of the :py:meth:`sequence_labels`</span>
<span class="sd">        :param prediction_key: Key to the predicted labels of the `gold_label`. </span>
<span class="sd">                               Where the prediction key values is a list of a </span>
<span class="sd">                               list of predicted labels. Each list is therefore </span>
<span class="sd">                               a different model run hence creating the </span>
<span class="sd">                               `PREDICTION 1`, &#39;PREDICTION 2&#39; etc. Thus the </span>
<span class="sd">                               values of `prediction_key` must be of shape </span>
<span class="sd">                               (number runs, number tokens)</span>
<span class="sd">        :returns: A CONLL formatted string where the format will be the </span>
<span class="sd">                  following: `TOKEN#GOLD LABEL#PREDICTION 1# PREDICTION 2`</span>
<span class="sd">                  Where each token and relevant labels are on separate new </span>
<span class="sd">                  lines. The first line will always contain the following:</span>
<span class="sd">                  `# {text_id: `value`}` where the text_id represents the </span>
<span class="sd">                  `text_id` of this TargetText, this will allow the CONLL</span>
<span class="sd">                  string to be uniquely identified back this TargetText </span>
<span class="sd">                  object. Also each TargetText CONLL string will be seperated </span>
<span class="sd">                  by a new line.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">conll_string</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">for</span> <span class="n">target_text</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">target_conll</span> <span class="o">=</span> <span class="n">target_text</span><span class="o">.</span><span class="n">to_conll</span><span class="p">(</span><span class="n">gold_label_key</span><span class="o">=</span><span class="n">gold_label_key</span><span class="p">,</span> 
                                                <span class="n">prediction_key</span><span class="o">=</span><span class="n">prediction_key</span><span class="p">)</span>
            <span class="n">conll_string</span> <span class="o">+=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">target_conll</span><span class="si">}</span><span class="se">\n\n</span><span class="s1">&#39;</span>
        <span class="k">return</span> <span class="n">conll_string</span></div>

<div class="viewcode-block" id="TargetTextCollection.to_conll_file"><a class="viewcode-back" href="../../target_extraction.html#target_extraction.data_types.TargetTextCollection.to_conll_file">[docs]</a>    <span class="k">def</span> <span class="nf">to_conll_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conll_fp</span><span class="p">:</span> <span class="n">Path</span><span class="p">,</span> <span class="n">gold_label_key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> 
                      <span class="n">prediction_key</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Writes the ouput of `to_conll` to the `conll_fp` file.</span>

<span class="sd">        :param conll_fp: Write the CONLL string to this file path.</span>
<span class="sd">        :param gold_label: A key that contains a sequence of labels e.g. </span>
<span class="sd">                           [`B`, `I`, `O`]. This can come from the return </span>
<span class="sd">                           of the :py:meth:`sequence_labels`</span>
<span class="sd">        :param prediction_key: Key to the predicted labels of the `gold_label`. </span>
<span class="sd">                               Where the prediction key values is a list of a </span>
<span class="sd">                               list of predicted labels. Each list is therefore </span>
<span class="sd">                               a different model run hence creating the </span>
<span class="sd">                               `PREDICTION 1`, &#39;PREDICTION 2&#39; etc. Thus the </span>
<span class="sd">                               values of `prediction_key` must be of shape </span>
<span class="sd">                               (number runs, number tokens)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">conll_string</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_conll</span><span class="p">(</span><span class="n">gold_label_key</span><span class="o">=</span><span class="n">gold_label_key</span><span class="p">,</span> 
                                     <span class="n">prediction_key</span><span class="o">=</span><span class="n">prediction_key</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">conll_fp</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;w+&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">conll_file</span><span class="p">:</span>
            <span class="n">conll_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">conll_string</span><span class="p">)</span></div>

<div class="viewcode-block" id="TargetTextCollection.load_conll"><a class="viewcode-back" href="../../target_extraction.html#target_extraction.data_types.TargetTextCollection.load_conll">[docs]</a>    <span class="k">def</span> <span class="nf">load_conll</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conll_fp</span><span class="p">:</span> <span class="n">Path</span><span class="p">,</span> <span class="n">tokens_key</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;tokenized_text&#39;</span><span class="p">,</span> 
                   <span class="n">gold_label_key</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                   <span class="n">prediction_key</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        This takes the `conll_fp` and loads the CONLL data into the relevant </span>
<span class="sd">        TargetText samples in this collection using the TargetText `from_conll`</span>
<span class="sd">        function. The matching of TargetText with CONLL data is through the CONLL</span>
<span class="sd">        string containing `# {text_id: _id}` for each CONLL sentence/text.</span>

<span class="sd">        :param tokens_key: Key to save the CONLL tokens too, for the TargetText.</span>
<span class="sd">        :param gold_label_key: Key to save the gold labels too. Either </span>
<span class="sd">                               `gold_label_key` or `prediction_key` must not be </span>
<span class="sd">                               `None` or both not `None`, for the TargetText.</span>
<span class="sd">        :param prediction_key: Key to save the prediction labels too. The value </span>
<span class="sd">                               will be of shape (number runs, number tokens), </span>
<span class="sd">                               for the TargetText.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">def</span> <span class="nf">_line_divider</span><span class="p">(</span><span class="n">line</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span>
        
        <span class="k">with</span> <span class="n">conll_fp</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">conll_file</span><span class="p">:</span>

            <span class="c1"># Group into alternative divider / sentence chunks.</span>
            <span class="k">for</span> <span class="n">is_divider</span><span class="p">,</span> <span class="n">lines</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">conll_file</span><span class="p">,</span> <span class="n">_line_divider</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">is_divider</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">lines</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>
                <span class="n">_id_line</span> <span class="o">=</span> <span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">_id_line</span> <span class="o">=</span> <span class="n">_id_line</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="s1">&#39;#&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                <span class="n">text_id</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">_id_line</span><span class="p">)[</span><span class="s1">&#39;text_id&#39;</span><span class="p">]</span>
                <span class="c1"># Find relevant TargetText</span>
                <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span><span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span> <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">!=</span><span class="s1">&#39;&#39;</span><span class="p">]</span>
                <span class="n">conll_line</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">text_id</span><span class="p">]</span><span class="o">.</span><span class="n">from_conll</span><span class="p">(</span><span class="n">conll_line</span><span class="p">,</span> <span class="n">tokens_key</span><span class="o">=</span><span class="n">tokens_key</span><span class="p">,</span> 
                                         <span class="n">gold_label_key</span><span class="o">=</span><span class="n">gold_label_key</span><span class="p">,</span> 
                                         <span class="n">prediction_key</span><span class="o">=</span><span class="n">prediction_key</span><span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_metadata</span><span class="p">(</span><span class="n">json_iterable</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="kc">None</span><span class="p">],</span>
                                                             <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        :param json_iterable: An interable that generates a JSON string, of </span>
<span class="sd">                              which the last string contains the metadata if </span>
<span class="sd">                              it exists. </span>
<span class="sd">        :returns: The metadata for the collection being loaded, as a Tuple of </span>
<span class="sd">                  length 3 where the 3 items are: 1. The metadata, </span>
<span class="sd">                  2. The name of the collection, and 3. Whether it has been </span>
<span class="sd">                  anonymised. The first 2 by default are None and the 3 is </span>
<span class="sd">                  False by default. </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">metadata</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">name</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">anonymised</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">deque</span><span class="p">(</span><span class="n">json_iterable</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">():</span>
                <span class="n">json_line</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
                <span class="k">if</span> <span class="s1">&#39;metadata&#39;</span> <span class="ow">in</span> <span class="n">json_line</span><span class="p">:</span>
                    <span class="n">metadata</span> <span class="o">=</span> <span class="n">json_line</span><span class="p">[</span><span class="s1">&#39;metadata&#39;</span><span class="p">]</span>
                    <span class="k">if</span> <span class="s1">&#39;name&#39;</span> <span class="ow">in</span> <span class="n">metadata</span><span class="p">:</span>
                        <span class="n">name</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span>
                    <span class="k">if</span> <span class="s1">&#39;anonymised&#39;</span> <span class="ow">in</span> <span class="n">metadata</span><span class="p">:</span>
                        <span class="n">anonymised</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;anonymised&#39;</span><span class="p">]</span>  
        <span class="k">return</span> <span class="n">metadata</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">anonymised</span>

<div class="viewcode-block" id="TargetTextCollection.from_json"><a class="viewcode-back" href="../../target_extraction.html#target_extraction.data_types.TargetTextCollection.from_json">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_json</span><span class="p">(</span><span class="n">json_text</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">**</span><span class="n">target_text_collection_kwargs</span>
                  <span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;TargetTextCollection&#39;</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Required as the json text is expected to be the return from the </span>
<span class="sd">        self.to_json method. This string is not passable by a standard json </span>
<span class="sd">        decoder.</span>

<span class="sd">        :param json_text: This is expected to be a dictionary like object for </span>
<span class="sd">                          each new line in this text</span>
<span class="sd">        :param target_text_collection_kwargs: Key word arguments to give to </span>
<span class="sd">                                              the TargetTextCollection </span>
<span class="sd">                                              constructor.</span>
<span class="sd">        :returns: A TargetTextCollection based on each new line in the given </span>
<span class="sd">                  text to be passable by TargetText.from_json method.</span>
<span class="sd">        :raises AnonymisedError: If the `TargetText` object that it is loading </span>
<span class="sd">                                 is anonymised but the `target_text_collection_kwargs`</span>
<span class="sd">                                 argument contains `anonymised` False, as </span>
<span class="sd">                                 you cannot de-anonymised without performing </span>
<span class="sd">                                 the </span>
<span class="sd">                                 :py:meth:`target_extraction.data_types.TargetTextCollection.de_anonymised`.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        
       
        <span class="k">if</span> <span class="n">json_text</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">TargetTextCollection</span><span class="p">(</span><span class="o">**</span><span class="n">target_text_collection_kwargs</span><span class="p">)</span>

        <span class="n">target_text_instances</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">metadata</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">anonymised</span> <span class="o">=</span> <span class="n">TargetTextCollection</span><span class="o">.</span><span class="n">_get_metadata</span><span class="p">(</span><span class="n">json_text</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">json_text</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">):</span>
            <span class="n">json_line</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="s1">&#39;metadata&#39;</span> <span class="ow">in</span> <span class="n">json_line</span><span class="p">:</span>
                <span class="n">target_text_instance</span> <span class="o">=</span> <span class="n">TargetText</span><span class="o">.</span><span class="n">from_json</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">anonymised</span><span class="o">=</span><span class="n">anonymised</span><span class="p">)</span>
                <span class="n">target_text_instances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">target_text_instance</span><span class="p">)</span>
        <span class="c1"># Key word arguments over riding meta data</span>
        <span class="k">if</span> <span class="s1">&#39;name&#39;</span> <span class="ow">in</span> <span class="n">target_text_collection_kwargs</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">target_text_collection_kwargs</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s1">&#39;metadata&#39;</span> <span class="ow">in</span> <span class="n">target_text_collection_kwargs</span><span class="p">:</span>
            <span class="n">metadata</span> <span class="o">=</span> <span class="n">target_text_collection_kwargs</span><span class="p">[</span><span class="s1">&#39;metadata&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s1">&#39;anonymised&#39;</span> <span class="ow">in</span> <span class="n">target_text_collection_kwargs</span><span class="p">:</span>
            <span class="n">anonymised</span> <span class="o">=</span> <span class="n">target_text_collection_kwargs</span><span class="p">[</span><span class="s1">&#39;anonymised&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">TargetTextCollection</span><span class="p">(</span><span class="n">target_text_instances</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> 
                                    <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span> <span class="n">anonymised</span><span class="o">=</span><span class="n">anonymised</span><span class="p">)</span></div>

<div class="viewcode-block" id="TargetTextCollection.load_json"><a class="viewcode-back" href="../../target_extraction.html#target_extraction.data_types.TargetTextCollection.load_json">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">load_json</span><span class="p">(</span><span class="n">json_fp</span><span class="p">:</span> <span class="n">Path</span><span class="p">,</span> <span class="o">**</span><span class="n">target_text_collection_kwargs</span>
                  <span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;TargetTextCollection&#39;</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Allows loading a dataset from json. Where the json file is expected to </span>
<span class="sd">        be output from TargetTextCollection.to_json_file as the file will be </span>
<span class="sd">        a json String on each line generated from TargetText.to_json. This </span>
<span class="sd">        will also load any meta data that was stored within the TargetTextCollection.</span>

<span class="sd">        :param json_fp: File that contains json strings generated from </span>
<span class="sd">                        TargetTextCollection.to_json_file</span>
<span class="sd">        :param target_text_collection_kwargs: Key word arguments to give to </span>
<span class="sd">                                              the TargetTextCollection </span>
<span class="sd">                                              constructor. If there was</span>
<span class="sd">                                              any meta data stored within the </span>
<span class="sd">                                              loaded json then these key word </span>
<span class="sd">                                              arguments would over ride the </span>
<span class="sd">                                              meta data stored.</span>
<span class="sd">        :returns: A TargetTextCollection based on each new line in the given </span>
<span class="sd">                  json file, and the optional meta data on the last line.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">target_text_instances</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">with</span> <span class="n">json_fp</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">json_file</span><span class="p">:</span>
            <span class="n">metadata</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">anonymised</span> <span class="o">=</span> <span class="n">TargetTextCollection</span><span class="o">.</span><span class="n">_get_metadata</span><span class="p">(</span><span class="n">json_file</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">json_fp</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">json_file</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">json_file</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">():</span>
                    <span class="n">json_line</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
                    <span class="k">if</span> <span class="s1">&#39;metadata&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">json_line</span><span class="p">:</span>
                        <span class="n">target_text_instance</span> <span class="o">=</span> <span class="n">TargetText</span><span class="o">.</span><span class="n">from_json</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">anonymised</span><span class="p">)</span>
                        <span class="n">target_text_instances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">target_text_instance</span><span class="p">)</span>
                        
        <span class="c1"># Key word arguments over riding meta data</span>
        <span class="k">if</span> <span class="s1">&#39;name&#39;</span> <span class="ow">in</span> <span class="n">target_text_collection_kwargs</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">target_text_collection_kwargs</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s1">&#39;metadata&#39;</span> <span class="ow">in</span> <span class="n">target_text_collection_kwargs</span><span class="p">:</span>
            <span class="n">metadata</span> <span class="o">=</span> <span class="n">target_text_collection_kwargs</span><span class="p">[</span><span class="s1">&#39;metadata&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s1">&#39;anonymised&#39;</span> <span class="ow">in</span> <span class="n">target_text_collection_kwargs</span><span class="p">:</span>
            <span class="n">anonymised</span> <span class="o">=</span> <span class="n">target_text_collection_kwargs</span><span class="p">[</span><span class="s1">&#39;anonymised&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">TargetTextCollection</span><span class="p">(</span><span class="n">target_text_instances</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> 
                                    <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span> <span class="n">anonymised</span><span class="o">=</span><span class="n">anonymised</span><span class="p">)</span></div>

<div class="viewcode-block" id="TargetTextCollection.to_json_file"><a class="viewcode-back" href="../../target_extraction.html#target_extraction.data_types.TargetTextCollection.to_json_file">[docs]</a>    <span class="k">def</span> <span class="nf">to_json_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">json_fp</span><span class="p">:</span> <span class="n">Path</span><span class="p">,</span> 
                     <span class="n">include_metadata</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Saves the current TargetTextCollection to a json file which won&#39;t be </span>
<span class="sd">        strictly json but each line in the file will be and each line in the </span>
<span class="sd">        file can be loaded in from String via TargetText.from_json. Also the </span>
<span class="sd">        file can be reloaded into a TargetTextCollection using </span>
<span class="sd">        TargetTextCollection.load_json.</span>

<span class="sd">        :param json_fp: File path to the json file to save the current data to.</span>
<span class="sd">        :param include_metadata: Whether or not to include the metadata when </span>
<span class="sd">                                 writing to file.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">with</span> <span class="n">json_fp</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;w+&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">json_file</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">target_text_instance</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                <span class="n">target_text_instance</span><span class="p">:</span> <span class="n">TargetText</span>
                <span class="n">target_text_string</span> <span class="o">=</span> <span class="n">target_text_instance</span><span class="o">.</span><span class="n">to_json</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">index</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">target_text_string</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\n</span><span class="si">{</span><span class="n">target_text_string</span><span class="si">}</span><span class="s1">&#39;</span>
                <span class="n">json_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">target_text_string</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">include_metadata</span><span class="p">:</span>
                <span class="n">metadata_to_write</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;metadata&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">}</span>
                <span class="n">json_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="se">\n</span><span class="si">{</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">metadata_to_write</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="TargetTextCollection.tokenize"><a class="viewcode-back" href="../../target_extraction.html#target_extraction.data_types.TargetTextCollection.tokenize">[docs]</a>    <span class="k">def</span> <span class="nf">tokenize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokenizer</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">str</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        This applies the TargetText.tokenize method across all of </span>
<span class="sd">        the TargetText instances within the collection.</span>

<span class="sd">        For a set of tokenizers that are definetly comptable see </span>
<span class="sd">        target_extraction.tokenizers module.</span>

<span class="sd">        Ensures that the tokenization is character preserving.</span>

<span class="sd">        :param tokenizer: The tokenizer to use tokenize the text for each </span>
<span class="sd">                          TargetText instance in the current collection</span>
<span class="sd">        :raises TypeError: If the tokenizer given does not return a List of </span>
<span class="sd">                           Strings.</span>
<span class="sd">        :raises ValueError: This is raised if any of the TargetText instances </span>
<span class="sd">                            in the collection contain an empty string.</span>
<span class="sd">        :raises ValueError: If the tokenization is not character preserving.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">target_text_instance</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">target_text_instance</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">tokenizer</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">target_text_instance</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">tokenizer</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="TargetTextCollection.pos_text"><a class="viewcode-back" href="../../target_extraction.html#target_extraction.data_types.TargetTextCollection.pos_text">[docs]</a>    <span class="k">def</span> <span class="nf">pos_text</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tagger</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">str</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        This applies the TargetText.pos_text method across all of </span>
<span class="sd">        the TargetText instances within the collection.</span>

<span class="sd">        For a set of pos taggers that are definetly comptable see </span>
<span class="sd">        target_extraction.pos_taggers module.</span>

<span class="sd">        :param tagger: POS tagger.</span>
<span class="sd">        :raises TypeError: If the POS tagger given does not return a List of </span>
<span class="sd">                           Strings.</span>
<span class="sd">        :raises ValueError: This is raised if any of the TargetText instances </span>
<span class="sd">                            in the collection contain an empty string.</span>
<span class="sd">        :raises ValueError: If the Target Text instance has not been tokenized.</span>
<span class="sd">        :raises ValueError: If the number of pos tags for a Target Text instance</span>
<span class="sd">                            does not have the same number of tokens that has </span>
<span class="sd">                            been generated by the tokenizer function.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">target_text_instance</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">target_text_instance</span><span class="o">.</span><span class="n">pos_text</span><span class="p">(</span><span class="n">tagger</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">target_text_instance</span><span class="o">.</span><span class="n">pos_text</span><span class="p">(</span><span class="n">tagger</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="TargetTextCollection.force_targets"><a class="viewcode-back" href="../../target_extraction.html#target_extraction.data_types.TargetTextCollection.force_targets">[docs]</a>    <span class="k">def</span> <span class="nf">force_targets</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        This applies the TargetText.force_targets method across all of the </span>
<span class="sd">        TargetText instances within the collection.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">target_text_instance</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">target_text_instance</span><span class="o">.</span><span class="n">force_targets</span><span class="p">()</span></div>

<div class="viewcode-block" id="TargetTextCollection.sequence_labels"><a class="viewcode-back" href="../../target_extraction.html#target_extraction.data_types.TargetTextCollection.sequence_labels">[docs]</a>    <span class="k">def</span> <span class="nf">sequence_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">return_errors</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 
                        <span class="o">**</span><span class="n">target_sequence_label_kwargs</span>
                        <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="s1">&#39;TargetText&#39;</span><span class="p">]:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        This applies the TargetText.sequence_labels method across all of </span>
<span class="sd">        the TargetText instances within the collection.</span>

<span class="sd">        :param return_errors: Returns TargetText objects that have caused </span>
<span class="sd">                              the ValueError to be raised.</span>
<span class="sd">        :param target_sequence_label_kwargs: Any Keyword arguments to give to </span>
<span class="sd">                                             the TargetText `sequence_labels`</span>
<span class="sd">                                             function.</span>
<span class="sd">        :returns: A list of TargetText objects that have caused the ValueError </span>
<span class="sd">                  to be raised if `return_errors` is True else an empty list </span>
<span class="sd">                  will be returned. </span>
<span class="sd">        :raises KeyError: If the current TargetText has not been tokenized.</span>
<span class="sd">        :raises ValueError: If two targets overlap the same token(s) e.g </span>
<span class="sd">                            `Laptop cover was great` if `Laptop` and </span>
<span class="sd">                            `Laptop cover` are two seperate targets this should </span>
<span class="sd">                            riase a ValueError as a token should only be </span>
<span class="sd">                            associated to one target.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">errored_targets</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">target_text_instance</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">return_errors</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">target_text_instance</span><span class="o">.</span><span class="n">sequence_labels</span><span class="p">(</span><span class="o">**</span><span class="n">target_sequence_label_kwargs</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="n">errored_targets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">target_text_instance</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">target_text_instance</span><span class="o">.</span><span class="n">sequence_labels</span><span class="p">(</span><span class="o">**</span><span class="n">target_sequence_label_kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">errored_targets</span></div>


<div class="viewcode-block" id="TargetTextCollection.exact_match_score"><a class="viewcode-back" href="../../target_extraction.html#target_extraction.data_types.TargetTextCollection.exact_match_score">[docs]</a>    <span class="k">def</span> <span class="nf">exact_match_score</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
                          <span class="n">predicted_sequence_key</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;predicted_sequence_labels&#39;</span>
                          <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> 
                                     <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Span</span><span class="p">]]]]:</span>
        <span class="sd">&#39;&#39;&#39;        </span>
<span class="sd">        Just for clarification we use the sequence label tags to find the </span>
<span class="sd">        predicted spans. However even if you have a perfect sequence label </span>
<span class="sd">        score does not mean you will have a perfect extact span score </span>
<span class="sd">        as the tokenizer used for the sequence labelling might not align </span>
<span class="sd">        perfectly with the annotated spans.</span>

<span class="sd">        The False Positive mistakes, False Negative mistakes, and correct</span>
<span class="sd">        True Positive Dictionary keys are those names with the values neing a </span>
<span class="sd">        List of Tuples where the Tuple is made up of the TargetText instance ID </span>
<span class="sd">        and the Span that was incorrect (FP) or not tagged (FN) or correct (TP).</span>
<span class="sd">        Example of this is as follows:</span>
<span class="sd">        {`FP`: [(&#39;1&#39;, Span(0, 4))], &#39;FN&#39;: [], &#39;TP&#39;: []}</span>

<span class="sd">        :param predicted_sequence_key: Key of the predicted sequence labels </span>
<span class="sd">                                       within this TargetText instance.</span>
<span class="sd">        :returns: Recall, Precision, and F1 score, False Positive mistakes, </span>
<span class="sd">                  False Negative mistakes, and correct True Positives in a </span>
<span class="sd">                  Dict. All of these measures are based on exact span matching </span>
<span class="sd">                  rather than the matching of the sequence label tags, </span>
<span class="sd">                  this is due to the annotation spans not always matching </span>
<span class="sd">                  tokenization therefore this removes the tokenization </span>
<span class="sd">                  error that can come from the sequence label measures.</span>
<span class="sd">        :raises KeyError: If there are no predicted sequence label key </span>
<span class="sd">                          within this TargetText.</span>
<span class="sd">        :raises ValueError: If the predicted or true spans contain multiple </span>
<span class="sd">                            spans that have the same span e.g. </span>
<span class="sd">                            [Span(4, 15), Span(4, 15)]</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># tp = True Positive count</span>
        <span class="n">tp</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">num_pred_true</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">num_actually_true</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">fp_mistakes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Span</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">fn_mistakes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Span</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">correct_tp</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Span</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">target_text_index</span><span class="p">,</span> <span class="n">target_text_instance</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">target_text_index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">keys_to_check</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;spans&#39;</span><span class="p">,</span> 
                                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">predicted_sequence_key</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys_to_check</span><span class="p">:</span>
                    <span class="n">target_text_instance</span><span class="o">.</span><span class="n">_key_error</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="n">predicted_spans</span> <span class="o">=</span> <span class="n">target_text_instance</span><span class="o">.</span><span class="n">get_sequence_spans</span><span class="p">(</span><span class="n">predicted_sequence_key</span><span class="p">)</span>
            <span class="c1"># Add to the number of predicted true and actually true</span>
            <span class="n">predicted_spans</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Span</span><span class="p">]</span>
            <span class="n">num_pred_true</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">predicted_spans</span><span class="p">)</span>

            <span class="n">true_spans</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Span</span><span class="p">]</span> <span class="o">=</span> <span class="n">target_text_instance</span><span class="p">[</span><span class="s1">&#39;spans&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">true_spans</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">true_spans</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">num_actually_true</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">true_spans</span><span class="p">)</span>
            
            <span class="c1"># This should be impossible to get to</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">predicted_spans</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">predicted_spans</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Predicted spans </span><span class="si">{</span><span class="n">predicted_spans</span><span class="si">}</span><span class="s1"> contain&#39;</span>
                                 <span class="sa">f</span><span class="s1">&#39; multiple of the same predicted span. &#39;</span>
                                 <span class="sa">f</span><span class="s1">&#39;TargetText: </span><span class="si">{</span><span class="n">target_text_instance</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="c1"># This is possible</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">true_spans</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">true_spans</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;True spans </span><span class="si">{</span><span class="n">true_spans</span><span class="si">}</span><span class="s1"> contain&#39;</span>
                                 <span class="sa">f</span><span class="s1">&#39; multiple of the same true span. &#39;</span>
                                 <span class="sa">f</span><span class="s1">&#39;TargetText: </span><span class="si">{</span><span class="n">target_text_instance</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            
            <span class="n">text_id</span> <span class="o">=</span> <span class="n">target_text_instance</span><span class="p">[</span><span class="s1">&#39;text_id&#39;</span><span class="p">]</span>
            <span class="n">true_spans</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">true_spans</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">predicted_span</span> <span class="ow">in</span> <span class="n">predicted_spans</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">predicted_span</span> <span class="ow">in</span> <span class="n">true_spans</span><span class="p">:</span>
                    <span class="n">tp</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">correct_tp</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">text_id</span><span class="p">,</span> <span class="n">predicted_span</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">fp_mistakes</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">text_id</span><span class="p">,</span> <span class="n">predicted_span</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">true_span</span> <span class="ow">in</span> <span class="n">true_spans</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">true_span</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">predicted_spans</span><span class="p">:</span>
                    <span class="n">fn_mistakes</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">text_id</span><span class="p">,</span> <span class="n">true_span</span><span class="p">))</span>
        
        <span class="n">error_analysis_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;FP&#39;</span><span class="p">:</span> <span class="n">fp_mistakes</span><span class="p">,</span> <span class="s1">&#39;FN&#39;</span><span class="p">:</span> <span class="n">fn_mistakes</span><span class="p">,</span> 
                               <span class="s1">&#39;TP&#39;</span><span class="p">:</span> <span class="n">correct_tp</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">tp</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">error_analysis_dict</span>
        <span class="n">recall</span> <span class="o">=</span> <span class="n">tp</span> <span class="o">/</span> <span class="n">num_actually_true</span>
        <span class="n">precision</span> <span class="o">=</span> <span class="n">tp</span> <span class="o">/</span> <span class="n">num_pred_true</span>
        <span class="n">f1</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">precision</span> <span class="o">*</span> <span class="n">recall</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">precision</span> <span class="o">+</span> <span class="n">recall</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">recall</span><span class="p">,</span> <span class="n">precision</span><span class="p">,</span> <span class="n">f1</span><span class="p">,</span> <span class="n">error_analysis_dict</span> </div>

<div class="viewcode-block" id="TargetTextCollection.samples_with_targets"><a class="viewcode-back" href="../../target_extraction.html#target_extraction.data_types.TargetTextCollection.samples_with_targets">[docs]</a>    <span class="k">def</span> <span class="nf">samples_with_targets</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;TargetTextCollection&#39;</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        :returns: All of the samples that have targets as a </span>
<span class="sd">                  TargetTextCollection for this TargetTextCollection.</span>
<span class="sd">        :raises KeyError: If either `spans` or `targets` does not exist in </span>
<span class="sd">                          one or more of the TargetText instances within this </span>
<span class="sd">                          collection. These key&#39;s are protected keys thus they</span>
<span class="sd">                          should always exist but this is just a warning if </span>
<span class="sd">                          you have got around the protected keys.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">sub_collection</span> <span class="o">=</span> <span class="n">TargetTextCollection</span><span class="p">()</span>
        <span class="n">sub_collection</span><span class="o">.</span><span class="n">anonymised</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">anonymised</span>
        <span class="k">for</span> <span class="n">target_text</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">target_text</span><span class="p">[</span><span class="s1">&#39;spans&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">target_text</span><span class="p">[</span><span class="s1">&#39;targets&#39;</span><span class="p">]:</span>
                <span class="n">sub_collection</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">target_text</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sub_collection</span></div>

<div class="viewcode-block" id="TargetTextCollection.target_count"><a class="viewcode-back" href="../../target_extraction.html#target_extraction.data_types.TargetTextCollection.target_count">[docs]</a>    <span class="k">def</span> <span class="nf">target_count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lower</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 
                     <span class="n">target_key</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;targets&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        :Note: The target can not exist e.g. be a `None` target as the target </span>
<span class="sd">               can be combined with the category like in the SemEval 2016 </span>
<span class="sd">               Restaurant dataset. In these case we do not include these </span>
<span class="sd">               in the target_count.</span>
<span class="sd">        :param lower: Whether or not to lower the target text.</span>
<span class="sd">        :param target_key: The key in each TargetText sample that contains the </span>
<span class="sd">                           list of target words.</span>
<span class="sd">        :returns: A dictionary of target text as key and values as the number </span>
<span class="sd">                  of times the target text occurs in this TargetTextCollection</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">target_count</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">target_dict</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">target_dict</span><span class="p">[</span><span class="n">target_key</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">target_dict</span><span class="p">[</span><span class="n">target_key</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">target</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="n">lower</span><span class="p">:</span>
                        <span class="n">target</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
                    <span class="n">target_count</span><span class="o">.</span><span class="n">update</span><span class="p">([</span><span class="n">target</span><span class="p">])</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">target_count</span><span class="p">)</span></div>

<div class="viewcode-block" id="TargetTextCollection.target_sentiments"><a class="viewcode-back" href="../../target_extraction.html#target_extraction.data_types.TargetTextCollection.target_sentiments">[docs]</a>    <span class="k">def</span> <span class="nf">target_sentiments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lower</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 
                          <span class="n">unique_sentiment</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
                          <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        :Note: The target can not exist e.g. be a `None` target as the target </span>
<span class="sd">               can be combined with the category like in the SemEval 2016 </span>
<span class="sd">               Restaurant dataset. In these case we do not include these </span>
<span class="sd">               in the target_count.</span>
<span class="sd">        :param lower: Whether or not to lower the target text.</span>
<span class="sd">        :param unique_sentiment: Whether or not the return is a dictionary  </span>
<span class="sd">                                 whose values are a List of Strings or if </span>
<span class="sd">                                 True a Set of Strings.</span>
<span class="sd">        :returns: A dictionary where the keys are target texts and the values </span>
<span class="sd">                  are a List of sentiment values that have been associated to </span>
<span class="sd">                  that target. The sentiment value can occur more than once </span>
<span class="sd">                  indicating the number of times that target has been associated </span>
<span class="sd">                  with that sentiment unless unique_sentiment is True then </span>
<span class="sd">                  instead of a List of sentiment values a Set is used instead.</span>
<span class="sd">        :Explanation: If the target `camera` has occured with the sentiment </span>
<span class="sd">                      `positive` twice and `negative` once then it will return </span>
<span class="sd">                      {`camera`: [`positive`, `positive`, `negative`]}. However</span>
<span class="sd">                      if `unique_sentiment` is True then it will return:</span>
<span class="sd">                      {`camera`: {`positive`, `negative`}}.</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">target_sentiment_values</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">unique_sentiment</span><span class="p">:</span>
            <span class="n">target_sentiment_values</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">target_dict</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">target_dict</span><span class="p">[</span><span class="s1">&#39;targets&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">target_dict</span><span class="p">[</span><span class="s1">&#39;target_sentiments&#39;</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">target</span><span class="p">,</span> <span class="n">sentiment</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">target_dict</span><span class="p">[</span><span class="s1">&#39;targets&#39;</span><span class="p">],</span> 
                                             <span class="n">target_dict</span><span class="p">[</span><span class="s1">&#39;target_sentiments&#39;</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="n">target</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="n">lower</span><span class="p">:</span>
                        <span class="n">target</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">unique_sentiment</span><span class="p">:</span>
                        <span class="n">target_sentiment_values</span><span class="p">[</span><span class="n">target</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">sentiment</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">target_sentiment_values</span><span class="p">[</span><span class="n">target</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sentiment</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">target_sentiment_values</span><span class="p">)</span></div>

<div class="viewcode-block" id="TargetTextCollection.number_targets"><a class="viewcode-back" href="../../target_extraction.html#target_extraction.data_types.TargetTextCollection.number_targets">[docs]</a>    <span class="k">def</span> <span class="nf">number_targets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">incl_none_targets</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        :param incl_none_targets: Whether to include targets that are `None`</span>
<span class="sd">                                  and are therefore associated to the categories </span>
<span class="sd">                                  in the count.</span>
<span class="sd">        :returns: The total number of targets in the collection. </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">target_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">target_dict</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">target_dict</span><span class="p">[</span><span class="s1">&#39;targets&#39;</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">target_dict</span><span class="p">[</span><span class="s1">&#39;targets&#39;</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">incl_none_targets</span> <span class="ow">and</span> <span class="n">target</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">target_count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">target_count</span></div>

<div class="viewcode-block" id="TargetTextCollection.number_categories"><a class="viewcode-back" href="../../target_extraction.html#target_extraction.data_types.TargetTextCollection.number_categories">[docs]</a>    <span class="k">def</span> <span class="nf">number_categories</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        :returns: The total number of categories in the collection</span>
<span class="sd">        :raises ValueError: If one of the category values in the list is of </span>
<span class="sd">                            value None</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">category_count</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="p">())</span></div>

<div class="viewcode-block" id="TargetTextCollection.category_count"><a class="viewcode-back" href="../../target_extraction.html#target_extraction.data_types.TargetTextCollection.category_count">[docs]</a>    <span class="k">def</span> <span class="nf">category_count</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        :returns: A dictionary of categories as keys and values as the number </span>
<span class="sd">                  of times the category occurs in this TargetTextCollection</span>
<span class="sd">        :raises ValueError: If any category has the value of None.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">categories_count</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">target_dict</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">target_dict</span><span class="p">[</span><span class="s1">&#39;categories&#39;</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">category</span> <span class="ow">in</span> <span class="n">target_dict</span><span class="p">[</span><span class="s1">&#39;categories&#39;</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">category</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;One of the category value is None, &#39;</span>
                                         <span class="sa">f</span><span class="s1">&#39;within </span><span class="si">{</span><span class="n">target_dict</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="n">categories_count</span><span class="o">.</span><span class="n">update</span><span class="p">([</span><span class="n">category</span><span class="p">])</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">categories_count</span><span class="p">)</span></div>

<div class="viewcode-block" id="TargetTextCollection.one_sample_per_span"><a class="viewcode-back" href="../../target_extraction.html#target_extraction.data_types.TargetTextCollection.one_sample_per_span">[docs]</a>    <span class="k">def</span> <span class="nf">one_sample_per_span</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">remove_empty</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
                            <span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;TargetTextCollection&#39;</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        This applies the TargetText.one_sample_per_span method across all of the </span>
<span class="sd">        TargetText instances within the collection to create a new collection </span>
<span class="sd">        with those new TargetText instances within it.</span>
<span class="sd">        </span>
<span class="sd">        :param remove_empty: If the TargetText instance contains any None </span>
<span class="sd">                             targets then these will be removed along with </span>
<span class="sd">                             their respective Spans.</span>
<span class="sd">        :returns: A new TargetTextCollection that has samples that come </span>
<span class="sd">                  from this collection but has had the </span>
<span class="sd">                  TargetText.one_sample_per_span method applied to it.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        
        <span class="n">new_collection</span> <span class="o">=</span> <span class="n">TargetTextCollection</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">target_text</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">new_collection</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">target_text</span><span class="o">.</span><span class="n">one_sample_per_span</span><span class="p">(</span><span class="n">remove_empty</span><span class="o">=</span><span class="n">remove_empty</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">new_collection</span></div>

<div class="viewcode-block" id="TargetTextCollection.dict_iterator"><a class="viewcode-back" href="../../target_extraction.html#target_extraction.data_types.TargetTextCollection.dict_iterator">[docs]</a>    <span class="k">def</span> <span class="nf">dict_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        :returns: An interator of all of the TargetText objects </span>
<span class="sd">                  within the collection as dictionaries.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">target_text</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">target_text</span><span class="p">:</span> <span class="n">TargetText</span>
            <span class="k">yield</span> <span class="nb">dict</span><span class="p">(</span><span class="n">target_text</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="TargetTextCollection.unique_distinct_sentiments"><a class="viewcode-back" href="../../target_extraction.html#target_extraction.data_types.TargetTextCollection.unique_distinct_sentiments">[docs]</a>    <span class="k">def</span> <span class="nf">unique_distinct_sentiments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
                                   <span class="n">sentiment_key</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;target_sentiments&#39;</span>
                                   <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        :param sentiment_key: The key that represents the sentiment value </span>
<span class="sd">                              for each TargetText object </span>
<span class="sd">        :returns: A set of the distinct sentiments within the collection. </span>
<span class="sd">                  The length of the set represents the number of distinct </span>
<span class="sd">                  sentiments within the collection.</span>
<span class="sd">        :raises TypeError: If the value in the sentiment_key is not of type list</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">unique_ds</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">target_object</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">sentiment_value</span> <span class="o">=</span> <span class="n">target_object</span><span class="p">[</span><span class="n">sentiment_key</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sentiment_value</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;The sentiment key </span><span class="si">{</span><span class="n">sentiment_key</span><span class="si">}</span><span class="s1"> contains a&#39;</span>
                                <span class="sa">f</span><span class="s1">&#39; value that is not of type List: &#39;</span>
                                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">sentiment_value</span><span class="si">}</span><span class="s1">. TargetText object: &#39;</span>
                                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">target_object</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">unique_ds</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">sentiment_value</span><span class="p">)))</span>
        <span class="c1"># Need to remove 0&#39;s which come about because an empty list is of </span>
        <span class="c1"># length 0</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">unique_ds</span><span class="p">:</span>
            <span class="n">unique_ds</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">unique_ds</span></div>

<div class="viewcode-block" id="TargetTextCollection.de_anonymise"><a class="viewcode-back" href="../../target_extraction.html#target_extraction.data_types.TargetTextCollection.de_anonymise">[docs]</a>    <span class="k">def</span> <span class="nf">de_anonymise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text_dicts</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        This will set the `anonymised` attribute to False </span>
<span class="sd">        from True and set the `text` key value to the value in the `text` </span>
<span class="sd">        key within the `text_dict` argument for each of the TargetTexts in </span>
<span class="sd">        the collection. If any Error is raised this collection will revert back</span>
<span class="sd">        fully to being anonymised.</span>

<span class="sd">        :param text_dicts: An iterable of dictionaries that contain the following </span>
<span class="sd">                           two keys: 1. `text` and 2. `text_id` where </span>
<span class="sd">                           the `text_id` has to be a key within the current </span>
<span class="sd">                           collection. The `text` associated to that id will </span>
<span class="sd">                           become that TargetText object&#39;s text value.</span>
<span class="sd">        :raises ValueError: If the length of the `text_dicts` does not match </span>
<span class="sd">                            that of the collection.</span>
<span class="sd">        :raises KeyError: If any of the `text_id`s in the `text_dicts` do not </span>
<span class="sd">                          match those within this collection.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">self_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">text_dict_len</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">text_dict</span> <span class="ow">in</span> <span class="n">text_dicts</span><span class="p">:</span>
                <span class="n">text_dict_id</span> <span class="o">=</span> <span class="n">text_dict</span><span class="p">[</span><span class="s1">&#39;text_id&#39;</span><span class="p">]</span>
                <span class="n">text_dict_len</span><span class="p">[</span><span class="n">text_dict_id</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">text_dict_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The key </span><span class="si">{</span><span class="n">text_dict_id</span><span class="si">}</span><span class="s2"> from `text_dicts`&quot;</span>
                                   <span class="sa">f</span><span class="s2">&quot; is not in this collection.&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">text_dict_id</span><span class="p">]</span><span class="o">.</span><span class="n">de_anonymise</span><span class="p">(</span><span class="n">text_dict</span><span class="p">)</span>
            <span class="n">text_dict_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">text_dict_len</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">self_len</span> <span class="o">!=</span> <span class="n">text_dict_len</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;The length of collection </span><span class="si">{</span><span class="n">self_len</span><span class="si">}</span><span class="s1"> is not &#39;</span>
                                 <span class="s1">&#39;equal to the length of the `text_dicts` &#39;</span>
                                 <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">text_dict_len</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="c1"># Cleans up after the exception as we have to preserve the case </span>
            <span class="c1"># that it is still anonymised</span>
            <span class="k">for</span> <span class="n">target_text</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">target_text</span><span class="o">.</span><span class="n">anonymised</span><span class="p">:</span>
                    <span class="n">target_text</span><span class="o">.</span><span class="n">anonymised</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">raise</span> <span class="n">e</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">anonymised</span> <span class="o">=</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="TargetTextCollection.sanitize"><a class="viewcode-back" href="../../target_extraction.html#target_extraction.data_types.TargetTextCollection.sanitize">[docs]</a>    <span class="k">def</span> <span class="nf">sanitize</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        This applies the TargetText.sanitize function to all of </span>
<span class="sd">        the TargetText instances within this collection, affectively ensures </span>
<span class="sd">        that all of the instances follow the specified rules that TargetText </span>
<span class="sd">        instances should follow.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">for</span> <span class="n">target_text</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">target_text</span><span class="o">.</span><span class="n">sanitize</span><span class="p">()</span></div>

<div class="viewcode-block" id="TargetTextCollection.in_order"><a class="viewcode-back" href="../../target_extraction.html#target_extraction.data_types.TargetTextCollection.in_order">[docs]</a>    <span class="k">def</span> <span class="nf">in_order</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        This returns True if all TargetText objects within the </span>
<span class="sd">        collection contains a list of targets that are in order of appearance </span>
<span class="sd">        within the text from left to right e.g. if the only TargetText in the </span>
<span class="sd">        collection contains two targets where the first target in the `targets`</span>
<span class="sd">        list is the first (left most) target in the text then this method would </span>
<span class="sd">        return True.</span>

<span class="sd">        :returns: True if all the `targets` within all the TargetText objects </span>
<span class="sd">                  in this collection are in sequential left to right order </span>
<span class="sd">                  within the text.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">target_text</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">target_text</span><span class="o">.</span><span class="n">in_order</span><span class="p">():</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span></div>
    
<div class="viewcode-block" id="TargetTextCollection.re_order"><a class="viewcode-back" href="../../target_extraction.html#target_extraction.data_types.TargetTextCollection.re_order">[docs]</a>    <span class="k">def</span> <span class="nf">re_order</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys_not_to_order</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        This will apply :py:meth:`target_extraction.data_types.TargetText.re_order`</span>
<span class="sd">        to each TargetText within the collection.</span>

<span class="sd">        :param keys_not_to_order: Any keys within the TargetTexts that do not </span>
<span class="sd">                                  need re-ordering</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># This takes into account the rollback problem where an error occurs </span>
        <span class="c1"># halfway through performing the function and half the collection has </span>
        <span class="c1"># been re-ordered where as the other half has not. This will bring it </span>
        <span class="c1"># back into a stable state.</span>
        <span class="n">self_copy</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">target_text</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="n">target_text</span><span class="o">.</span><span class="n">re_order</span><span class="p">(</span><span class="n">keys_not_to_order</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_storage</span> <span class="o">=</span> <span class="n">self_copy</span>
            <span class="k">raise</span> <span class="n">e</span></div>

<div class="viewcode-block" id="TargetTextCollection.add_unique_key"><a class="viewcode-back" href="../../target_extraction.html#target_extraction.data_types.TargetTextCollection.add_unique_key">[docs]</a>    <span class="k">def</span> <span class="nf">add_unique_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">id_key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">id_key_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> 
                       <span class="n">id_delimiter</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;::&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Applies the following </span>
<span class="sd">        :py:meth:`target_extraction.data_types.TargetText.add_unique_key` </span>
<span class="sd">        to each TargetText within this collection</span>
<span class="sd">        </span>
<span class="sd">        :param id_key: The name of the key within this TargetText that requires </span>
<span class="sd">                       unique ids that will be stored in `id_key_name`.</span>
<span class="sd">        :param id_key_name: The name of the key to associate to these new </span>
<span class="sd">                            unique ids.</span>
<span class="sd">        :param id_delimiter: The delimiter to seperate the `text_id` and the </span>
<span class="sd">                             index of the `id_key` that is being represented </span>
<span class="sd">                             by this unique id.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">value</span><span class="o">.</span><span class="n">add_unique_key</span><span class="p">(</span><span class="n">id_key</span><span class="p">,</span> <span class="n">id_key_name</span><span class="p">,</span> <span class="n">id_delimiter</span><span class="o">=</span><span class="n">id_delimiter</span><span class="p">)</span></div>

<div class="viewcode-block" id="TargetTextCollection.key_difference"><a class="viewcode-back" href="../../target_extraction.html#target_extraction.data_types.TargetTextCollection.key_difference">[docs]</a>    <span class="k">def</span> <span class="nf">key_difference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_collection</span><span class="p">:</span> <span class="s1">&#39;TargetTextCollection&#39;</span>
                       <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        :param other_collection: The collection that is being compared to this.</span>
<span class="sd">        :returns: A list of keys that represent all of the keys that are in the </span>
<span class="sd">                  other (compared) collection and not in this collection.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">this_keys</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>
        <span class="n">other_keys</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">other_collection</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">other_keys</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">this_keys</span><span class="p">))</span></div>

<div class="viewcode-block" id="TargetTextCollection.combine_data_on_id"><a class="viewcode-back" href="../../target_extraction.html#target_extraction.data_types.TargetTextCollection.combine_data_on_id">[docs]</a>    <span class="k">def</span> <span class="nf">combine_data_on_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_collection</span><span class="p">:</span> <span class="s1">&#39;TargetTextCollection&#39;</span><span class="p">,</span> 
                           <span class="n">id_key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">data_keys</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> 
                           <span class="n">raise_on_overwrite</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                           <span class="n">check_same_ids</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        :param other_collection: The collection that contains the data </span>
<span class="sd">                                 that is to be copied to this collection.</span>
<span class="sd">        :param id_key: The key that indicates in each TargetText within </span>
<span class="sd">                       this and the `other_collection` how the values are </span>
<span class="sd">                       to be copied from the `other_collection` to this </span>
<span class="sd">                       collection.</span>
<span class="sd">        :param data_keys: The keys of the values in each TargetText within the </span>
<span class="sd">                          `other_collection` that is be copied to the relevant </span>
<span class="sd">                          TargetTexts within this collection. It assumes that if</span>
<span class="sd">                          any of key/values are a list of lists that the inner </span>
<span class="sd">                          lists relate to the targets and the outer list is </span>
<span class="sd">                          not related to the targets. </span>
<span class="sd">        :param raise_on_overwrite: If True will raise the </span>
<span class="sd">                                   :py:class:`target_extraction.data_types_util.OverwriteError` </span>
<span class="sd">                                   if any of the `data_keys` exist in any </span>
<span class="sd">                                   of the TargetTexts within this collection.</span>
<span class="sd">        :param check_same_ids: If True will ensure that this collection and the </span>
<span class="sd">                               other collection are of same length and check </span>
<span class="sd">                               if each have the same unique ids</span>
<span class="sd">        :raises AssertionError: If the number of IDs from the `id_key` does not </span>
<span class="sd">                                match the number of data to be added to a data key</span>
<span class="sd">        :raises ValueError: If `check_same_ids` is True and the two collections </span>
<span class="sd">                            are either of not the same length or have  </span>
<span class="sd">                            different unique ids according to `id_key` within </span>
<span class="sd">                            the TargetText objects.</span>
<span class="sd">        :raises OverwriteError: If `raise_on_overwrite` is True and the any of </span>
<span class="sd">                                the `data_keys` exist in any of the TargetTexts</span>
<span class="sd">                                within this collection.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">def</span> <span class="nf">sort_data_by_key</span><span class="p">(</span><span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">self_target_text</span><span class="p">:</span> <span class="n">TargetText</span><span class="p">,</span> 
                             <span class="n">other_target_text</span><span class="p">:</span> <span class="n">TargetText</span><span class="p">,</span> 
                             <span class="n">data_to_sort</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">]:</span>
            <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            :param key: A key that appear in both `self_target_text` and </span>
<span class="sd">                        `other_target_text`, where the key for both represents </span>
<span class="sd">                        values that appear in both and are unique.</span>
<span class="sd">            :param self_target_text: A TargetText object where the values in </span>
<span class="sd">                                     `key` will determine the sorting performed</span>
<span class="sd">                                     to `data_to_sort`. </span>
<span class="sd">            :param other_target_text: The TargetText that represents the `data_to_sort`</span>
<span class="sd">                                      and is in this TargetText&#39;s sort order </span>
<span class="sd">                                      based on values in `key`</span>
<span class="sd">            :param data_to_sort: Data that has come from `other_target_text` that </span>
<span class="sd">                                 is to be sorted based on `key` values from </span>
<span class="sd">                                 `self_target_text`</span>
<span class="sd">            :returns: The `data_to_sort` ordered by the values in `self_target_text`</span>
<span class="sd">                      key `key`</span>
<span class="sd">            :raises AssertionError: If the number of IDs from the `key` does not </span>
<span class="sd">                                    match the number of data_to_sort</span>
<span class="sd">            &#39;&#39;&#39;</span>
            <span class="n">self_data_values</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">num_ids</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">other_target_text</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
            <span class="n">num_data</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_to_sort</span><span class="p">)</span>
            <span class="n">assert_err</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s1">&#39;The ID key </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s1"> contains </span><span class="si">{</span><span class="n">num_ids</span><span class="si">}</span><span class="s1">, however the &#39;</span>
                          <span class="s1">&#39;number of values/data to be added from the other &#39;</span>
                          <span class="sa">f</span><span class="s1">&#39;TargetText is </span><span class="si">{</span><span class="n">num_data</span><span class="si">}</span><span class="s1"> which is </span><span class="si">{</span><span class="n">data_to_sort</span><span class="si">}</span><span class="s1"> &#39;</span>
                          <span class="sa">f</span><span class="s1">&#39;OtherTargetText </span><span class="si">{</span><span class="n">other_target_text</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>
                          <span class="sa">f</span><span class="s1">&#39;SelfTargetText </span><span class="si">{</span><span class="n">self_target_text</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">num_ids</span> <span class="o">==</span> <span class="n">num_data</span><span class="p">,</span> <span class="n">assert_err</span>

            <span class="k">for</span> <span class="n">self_id_value</span> <span class="ow">in</span> <span class="n">self_target_text</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
                <span class="n">index_other_id_value</span> <span class="o">=</span> <span class="n">other_target_text</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">self_id_value</span><span class="p">)</span>
                <span class="n">self_data_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data_to_sort</span><span class="p">[</span><span class="n">index_other_id_value</span><span class="p">])</span>
            
            <span class="k">return</span> <span class="n">self_data_values</span>

        <span class="k">if</span> <span class="n">check_same_ids</span><span class="p">:</span>
            <span class="n">len_self</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">len_other</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">other_collection</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">len_self</span> <span class="o">!=</span> <span class="n">len_other</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The two collections are not the same length. &#39;</span>
                                 <span class="sa">f</span><span class="s1">&#39;This length </span><span class="si">{</span><span class="n">len_self</span><span class="si">}</span><span class="s1"> other </span><span class="si">{</span><span class="n">len_other</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">self_ids</span> <span class="o">=</span> <span class="p">{</span><span class="n">_id</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">for</span> <span class="n">_id</span> <span class="ow">in</span> <span class="n">value</span><span class="p">[</span><span class="n">id_key</span><span class="p">]}</span>
            <span class="n">other_ids</span> <span class="o">=</span> <span class="p">{</span><span class="n">_id</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">other_collection</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> 
                             <span class="k">for</span> <span class="n">_id</span> <span class="ow">in</span> <span class="n">value</span><span class="p">[</span><span class="n">id_key</span><span class="p">]}</span>
            <span class="n">self_differences</span> <span class="o">=</span> <span class="n">self_ids</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">other_ids</span><span class="p">)</span>
            <span class="n">other_differences</span> <span class="o">=</span> <span class="n">other_ids</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">self_ids</span><span class="p">)</span>
            <span class="n">all_differences</span> <span class="o">=</span> <span class="n">self_differences</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">other_differences</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_differences</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;The two collections do not contain the same&#39;</span>
                                 <span class="sa">f</span><span class="s1">&#39; ids. The difference between this and the &#39;</span>
                                 <span class="sa">f</span><span class="s1">&#39;other are the following ids </span><span class="si">{</span><span class="n">self_differences</span><span class="si">}</span><span class="s1">&#39;</span>
                                 <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">The difference between the other and this &#39;</span>
                                 <span class="sa">f</span><span class="s1">&#39;is the following </span><span class="si">{</span><span class="n">other_differences</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="c1"># If an error occurs would be good to have a roll back poilcy that </span>
        <span class="c1"># will return this collection back to it&#39;s original self</span>
        <span class="n">self_copy</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">text_id</span><span class="p">,</span> <span class="n">self_target_text</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">other_target_text</span> <span class="o">=</span> <span class="n">other_collection</span><span class="p">[</span><span class="n">text_id</span><span class="p">]</span>
                <span class="c1"># Cannot assume that the unique ids will be in the same order.</span>
                <span class="k">for</span> <span class="n">data_key</span> <span class="ow">in</span> <span class="n">data_keys</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">data_key</span> <span class="ow">in</span> <span class="n">self_target_text</span> <span class="ow">and</span> <span class="n">raise_on_overwrite</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">OverwriteError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;The following data key </span><span class="si">{</span><span class="n">data_key</span><span class="si">}</span><span class="s1">&#39;</span>
                                             <span class="s1">&#39; exists in the following TargetText&#39;</span>
                                             <span class="sa">f</span><span class="s1">&#39; </span><span class="si">{</span><span class="n">self_target_text</span><span class="si">}</span><span class="s1"> within this collection. &#39;</span>
                                             <span class="s1">&#39;The other TargetText that contains &#39;</span>
                                             <span class="s1">&#39;this data key to copy the data from &#39;</span>
                                             <span class="sa">f</span><span class="s1">&#39;is </span><span class="si">{</span><span class="n">other_target_text</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="n">self_data_values</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">other_data_values</span> <span class="o">=</span> <span class="n">other_target_text</span><span class="p">[</span><span class="n">data_key</span><span class="p">]</span>
                    <span class="c1"># If the other_data_values is a list of a list, need to </span>
                    <span class="c1"># take into account the sorting of the targets should only </span>
                    <span class="c1"># be applied to the inner list.</span>
                    <span class="n">is_inner_list</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other_data_values</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">other_data_values</span><span class="p">:</span>
                            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other_data_values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
                                <span class="n">is_inner_list</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">if</span> <span class="n">is_inner_list</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">other_inner_list_data</span> <span class="ow">in</span> <span class="n">other_data_values</span><span class="p">:</span>
                            <span class="n">self_inner_list_data</span> <span class="o">=</span> <span class="n">sort_data_by_key</span><span class="p">(</span><span class="n">id_key</span><span class="p">,</span> <span class="n">self_target_text</span><span class="p">,</span> 
                                                                    <span class="n">other_target_text</span><span class="p">,</span> 
                                                                    <span class="n">other_inner_list_data</span><span class="p">)</span>
                            <span class="n">self_data_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">self_inner_list_data</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">self_data_values</span> <span class="o">=</span> <span class="n">sort_data_by_key</span><span class="p">(</span><span class="n">id_key</span><span class="p">,</span> <span class="n">self_target_text</span><span class="p">,</span> 
                                                            <span class="n">other_target_text</span><span class="p">,</span> 
                                                            <span class="n">other_data_values</span><span class="p">)</span>
                    <span class="n">self_target_text</span><span class="p">[</span><span class="n">data_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">self_data_values</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_storage</span> <span class="o">=</span> <span class="n">self_copy</span>
            <span class="k">raise</span> <span class="n">e</span></div>

<div class="viewcode-block" id="TargetTextCollection.one_sentiment_text"><a class="viewcode-back" href="../../target_extraction.html#target_extraction.data_types.TargetTextCollection.one_sentiment_text">[docs]</a>    <span class="k">def</span> <span class="nf">one_sentiment_text</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sentiment_key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                           <span class="n">average_sentiment</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 
                           <span class="n">text_sentiment_key</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;text_sentiment&#39;</span>
                           <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Adds the `text_sentiment_key` to each TargetText within the collection </span>
<span class="sd">        where the value will represent the sentiment value for the text based </span>
<span class="sd">        on the `sentiment_key` values and `average_sentiment` determining how </span>
<span class="sd">        to handle multiple sentiments. This will allow text level classifiers </span>
<span class="sd">        to be trained on target/aspect/category data.</span>

<span class="sd">        :param sentiment_key: The key in the TargetTexts that represent the </span>
<span class="sd">                              sentiment for the TargetTexts sentence. </span>
<span class="sd">        :param average_sentiment: If False it will only add the `text_sentiment_key` </span>
<span class="sd">                                  to TargetTexts that have one unique sentiment in the </span>
<span class="sd">                                  `sentiment_key` e.g. can have more than one sentiment</span>
<span class="sd">                                  value in the `sentiment_key` but each one of </span>
<span class="sd">                                  those values has to be the same value. If True </span>
<span class="sd">                                  it will choose the </span>
<span class="sd">                                  most frequent sentiment , ties are decided </span>
<span class="sd">                                  by random choice. If the there are no </span>
<span class="sd">                                  values in `sentiment_key` then </span>
<span class="sd">                                  `text_sentiment_key` will not be added to </span>
<span class="sd">                                  the TargetText.</span>
<span class="sd">        :param text_sentiment_key: The key to add the text level sentiment value </span>
<span class="sd">                                   to.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">target_text</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">target_text</span><span class="p">:</span> <span class="n">TargetText</span>
            <span class="n">target_text</span><span class="o">.</span><span class="n">_key_error</span><span class="p">(</span><span class="n">sentiment_key</span><span class="p">)</span>

            <span class="n">sentiments</span> <span class="o">=</span> <span class="n">target_text</span><span class="p">[</span><span class="n">sentiment_key</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">average_sentiment</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sentiments</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">target_text</span><span class="p">[</span><span class="n">text_sentiment_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">sentiments</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">sentiments</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">sentiment_counts</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">sentiments</span><span class="p">)</span>
                    <span class="n">sorted_counts</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">sentiment_counts</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> 
                                           <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">highest_count</span> <span class="o">=</span> <span class="n">sorted_counts</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">highest_sentiment_values</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">sentiment_value</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">sorted_counts</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="n">highest_count</span><span class="p">:</span>
                            <span class="n">highest_sentiment_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sentiment_value</span><span class="p">)</span>
                    <span class="k">assert</span> <span class="n">highest_sentiment_values</span>
                    <span class="n">random_sentiment_value</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">highest_sentiment_values</span><span class="p">)</span>
                    <span class="n">target_text</span><span class="p">[</span><span class="n">text_sentiment_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">random_sentiment_value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sentiments</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">target_text</span><span class="p">[</span><span class="n">text_sentiment_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">sentiments</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">sentiments</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">sentiments</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">target_text</span><span class="p">[</span><span class="n">text_sentiment_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">sentiments</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="TargetTextCollection.combine"><a class="viewcode-back" href="../../target_extraction.html#target_extraction.data_types.TargetTextCollection.combine">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">combine</span><span class="p">(</span><span class="o">*</span><span class="n">collections</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;TargetTextCollection&#39;</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        :param collections: An iterator containing one or more </span>
<span class="sd">                            TargetTextCollections</span>
<span class="sd">        :returns: A TargetTextCollection that is the combination of all of </span>
<span class="sd">                  those given.</span>

<span class="sd">        :NOTE: If any of the collections are anonymised then the returned </span>
<span class="sd">               collection will also be anonymised, even if only one of the </span>
<span class="sd">               collections has been anonymised.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">target_objects</span><span class="p">:</span> <span class="s1">&#39;TargetText&#39;</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">is_anonymised</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">collection</span> <span class="ow">in</span> <span class="n">collections</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">collection</span><span class="o">.</span><span class="n">anonymised</span><span class="p">:</span>
                <span class="n">is_anonymised</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">collection</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="n">target_objects</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">TargetTextCollection</span><span class="p">(</span><span class="n">target_objects</span><span class="p">,</span> <span class="n">anonymised</span><span class="o">=</span><span class="n">is_anonymised</span><span class="p">)</span></div>

<div class="viewcode-block" id="TargetTextCollection.same_data"><a class="viewcode-back" href="../../target_extraction.html#target_extraction.data_types.TargetTextCollection.same_data">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">same_data</span><span class="p">(</span><span class="n">collections</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="s1">&#39;TargetTextCollection&#39;</span><span class="p">]</span>
                  <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="s1">&#39;TargetText&#39;</span><span class="p">,</span> <span class="s1">&#39;TargetText&#39;</span><span class="p">]],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        :param collections: A list of TargetTextCollections to test if there are </span>
<span class="sd">                            any duplicates based on `text_id` and `text` key </span>
<span class="sd">                            values.</span>
<span class="sd">        :returns: If the list is empty then there are no duplicates. Else a list of</span>
<span class="sd">                  tuples containing 1. A list of tuples of duplicate TargetText instances </span>
<span class="sd">                  2. A tuple of collection names that the TargetText have come stating </span>
<span class="sd">                  the names of the collections that have the duplicates.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">all_matches</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">collection_index</span><span class="p">,</span> <span class="n">collection</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">collections</span><span class="p">):</span>
            
            <span class="k">for</span> <span class="n">other_collection</span> <span class="ow">in</span> <span class="n">collections</span><span class="p">[</span><span class="n">collection_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]:</span>
                <span class="n">same_targets</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">target_text</span> <span class="ow">in</span> <span class="n">collection</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                    <span class="k">for</span> <span class="n">other_target_text</span> <span class="ow">in</span> <span class="n">other_collection</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                        <span class="k">if</span> <span class="n">target_text</span><span class="p">[</span><span class="s1">&#39;text_id&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">other_target_text</span><span class="p">[</span><span class="s1">&#39;text_id&#39;</span><span class="p">]:</span>
                            <span class="n">same_targets</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">target_text</span><span class="p">,</span> <span class="n">other_target_text</span><span class="p">))</span>
                        <span class="k">elif</span> <span class="n">target_text</span><span class="p">[</span><span class="s1">&#39;text&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">other_target_text</span><span class="p">[</span><span class="s1">&#39;text&#39;</span><span class="p">]:</span>
                            <span class="n">same_targets</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">target_text</span><span class="p">,</span> <span class="n">other_target_text</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">same_targets</span><span class="p">:</span>
                    <span class="n">all_matches</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">same_targets</span><span class="p">,</span> <span class="p">(</span><span class="n">collection</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">other_collection</span><span class="o">.</span><span class="n">name</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">all_matches</span></div>


    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s1">&#39;TargetText&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Will add the TargetText instance to the collection where the key </span>
<span class="sd">        should be the same as the TargetText instance &#39;text_id&#39;.</span>

<span class="sd">        :param key: Key to be added or changed</span>
<span class="sd">        :param value: TargetText instance associated to this key. Where the </span>
<span class="sd">                      key should be the same value as the TargetText instance </span>
<span class="sd">                      &#39;text_id&#39; value. Furthermore if the TargetTextCollection&#39;s</span>
<span class="sd">                      `anonymised` attribute is True then the TargetText object </span>
<span class="sd">                      being added will also be anonymised.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">TargetText</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;The value should be of type TargetText and not &#39;</span>
                            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">text_id</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="s1">&#39;text_id&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">text_id</span> <span class="o">!=</span> <span class="n">key</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;The value `text_id`: </span><span class="si">{</span><span class="n">text_id</span><span class="si">}</span><span class="s1"> should be the &#39;</span>
                             <span class="sa">f</span><span class="s1">&#39;same value as the key: </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="c1"># We copy it to stop any mutable objects from changing outside of the </span>
        <span class="c1"># collection</span>
        <span class="n">value_copy</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="n">value_copy</span><span class="o">.</span><span class="n">anonymised</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">anonymised</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value_copy</span>

    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Given a key that matches a key within self._storage or self.keys() </span>
<span class="sd">        it will delete that key and value from this object.</span>

<span class="sd">        :param key: Key and its respective value to delete from this object.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s1">&#39;TargetTextCollection&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Two TargetTextCollection instances are equal if they both have </span>
<span class="sd">        the same TargetText instances within it.</span>

<span class="sd">        :param other: Another TargetTextCollection object that is being  </span>
<span class="sd">                      compared to this TargetTextCollection object.</span>
<span class="sd">        :returns: True if they have the same TargetText instances within it.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">TargetTextCollection</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">other</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        :returns: String returned is what user see when the instance is </span>
<span class="sd">                  printed or printed within a interpreter.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">rep_text</span> <span class="o">=</span> <span class="s1">&#39;TargetTextCollection(&#39;</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">rep_text</span> <span class="o">+=</span> <span class="sa">f</span><span class="s1">&#39;key: </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s1">, value: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="k">break</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">rep_text</span> <span class="o">+=</span> <span class="s1">&#39;...)&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rep_text</span> <span class="o">+=</span> <span class="s1">&#39;)&#39;</span>
        <span class="k">return</span> <span class="n">rep_text</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        :returns: The number of TargetText instances in the collection.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns as interator over the TargetText instances &#39;text_id&#39;&#39;s that </span>
<span class="sd">        are stored in this collection. This is an ordered iterator as the </span>
<span class="sd">        underlying dictionary used to store the TargetText instances is an </span>
<span class="sd">        OrderedDict in self._storage.</span>

<span class="sd">        :returns: TargetText instances &#39;text_id&#39;&#39;s that are stored in this </span>
<span class="sd">                  collection</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;TargetText&#39;</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        :returns: A TargetText instance that is stored within this collection.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="p">[</span><span class="n">key</span><span class="p">]</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Andrew Moore

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>