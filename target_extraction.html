

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>target_extraction package &mdash; Target Extraction 0.0.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Target Extraction
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li><a class="reference internal" href="#">target_extraction package</a><ul>
<li><a class="reference internal" href="#subpackages">Subpackages</a></li>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-target_extraction.data_types">target_extraction.data_types module</a></li>
<li><a class="reference internal" href="#module-target_extraction.data_types_util">target_extraction.data_types_util module</a></li>
<li><a class="reference internal" href="#module-target_extraction.dataset_parsers">target_extraction.dataset_parsers module</a></li>
<li><a class="reference internal" href="#module-target_extraction.pos_taggers">target_extraction.pos_taggers module</a></li>
<li><a class="reference internal" href="#module-target_extraction.taggers_helper">target_extraction.taggers_helper module</a></li>
<li><a class="reference internal" href="#module-target_extraction.tokenizers">target_extraction.tokenizers module</a></li>
<li><a class="reference internal" href="#module-target_extraction">Module contents</a></li>
</ul>
</li>
</ul>
</div>
            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Target Extraction</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>target_extraction package</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/target_extraction.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="target-extraction-package">
<h1>target_extraction package<a class="headerlink" href="#target-extraction-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="subpackages">
<h2>Subpackages<a class="headerlink" href="#subpackages" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="target_extraction.allen.html">target_extraction.allen package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="target_extraction.allen.html#subpackages">Subpackages</a><ul>
<li class="toctree-l3"><a class="reference internal" href="target_extraction.allen.dataset_readers.html">target_extraction.allen.dataset_readers package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="target_extraction.allen.dataset_readers.html#submodules">Submodules</a></li>
<li class="toctree-l4"><a class="reference internal" href="target_extraction.allen.dataset_readers.html#module-target_extraction.allen.dataset_readers.target_conll">target_extraction.allen.dataset_readers.target_conll module</a></li>
<li class="toctree-l4"><a class="reference internal" href="target_extraction.allen.dataset_readers.html#module-target_extraction.allen.dataset_readers.target_extraction">target_extraction.allen.dataset_readers.target_extraction module</a></li>
<li class="toctree-l4"><a class="reference internal" href="target_extraction.allen.dataset_readers.html#module-target_extraction.allen.dataset_readers.target_sentiment">target_extraction.allen.dataset_readers.target_sentiment module</a></li>
<li class="toctree-l4"><a class="reference internal" href="target_extraction.allen.dataset_readers.html#module-target_extraction.allen.dataset_readers.text_sentiment">target_extraction.allen.dataset_readers.text_sentiment module</a></li>
<li class="toctree-l4"><a class="reference internal" href="target_extraction.allen.dataset_readers.html#module-target_extraction.allen.dataset_readers">Module contents</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="target_extraction.allen.models.html">target_extraction.allen.models package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="target_extraction.allen.models.html#subpackages">Subpackages</a><ul>
<li class="toctree-l5"><a class="reference internal" href="target_extraction.allen.models.target_sentiment.html">target_extraction.allen.models.target_sentiment package</a><ul>
<li class="toctree-l6"><a class="reference internal" href="target_extraction.allen.models.target_sentiment.html#submodules">Submodules</a></li>
<li class="toctree-l6"><a class="reference internal" href="target_extraction.allen.models.target_sentiment.html#module-target_extraction.allen.models.target_sentiment.atae">target_extraction.allen.models.target_sentiment.atae module</a></li>
<li class="toctree-l6"><a class="reference internal" href="target_extraction.allen.models.target_sentiment.html#module-target_extraction.allen.models.target_sentiment.in_context">target_extraction.allen.models.target_sentiment.in_context module</a></li>
<li class="toctree-l6"><a class="reference internal" href="target_extraction.allen.models.target_sentiment.html#module-target_extraction.allen.models.target_sentiment.interactive_attention_network">target_extraction.allen.models.target_sentiment.interactive_attention_network module</a></li>
<li class="toctree-l6"><a class="reference internal" href="target_extraction.allen.models.target_sentiment.html#module-target_extraction.allen.models.target_sentiment.split_contexts">target_extraction.allen.models.target_sentiment.split_contexts module</a></li>
<li class="toctree-l6"><a class="reference internal" href="target_extraction.allen.models.target_sentiment.html#module-target_extraction.allen.models.target_sentiment.util">target_extraction.allen.models.target_sentiment.util module</a></li>
<li class="toctree-l6"><a class="reference internal" href="target_extraction.allen.models.target_sentiment.html#module-target_extraction.allen.models.target_sentiment">Module contents</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="target_extraction.allen.models.html#submodules">Submodules</a></li>
<li class="toctree-l4"><a class="reference internal" href="target_extraction.allen.models.html#module-target_extraction.allen.models.target_tagger">target_extraction.allen.models.target_tagger module</a></li>
<li class="toctree-l4"><a class="reference internal" href="target_extraction.allen.models.html#module-target_extraction.allen.models">Module contents</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="target_extraction.allen.modules.html">target_extraction.allen.modules package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="target_extraction.allen.modules.html#subpackages">Subpackages</a><ul>
<li class="toctree-l5"><a class="reference internal" href="target_extraction.allen.modules.inter_target.html">target_extraction.allen.modules.inter_target package</a><ul>
<li class="toctree-l6"><a class="reference internal" href="target_extraction.allen.modules.inter_target.html#submodules">Submodules</a></li>
<li class="toctree-l6"><a class="reference internal" href="target_extraction.allen.modules.inter_target.html#module-target_extraction.allen.modules.inter_target.inter_target">target_extraction.allen.modules.inter_target.inter_target module</a></li>
<li class="toctree-l6"><a class="reference internal" href="target_extraction.allen.modules.inter_target.html#module-target_extraction.allen.modules.inter_target.sequence_inter_target">target_extraction.allen.modules.inter_target.sequence_inter_target module</a></li>
<li class="toctree-l6"><a class="reference internal" href="target_extraction.allen.modules.inter_target.html#module-target_extraction.allen.modules.inter_target">Module contents</a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="target_extraction.allen.modules.target_position_weight.html">target_extraction.allen.modules.target_position_weight package</a><ul>
<li class="toctree-l6"><a class="reference internal" href="target_extraction.allen.modules.target_position_weight.html#submodules">Submodules</a></li>
<li class="toctree-l6"><a class="reference internal" href="target_extraction.allen.modules.target_position_weight.html#module-target_extraction.allen.modules.target_position_weight.relative_target_position_weight">target_extraction.allen.modules.target_position_weight.relative_target_position_weight module</a></li>
<li class="toctree-l6"><a class="reference internal" href="target_extraction.allen.modules.target_position_weight.html#module-target_extraction.allen.modules.target_position_weight.target_position_weight">target_extraction.allen.modules.target_position_weight.target_position_weight module</a></li>
<li class="toctree-l6"><a class="reference internal" href="target_extraction.allen.modules.target_position_weight.html#module-target_extraction.allen.modules.target_position_weight">Module contents</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="target_extraction.allen.modules.html#submodules">Submodules</a></li>
<li class="toctree-l4"><a class="reference internal" href="target_extraction.allen.modules.html#module-target_extraction.allen.modules.word_dropout">target_extraction.allen.modules.word_dropout module</a></li>
<li class="toctree-l4"><a class="reference internal" href="target_extraction.allen.modules.html#module-target_extraction.allen.modules">Module contents</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="target_extraction.allen.predictors.html">target_extraction.allen.predictors package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="target_extraction.allen.predictors.html#submodules">Submodules</a></li>
<li class="toctree-l4"><a class="reference internal" href="target_extraction.allen.predictors.html#module-target_extraction.allen.predictors.target_sentiment">target_extraction.allen.predictors.target_sentiment module</a></li>
<li class="toctree-l4"><a class="reference internal" href="target_extraction.allen.predictors.html#module-target_extraction.allen.predictors.target_tagger">target_extraction.allen.predictors.target_tagger module</a></li>
<li class="toctree-l4"><a class="reference internal" href="target_extraction.allen.predictors.html#module-target_extraction.allen.predictors">Module contents</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="target_extraction.allen.token_indexers.html">target_extraction.allen.token_indexers package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="target_extraction.allen.token_indexers.html#submodules">Submodules</a></li>
<li class="toctree-l4"><a class="reference internal" href="target_extraction.allen.token_indexers.html#module-target_extraction.allen.token_indexers.custom_elmo_indexer">target_extraction.allen.token_indexers.custom_elmo_indexer module</a></li>
<li class="toctree-l4"><a class="reference internal" href="target_extraction.allen.token_indexers.html#module-target_extraction.allen.token_indexers">Module contents</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="target_extraction.allen.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="target_extraction.allen.html#module-target_extraction.allen.allennlp_model">target_extraction.allen.allennlp_model module</a></li>
<li class="toctree-l2"><a class="reference internal" href="target_extraction.allen.html#module-target_extraction.allen">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="target_extraction.analysis.html">target_extraction.analysis package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="target_extraction.analysis.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="target_extraction.analysis.html#module-target_extraction.analysis.dataset_plots">target_extraction.analysis.dataset_plots module</a></li>
<li class="toctree-l2"><a class="reference internal" href="target_extraction.analysis.html#module-target_extraction.analysis.dataset_statistics">target_extraction.analysis.dataset_statistics module</a></li>
<li class="toctree-l2"><a class="reference internal" href="target_extraction.analysis.html#module-target_extraction.analysis.sentiment_error_analysis">target_extraction.analysis.sentiment_error_analysis module</a></li>
<li class="toctree-l2"><a class="reference internal" href="target_extraction.analysis.html#module-target_extraction.analysis.sentiment_metrics">target_extraction.analysis.sentiment_metrics module</a></li>
<li class="toctree-l2"><a class="reference internal" href="target_extraction.analysis.html#module-target_extraction.analysis.statistical_analysis">target_extraction.analysis.statistical_analysis module</a></li>
<li class="toctree-l2"><a class="reference internal" href="target_extraction.analysis.html#module-target_extraction.analysis.util">target_extraction.analysis.util module</a></li>
<li class="toctree-l2"><a class="reference internal" href="target_extraction.analysis.html#module-target_extraction.analysis">Module contents</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-target_extraction.data_types">
<span id="target-extraction-data-types-module"></span><h2>target_extraction.data_types module<a class="headerlink" href="#module-target_extraction.data_types" title="Permalink to this headline">¶</a></h2>
<p>Moudle that contains the two main data types 
<cite>target_extraction.data_types.TargetText</cite> and 
<cite>target_extraction.data_types.TargetTextCollection</cite> where the later is a
container for the former.</p>
<p>classes:</p>
<ol class="arabic simple">
<li><p><cite>target_extraction.data_types.TargetText</cite></p></li>
<li><p><cite>target_extraction.data_types.TargetTextCollection</cite></p></li>
</ol>
<dl class="class">
<dt id="target_extraction.data_types.TargetText">
<em class="property">class </em><code class="sig-prename descclassname">target_extraction.data_types.</code><code class="sig-name descname">TargetText</code><span class="sig-paren">(</span><em class="sig-param">text</em>, <em class="sig-param">text_id</em>, <em class="sig-param">targets=None</em>, <em class="sig-param">spans=None</em>, <em class="sig-param">target_sentiments=None</em>, <em class="sig-param">categories=None</em>, <em class="sig-param">category_sentiments=None</em>, <em class="sig-param">anonymised=False</em>, <em class="sig-param">**additional_data</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/data_types.html#TargetText"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.data_types.TargetText" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MutableMapping</span></code></p>
<p>This is a data structure that inherits from MutableMapping which is 
essentially a python dictionary.</p>
<p>The following are the default keys that are in all <cite>TargetText</cite> 
objects, additional items can be added through __setitem__</p>
<ol class="arabic simple">
<li><p>text - The text associated to all of the other items</p></li>
<li><p>text_id – The unique ID associated to this object</p></li>
<li><dl class="simple">
<dt>targets – List of all target words that occur in the text. A special </dt><dd><p>placeholder of None (python None value) can exist where the 
target does not exist but a related Category does this would 
mean though that the related span is Span(0, 0), this type of 
special placeholder is in place for the SemEval 2016 Restaurant 
dataset where they link the categories to the targets but 
not all categories have related targets thus None.</p>
</dd>
</dl>
</li>
<li><p>spans – List of Span NamedTuples where each one specifies the start and 
end of the respective targets within the text.</p></li>
<li><p>target_sentiments – List sepcifying the sentiment of the respective 
targets within the text.</p></li>
<li><p>categories – List of categories that exist in the data which may or 
may not link to the targets (this is dataset speicific). NOTE: 
depending on the dataset and how it is parsed the category can exist 
but the target does not as the category is a latent variable, in 
these cases the category and category sentiments will be the same size 
which would be a different size to the target and target sentiments 
size. E.g. can happen where the dataset has targets and categories 
but they do not map to each other in a one to one manner e.g 
SemEval 2014 restuarant dataset, there are some samples that contain 
categories but no targets. Another word for category can be aspect.</p></li>
<li><p>category_sentiments – List of the sentiments associated to the 
categories. If the categories and targets map to each other then 
this will be empty and you will only use the target_sentiments.</p></li>
</ol>
<p>Attributes:</p>
<ol class="arabic simple">
<li><p>anonymised – If True then the data within the TargetText object has 
no text but the rest of the metadata should exist.</p></li>
</ol>
<p>Methods:</p>
<ol class="arabic">
<li><p>to_json – Returns the object as a dictionary and then encoded using 
json.dumps</p></li>
<li><p>to_conll – Returns a CONLL formatted string where the formatt will be the 
following: <cite>TOKEN#GOLD LABEL#PREDICTION 1# PREDICTION 2</cite>. Where each 
token and relevant labels are on separate new lines. The first line will 
always contain the following: <cite># {text_id: `value</cite>}` where the <cite>text_id</cite> 
represents the <cite>text_id</cite> of this TargetText, this will allow the CONLL</p>
<blockquote>
<div><p>string to be uniquely identified back this TargetText object.</p>
</div></blockquote>
</li>
<li><p>from_conll – Adds the gold labels and/or predicted sequence labels from 
the CONLL formatted string.</p></li>
<li><p>tokenize – This will add a new key <cite>tokenized_text</cite> to this TargetText 
instance that will store the tokens of the text that is associated to 
this TargetText instance.</p></li>
<li><p>pos_text – This will add a new key <cite>pos_tags</cite> to this TargetText 
instance. This key will store the pos tags of the text that is 
associated to this Target Text instance.</p></li>
<li><p>force_targets – Does not return anything but modifies the <cite>spans</cite> and 
<cite>text</cite> values as whitespace is prefixed and suffixed the target unless 
the prefix or suffix is whitespace. NOTE that this is the only method 
that currently can change the <cite>spans</cite> and <cite>text</cite> key values after they 
have been set.</p></li>
<li><p>sequence_labels – Adds the <cite>sequence_labels</cite> key to this TargetText 
instance which can be used to train a machine learning algorthim to 
detect targets.</p></li>
<li><p>get_sequence_indexs – The indexs related to the tokens, pos tags etc 
for each labelled sequence span.</p></li>
<li><p>get_sequence_spans – The span indexs from the sequence labels given 
assuming that the sequence labels are in BIO format.</p></li>
<li><p>get_targets_from_sequence_labels – Retrives the target words given the 
sequence labels.</p></li>
<li><p>one_sample_per_span – This returns a similar TargetText instance 
where the new instance will only contain one target per span.</p></li>
<li><p>left_right_target_contexts – This will return the sentence that is 
left and right of the target as well as the words in the target for 
each target in the sentence.</p></li>
<li><p>replace_target – Given an index and a new target word it will replace 
the target at the index with the new target word and return a new 
TargetText object with everything the same apart from this new target.</p></li>
<li><p>de_anonymise – This will set the <cite>anonymised</cite> attribute to False 
from True and set the <cite>text</cite> key value to the value in the <cite>text</cite> 
key within the <cite>text_dict</cite> argument.</p></li>
<li><p>in_order – True if all the <cite>targets</cite> within this TargetText 
are in sequential left to right order within the text.</p></li>
<li><p>re_order – Re-Orders the TargetText object targets so that they are in 
a left to right order within the text, this will then re-order all 
values within this object that are in a list format into this order. 
Once the TargetText has been re-ordered it will return True when 
:py:meth`target_extraction.data_types.TargetText.in_order` is called.</p></li>
<li><p>add_unique_key – Given a key e.g. <cite>targets</cite> it will create a new value 
in the TargetText object that is a list of strings which are unique IDs
based on the <cite>text_id</cite> and the index the <cite>targets</cite> occur in e.g. 
if the <cite>targets</cite> contain [<cite>food</cite>, <cite>service</cite>] and the <cite>text_id</cite> is 
<cite>12a5</cite> then the <cite>target_id</cite> created will contain <cite>[`12a5$$0</cite>,`12a5$$1`]`</p></li>
</ol>
<p>Static Functions:</p>
<ol class="arabic simple">
<li><p>from_json – Returns a TargetText object given a json string. For 
example the json string can be the return of TargetText.to_json.</p></li>
<li><p>targets_from_spans – Given a sequence of spans and the associated text 
it will return the targets that are within the text based on the spans</p></li>
<li><p>target_text_from_prediction – Creates a TargetText object from data 
that has come from predictions of a Target Extract tagger</p></li>
</ol>
<dl class="method">
<dt id="target_extraction.data_types.TargetText.add_unique_key">
<code class="sig-name descname">add_unique_key</code><span class="sig-paren">(</span><em class="sig-param">id_key</em>, <em class="sig-param">id_key_name</em>, <em class="sig-param">id_delimiter='::'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/data_types.html#TargetText.add_unique_key"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.data_types.TargetText.add_unique_key" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>id_key</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – The name of the key within this TargetText that requires 
unique ids that will be stored in <cite>id_key_name</cite>.</p></li>
<li><p><strong>id_key_name</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – The name of the key to associate to these new 
unique ids.</p></li>
<li><p><strong>id_delimiter</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – The delimiter to seperate the <cite>text_id</cite> and the 
index of the <cite>id_key</cite> that is being represented 
by this unique id.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>KeyError</strong> – If the <cite>id_key_name</cite> already exists within the 
TargetText.</p></li>
<li><p><strong>TypeError</strong> – If the value of <cite>id_key</cite> is not of type List.</p></li>
</ul>
</dd>
<dt class="field-odd">Example</dt>
<dd class="field-odd"><p>self.add_unique_key(<cite>targets</cite>, <cite>targets_id</cite>) where 
<cite>targets`=[`food</cite>, <cite>service</cite>] and <cite>text_id`=`12a5</cite> the 
following key will be added to self <cite>targets_id</cite> with the 
following value = <cite>[`12a5::0</cite>, <cite>12a5::1</cite>]`</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="target_extraction.data_types.TargetText.anonymised">
<em class="property">property </em><code class="sig-name descname">anonymised</code><a class="headerlink" href="#target_extraction.data_types.TargetText.anonymised" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>True if the data within the TargetText has been anonymised.
Anonymised data means that there is no text associated with
the TargetText object but all of the metadata is there.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="target_extraction.data_types.TargetText.de_anonymise">
<code class="sig-name descname">de_anonymise</code><span class="sig-paren">(</span><em class="sig-param">text_dict</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/data_types.html#TargetText.de_anonymise"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.data_types.TargetText.de_anonymise" title="Permalink to this definition">¶</a></dt>
<dd><p>This will set the <cite>anonymised</cite> attribute to False from True and 
set the <cite>text</cite> key value to the value in the <cite>text</cite> key within the 
<cite>text_dict</cite> argument.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>text_dict</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Dict</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]) – A dictionary that contain the following two keys: 
1. <cite>text</cite> and 2. <cite>text_id</cite> where the <cite>text_id</cite> has 
to match the current TargetText object <cite>text_id</cite> and 
the <cite>text</cite> value will become the new value in the 
<cite>text</cite> key for this TargetText object.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – If the TargetText object <cite>text_id</cite> does not match 
the <cite>text_id</cite> within <cite>text_dict</cite> argument.</p></li>
<li><p><a class="reference internal" href="#target_extraction.data_types_util.AnonymisedError" title="target_extraction.data_types_util.AnonymisedError"><strong>AnonymisedError</strong></a> – If the <cite>text</cite> given does not pass the 
<a class="reference internal" href="#target_extraction.data_types.TargetText.sanitize" title="target_extraction.data_types.TargetText.sanitize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sanitize()</span></code></a> test.</p></li>
</ul>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="target_extraction.data_types.TargetText.force_targets">
<code class="sig-name descname">force_targets</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/data_types.html#TargetText.force_targets"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.data_types.TargetText.force_targets" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">NOTE</dt>
<dd class="field-odd"><p>As this affects the following attributes <cite>spans</cite>, <cite>text</cite>, and <cite>targets</cite> 
it therefore has to modify these through self._storage as both of  
these attributes are within self._protected_keys.</p>
</dd>
</dl>
<p>Does not return anything but modifies the <cite>spans</cite> and <cite>text</cite> values 
as whitespace is prefixed and suffixed the target unless the prefix 
or suffix is whitespace.</p>
<p>Motivation:
Ensure that the target tokens are not within another separate String 
e.g. target = <cite>priced</cite> but the sentence is <cite>the laptop;priced is high</cite> 
and the tokenizer is on whitespace it will not have <cite>priced</cite> seperated 
therefore the BIO tagging is not deterministic thus force will add 
whitespace around the target word e.g. <cite>the laptop; priced</cite>. This was 
mainly added for the TargetText.sequence_tags method.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference internal" href="#target_extraction.data_types_util.AnonymisedError" title="target_extraction.data_types_util.AnonymisedError"><strong>AnonymisedError</strong></a> – If the object has been anonymised then this 
method cannot be used.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="target_extraction.data_types.TargetText.from_conll">
<code class="sig-name descname">from_conll</code><span class="sig-paren">(</span><em class="sig-param">conll_str</em>, <em class="sig-param">tokens_key='tokenized_text'</em>, <em class="sig-param">gold_label_key=None</em>, <em class="sig-param">prediction_key=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/data_types.html#TargetText.from_conll"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.data_types.TargetText.from_conll" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>conll_str</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – CONLL formatted string formatted like so: 
<cite>TOKEN#GOLD LABEL#PREDICTION 1# PREDICTION 2</cite></p></li>
<li><p><strong>tokens_key</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – Key to save the CONLL tokens too.</p></li>
<li><p><strong>gold_label_key</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]) – Key to save the gold labels too. Either 
<cite>gold_label_key</cite> or <cite>prediction_key</cite> must not be 
<cite>None</cite> or both not <cite>None</cite></p></li>
<li><p><strong>prediction_key</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]) – Key to save the prediction labels too. The value 
will be of shape (number runs, number tokens)</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><a class="reference internal" href="#target_extraction.data_types_util.AnonymisedError" title="target_extraction.data_types_util.AnonymisedError"><strong>AnonymisedError</strong></a> – If the object has been anonymised then this 
method cannot be used.</p></li>
<li><p><strong>ValueError</strong> – If both <cite>gold_label_key</cite> and <cite>prediction_key</cite> are 
<cite>None</cite>.</p></li>
<li><p><strong>ValueError</strong> – If the number of labels are not consistent in the 
CONLL string e.g. the first token has 3 predicted 
labels and the second token has 2 predicted labels.</p></li>
<li><p><strong>ValueError</strong> – If the text within this TargetText does not match 
the tokens in the CONLL string. (CASE SENSITIVE)</p></li>
</ul>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="target_extraction.data_types.TargetText.from_json">
<em class="property">static </em><code class="sig-name descname">from_json</code><span class="sig-paren">(</span><em class="sig-param">json_text</em>, <em class="sig-param">anonymised=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/data_types.html#TargetText.from_json"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.data_types.TargetText.from_json" title="Permalink to this definition">¶</a></dt>
<dd><p>This is required as the ‘spans’ are Span objects which are not json 
serlizable and are required for TargetText therefore this handles 
that special case.</p>
<p>This function is also required as we have had to avoid using the 
__set__ function and add objects via the _storage dictionary 
underneath so that we could add values to this object that are not 
within the constructor like <cite>tokenized_text</cite>. To ensure that it is 
compatable with the TargetText concept we call <cite>TargetText.sanitize</cite>
method at the end.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>json_text</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – JSON representation of TargetText 
(can be from TargetText.to_json)</p></li>
<li><p><strong>anonymised</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – Whether or not the TargetText object being loaded 
is an anonymised version.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#target_extraction.data_types.TargetText" title="target_extraction.data_types.TargetText"><code class="xref py py-class docutils literal notranslate"><span class="pre">TargetText</span></code></a></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A TargetText object</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>KeyError</strong> – If within the JSON representation there is no 
<cite>text_id</cite> key. Or if anonymised is False raises a
KeyError if there is no <cite>text</cite> key in the JSON 
representation.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="target_extraction.data_types.TargetText.get_sequence_indexs">
<code class="sig-name descname">get_sequence_indexs</code><span class="sig-paren">(</span><em class="sig-param">sequence_key</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/data_types.html#TargetText.get_sequence_indexs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.data_types.TargetText.get_sequence_indexs" title="Permalink to this definition">¶</a></dt>
<dd><p>The following sequence label tags are supported: IOB-2. These are the 
tags that are currently generated by <cite>sequence_labels</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>sequence_key</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – Key to sequence labels such as a BIO sequence 
labels. Example key name would be <cite>sequence_labels</cite>
after <cite>sequence_labels</cite> function has been called 
or more appropiately <cite>predicted_sequence_labels</cite> 
when you have predicted sequence labels.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]]</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p>A list of a list of intergers where each list of integers 
represent the token/pos tag/sequence label index of each 
sequence label span.
:Example: These sequence labels [<cite>O</cite>, <cite>B</cite>, <cite>I</cite>, <cite>O</cite>, <cite>B</cite>]</p>
<blockquote>
<div><p>would return the following integers list [[1, 2], [4]]</p>
</div></blockquote>
</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><a class="reference internal" href="#target_extraction.data_types_util.AnonymisedError" title="target_extraction.data_types_util.AnonymisedError"><strong>AnonymisedError</strong></a> – If the object has been anonymised then this 
method cannot be used.</p></li>
<li><p><strong>ValueError</strong> – If the sequence labels that are contained in the 
sequence key value contain values other than 
<cite>B</cite>, <cite>I</cite>, or <cite>O</cite>.</p></li>
<li><p><strong>ValueError</strong> – If then number of tokens in the current TargetText 
object is not the same as the number of sequence 
labels.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="target_extraction.data_types.TargetText.get_sequence_spans">
<code class="sig-name descname">get_sequence_spans</code><span class="sig-paren">(</span><em class="sig-param">sequence_key</em>, <em class="sig-param">confidence=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/data_types.html#TargetText.get_sequence_spans"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.data_types.TargetText.get_sequence_spans" title="Permalink to this definition">¶</a></dt>
<dd><p>The following sequence label tags are supported: IOB-2. These are the 
tags that are currently generated by <cite>sequence_labels</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sequence_key</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – Key to sequence labels such as a BIO sequence 
labels. Example key name would be <cite>sequence_labels</cite>
after <cite>sequence_labels</cite> function has been called 
or more appropiately <cite>predicted_sequence_labels</cite> 
when you have predicted sequence labels.</p></li>
<li><p><strong>confidence</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]) – <p>Optional argument that will return only spans 
that have been predicted with a confidence 
higher than this. 
:NOTE: As it is BIO labelling in the case where</p>
<blockquote>
<div><p>all but one of the B and I’s is greater than 
the threshold that span would not be 
returned, as one of the words in the multi 
word target word is less than the threshold.</p>
</div></blockquote>
</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<a class="reference internal" href="#target_extraction.data_types_util.Span" title="target_extraction.data_types_util.Span"><code class="xref py py-class docutils literal notranslate"><span class="pre">Span</span></code></a>]</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The span indexs from the sequence labels given assuming that 
the sequence labels are in BIO format.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><a class="reference internal" href="#target_extraction.data_types_util.AnonymisedError" title="target_extraction.data_types_util.AnonymisedError"><strong>AnonymisedError</strong></a> – If the object has been anonymised then this 
method cannot be used.</p></li>
<li><p><strong>KeyError</strong> – If no <cite>confidence</cite> key are found. However <cite>confidence</cite> 
is only required if the confidence argument is set.</p></li>
<li><p><strong>ValueError</strong> – If the sequence labels that are contained in the 
sequence key value contain values other than 
<cite>B</cite>, <cite>I</cite>, or <cite>O</cite>.</p></li>
<li><p><strong>ValueError</strong> – If the confidence value is not between 0 and 1</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="target_extraction.data_types.TargetText.get_targets_from_sequence_labels">
<code class="sig-name descname">get_targets_from_sequence_labels</code><span class="sig-paren">(</span><em class="sig-param">sequence_key</em>, <em class="sig-param">confidence=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/data_types.html#TargetText.get_targets_from_sequence_labels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.data_types.TargetText.get_targets_from_sequence_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>This function mains use is when the sequence labels have been 
predicted on a piece of text that has no gold annotations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sequence_key</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – Key to sequence labels such as a BIO sequence 
labels. Example key name would be <cite>sequence_labels</cite>
after <cite>sequence_labels</cite> function has been called 
or more appropiately <cite>predicted_sequence_labels</cite> 
when you have predicted sequence labels.</p></li>
<li><p><strong>confidence</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]) – <p>Optional argument that will return only target 
texts that have been predicted with a confidence 
higher than this. 
:NOTE: As it is BIO labelling in the case where</p>
<blockquote>
<div><p>all but one of the B and I’s is greater than 
the threshold that target word would not be 
returned as one of the words in the multi 
word target word is less than the threshold.</p>
</div></blockquote>
</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The target text’s that the sequence labels have predcited.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><a class="reference internal" href="#target_extraction.data_types_util.AnonymisedError" title="target_extraction.data_types_util.AnonymisedError"><strong>AnonymisedError</strong></a> – If the object has been anonymised then this 
method cannot be used.</p></li>
<li><p><strong>KeyError</strong> – If no <cite>tokenized_text</cite> or <cite>confidence</cite> key are found.
However <cite>confidence</cite> is only required if the 
confidence argument is set.</p></li>
<li><p><strong>ValueError</strong> – If the confidence value is not between 0 and 1</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="target_extraction.data_types.TargetText.in_order">
<code class="sig-name descname">in_order</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/data_types.html#TargetText.in_order"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.data_types.TargetText.in_order" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>True if all the <cite>targets</cite> within this TargetText 
are in sequential left to right order within the text.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="target_extraction.data_types.TargetText.left_right_target_contexts">
<code class="sig-name descname">left_right_target_contexts</code><span class="sig-paren">(</span><em class="sig-param">incl_target</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/data_types.html#TargetText.left_right_target_contexts"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.data_types.TargetText.left_right_target_contexts" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>incl_target</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – Whether or not the left and right sentences should 
also include the target word.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>], <code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>], <code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]]]</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The sentence that is left and right of the target as well as 
the words in the target for each target in the sentence.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><a class="reference internal" href="#target_extraction.data_types_util.AnonymisedError" title="target_extraction.data_types_util.AnonymisedError"><strong>AnonymisedError</strong></a> – If the object has been anonymised then this 
method cannot be used.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="target_extraction.data_types.TargetText.one_sample_per_span">
<code class="sig-name descname">one_sample_per_span</code><span class="sig-paren">(</span><em class="sig-param">remove_empty=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/data_types.html#TargetText.one_sample_per_span"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.data_types.TargetText.one_sample_per_span" title="Permalink to this definition">¶</a></dt>
<dd><p>This returns a similar TargetText instance where the new instance 
will only contain one target per span.</p>
<p>This is for the cases where you can have a target e.g. <cite>food</cite> that has 
a different related category attached to it e.g.
TargetText(text=`$8 and there is much nicer, food, all of it great and</p>
<blockquote>
<div><p>continually refilled.`, text_id=`1`, 
targets=[<cite>food</cite>, <cite>food</cite>, <cite>food</cite>], 
categories=[<cite>style</cite>, <cite>quality</cite>, <cite>price</cite>], 
target_sentiments=[<cite>pos</cite>,`pos`,`pos`], 
spans=[Span(27, 31),Span(27, 31),Span(27, 31)])</p>
</div></blockquote>
<p>As we can see the targets and the categories are linked, this is only 
really the case in SemEval 2016 datasets from what I know currently. 
In the example case above it will transform it to the following:
TargetText(text=`$8 and there is much nicer, food, all of it great and</p>
<blockquote>
<div><p>continually refilled.`, text_id=`1`, 
targets=[<cite>food</cite>],spans=[Span(27,31)])</p>
</div></blockquote>
<p>This type of pre-processing is perfect for the Target Extraction 
task.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>remove_empty</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – If the TargetText instance contains any None 
targets then these will be removed along with 
their respective Spans.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#target_extraction.data_types.TargetText" title="target_extraction.data_types.TargetText"><code class="xref py py-class docutils literal notranslate"><span class="pre">TargetText</span></code></a></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>This returns a similar TargetText instance where the new 
instance will only contain one target per span.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><a class="reference internal" href="#target_extraction.data_types_util.AnonymisedError" title="target_extraction.data_types_util.AnonymisedError"><strong>AnonymisedError</strong></a> – If the object has been anonymised then this 
method cannot be used.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="target_extraction.data_types.TargetText.pos_text">
<code class="sig-name descname">pos_text</code><span class="sig-paren">(</span><em class="sig-param">tagger</em>, <em class="sig-param">perform_type_checks=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/data_types.html#TargetText.pos_text"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.data_types.TargetText.pos_text" title="Permalink to this definition">¶</a></dt>
<dd><p>This will add a new key <cite>pos_tags</cite> to this TargetText instance.
This key will store the pos tags of the text that is associated to 
this Target Text instance. NOTE: It will also replace the current 
tokens in the <cite>tokenized_text</cite> key with the tokens produced 
from the pos tagger.</p>
<p>For a set of pos taggers that are definetly comptable see 
target_extraction.pos_taggers module. The pos tagger will have to 
produce both a list of tokens and pos tags.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tagger</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Callable</span></code>[[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>], <code class="xref py py-class docutils literal notranslate"><span class="pre">Tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>], <code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]]]) – POS tagger.</p></li>
<li><p><strong>perform_type_checks</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – Whether or not to perform type checks 
to ensure the POS tagger returns a 
tuple containing two lists both containing 
Strings.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><a class="reference internal" href="#target_extraction.data_types_util.AnonymisedError" title="target_extraction.data_types_util.AnonymisedError"><strong>AnonymisedError</strong></a> – If the object has been anonymised then this 
method cannot be used.</p></li>
<li><p><strong>TypeError</strong> – If the POS tagger given does not return a Tuple</p></li>
<li><p><strong>TypeError</strong> – If the POS tagger given does not return a List of 
Strings for both the tokens and the pos tags.</p></li>
<li><p><strong>TypeError</strong> – If the POS tagger tokens or pos tags are not lists</p></li>
<li><p><strong>ValueError</strong> – If the POS tagger return is not a tuple of length 
2</p></li>
<li><p><strong>ValueError</strong> – This is raised if the Target Text text is empty</p></li>
<li><p><strong>ValueError</strong> – If the number of pos tags for this instance
does not have the same number of tokens that has 
been generated by the tokenizer function.</p></li>
</ul>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="target_extraction.data_types.TargetText.re_order">
<code class="sig-name descname">re_order</code><span class="sig-paren">(</span><em class="sig-param">keys_not_to_order=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/data_types.html#TargetText.re_order"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.data_types.TargetText.re_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Re-orders the TargetText object so that the targets are in a left to 
right order within the text, this will then re-order all values within 
this object that are in a list format into this order. Once the 
TargetText has been re-ordered it will return True when 
:py:meth`target_extraction.data_types.TargetText.in_order` is called.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>keys_not_to_order</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]]) – Any key values not to re-order using this 
function e.g. <cite>pos_tags</cite>, <cite>tokenized_text</cite>, 
etc</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>AssertionError</strong> – If running :py:meth`target_extraction.data_types.TargetText.in_order`
after being re-ordered does not return True.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="target_extraction.data_types.TargetText.replace_target">
<code class="sig-name descname">replace_target</code><span class="sig-paren">(</span><em class="sig-param">target_index</em>, <em class="sig-param">replacement_target_word</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/data_types.html#TargetText.replace_target"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.data_types.TargetText.replace_target" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Params target_index</dt>
<dd class="field-odd"><p>The target index of the target word to replace</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p><strong>replacement_target_word</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – The target word to replace the target 
word at the given index</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#target_extraction.data_types.TargetText" title="target_extraction.data_types.TargetText"><code class="xref py py-class docutils literal notranslate"><span class="pre">TargetText</span></code></a></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Given the target index and replacement target word it will 
replace the target at the index with the new target word and 
return a new TargetText object with everything the same apart 
from this new target.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ValueError</strong> – If the target_index is less than 0 or an index 
number that does not exist.</p></li>
<li><p><a class="reference internal" href="#target_extraction.data_types_util.OverLappingTargetsError" title="target_extraction.data_types_util.OverLappingTargetsError"><strong>OverLappingTargetsError</strong></a> – If the target to replace is contained 
within another target e.g. 
<cite>what a great day</cite> if this has two 
targets <cite>great</cite> and <cite>great day</cite> then 
it will raise this error if you 
replace either word as each is 
within the other.</p></li>
<li><p><a class="reference internal" href="#target_extraction.data_types_util.AnonymisedError" title="target_extraction.data_types_util.AnonymisedError"><strong>AnonymisedError</strong></a> – If the object has been anonymised then this 
method cannot be used.</p></li>
</ul>
</dd>
<dt class="field-even">Example</dt>
<dd class="field-even"><p>Given the following TargetText Object</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="target_extraction.data_types.TargetText.sanitize">
<code class="sig-name descname">sanitize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/data_types.html#TargetText.sanitize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.data_types.TargetText.sanitize" title="Permalink to this definition">¶</a></dt>
<dd><p>This performs a check on all of the lists that can be given at 
object construction time to ensure that the following conditions are 
met:</p>
<ol class="arabic simple">
<li><p>The target, spans and target_sentiments lists are all of the same 
size if set.</p></li>
<li><p>The categories and the category_sentiments lists are all of the 
same size if set.</p></li>
</ol>
<p>Further more it checks the following:</p>
<ol class="arabic simple">
<li><p>If targets or spans are set then both have to exist.</p></li>
<li><p>If targets and spans are set that the spans text match the 
associated target words e.g. if the target is <cite>barry davies</cite> in 
<cite>today barry davies went</cite> then the spans should be [[6,18]]</p></li>
<li><p>If anonymised esures that the <cite>text</cite> key does not exist.</p></li>
</ol>
<p>The 2nd check is not performed if <cite>self.anonymised</cite> is False.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If any of the above conditions are not True.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="target_extraction.data_types.TargetText.sequence_labels">
<code class="sig-name descname">sequence_labels</code><span class="sig-paren">(</span><em class="sig-param">per_target=False</em>, <em class="sig-param">label_key=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/data_types.html#TargetText.sequence_labels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.data_types.TargetText.sequence_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds the <cite>sequence_labels</cite> key to this TargetText instance which can 
be used to train a machine learning algorthim to detect targets. The 
value associated to the <cite>sequence_labels</cite> key will be a list of 
<cite>B</cite>, <cite>I</cite>, or <cite>O</cite> labels, where each label is associated to a token.</p>
<p>The <cite>force_targets</cite> method might come in useful here for training 
and validation data to ensure that more of the targets are not 
affected by tokenization error as only tokens that are fully within 
the target span are labelled with <cite>B</cite> or <cite>I</cite> tags. Another use for the 
<cite>force_targets</cite> is so to ensure that targets are not affected by 
tokenisation and therefore can be used to state where the targets are 
in the sequence for sentiment classification e.g. in the case of 
getting contextualised target tokens or to create [TD-BERT 
Gao et al. 2019](<a class="reference external" href="https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8864964">https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8864964</a>).</p>
<p>Currently the only sequence labels supported is IOB-2 labels for the 
targets only. Future plans look into different sequence label order
e.g. IOB see link below for more details of the difference between the 
two sequence, of which there are more sequence again.
<a class="reference external" href="https://en.wikipedia.org/wiki/Inside%E2%80%93outside%E2%80%93beginning_(tagging">https://en.wikipedia.org/wiki/Inside%E2%80%93outside%E2%80%93beginning_(tagging</a>)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>per_target</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – Whether the the value of associated to the 
<cite>sequence_labels</cite> key should be one list for all 
of the targets False. Or if True should be a list 
of a labels per target where the labels will only 
be associated to the represented target.</p></li>
<li><p><strong>label_key</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]) – Optional label key. Where the key represents a list of 
values that are associated with each token. These list 
of values are then the class labels to attach to 
each <cite>B</cite>, <cite>I</cite>, <cite>O</cite> tag. E.g. the label key could be 
<cite>target_sentiments</cite> therefore creating the sequence 
labelling task of target extraction and predicting 
sentiment. For example if the label key is <cite>target_sentiments</cite>
it would make the <cite>B</cite>, <cite>I</cite>, <cite>O</cite> task extraction 
and sentiment prediction.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><a class="reference internal" href="#target_extraction.data_types_util.AnonymisedError" title="target_extraction.data_types_util.AnonymisedError"><strong>AnonymisedError</strong></a> – If the object has been anonymised then this 
method cannot be used.</p></li>
<li><p><strong>KeyError</strong> – If the current TargetText has not been tokenized. Or 
if <cite>label_key</cite> is not None then <cite>label_key</cite> must be 
a key in self else KeyError.</p></li>
<li><p><strong>ValueError</strong> – If <cite>label_key</cite> not None. Raises if number of labels 
does not match the number of targets that the labels 
should be associated too.</p></li>
<li><p><strong>ValueError</strong> – If two targets overlap the same token(s) e.g 
<cite>Laptop cover was great</cite> if <cite>Laptop</cite> and 
<cite>Laptop cover</cite> are two separate targets this should 
raise a ValueError as a token should only be 
associated to one target.</p></li>
</ul>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="target_extraction.data_types.TargetText.target_text_from_prediction">
<em class="property">static </em><code class="sig-name descname">target_text_from_prediction</code><span class="sig-paren">(</span><em class="sig-param">text</em>, <em class="sig-param">text_id</em>, <em class="sig-param">sequence_labels</em>, <em class="sig-param">tokenized_text</em>, <em class="sig-param">confidence=None</em>, <em class="sig-param">confidences=None</em>, <em class="sig-param">**additional_data</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/data_types.html#TargetText.target_text_from_prediction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.data_types.TargetText.target_text_from_prediction" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a TargetText object from data that has come from predictions
of a Target Extract tagger e.g. the dictionaries that are returned 
from <code class="xref py py-meth docutils literal notranslate"><span class="pre">target_extraction.allen.allennlp_model.predict_sequences()</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>text</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – Text to give to the TargetText object</p></li>
<li><p><strong>text_id</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – Text ID to give to the TargetText object</p></li>
<li><p><strong>sequence_labels</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]) – The predicted sequence labels</p></li>
<li><p><strong>tokenized_text</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]) – The tokens that were used to produce the 
predicted sequence labels (should be returned 
by the Target Extract tagger predictor).</p></li>
<li><p><strong>confidence</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]) – The level of confidence from the tagger that is 
required for a target to be a target e.g. 0.9</p></li>
<li><p><strong>confidences</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]]) – The list of confidence values produced 
by the Target Extract tagger predictor to be used 
with the confidence argument. The list of confidence 
values should be the same size as the sequence labels 
list and tokenized text.</p></li>
<li><p><strong>additional_data</strong> – Any other keyword arguments to provide to the 
TargetText object</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#target_extraction.data_types.TargetText" title="target_extraction.data_types.TargetText"><code class="xref py py-class docutils literal notranslate"><span class="pre">TargetText</span></code></a></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A TargetText object with spans and targets values</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – If sequence labels, tokenized text and confidecnes 
are not of the same length</p></li>
<li><p><strong>ValueError</strong> – If the following keys are in the additional data;
1. confidence, 2. text, 3. text_id, 4. tokenized_text
5. sequence_labels, 6. targets, 7. spans. As these 
keys will be populated by within the TargetText 
object automatically.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="target_extraction.data_types.TargetText.targets_from_spans">
<em class="property">static </em><code class="sig-name descname">targets_from_spans</code><span class="sig-paren">(</span><em class="sig-param">text</em>, <em class="sig-param">spans</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/data_types.html#TargetText.targets_from_spans"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.data_types.TargetText.targets_from_spans" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>text</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – The text that the spans are associated too.</p></li>
<li><p><strong>spans</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<a class="reference internal" href="#target_extraction.data_types_util.Span" title="target_extraction.data_types_util.Span"><code class="xref py py-class docutils literal notranslate"><span class="pre">Span</span></code></a>]) – A list of Span values that represent the character index 
of the target words to be returned.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The target words that are associated to the spans and text 
given.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="target_extraction.data_types.TargetText.to_conll">
<code class="sig-name descname">to_conll</code><span class="sig-paren">(</span><em class="sig-param">gold_label_key</em>, <em class="sig-param">prediction_key=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/data_types.html#TargetText.to_conll"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.data_types.TargetText.to_conll" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>gold_label</strong> – A key that contains a sequence of labels e.g. 
[<cite>B</cite>, <cite>I</cite>, <cite>O</cite>]. This can come from the return 
of the <a class="reference internal" href="#target_extraction.data_types.TargetText.sequence_labels" title="target_extraction.data_types.TargetText.sequence_labels"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sequence_labels()</span></code></a></p></li>
<li><p><strong>prediction_key</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]) – Key to the predicted labels of the <cite>gold_label</cite>. 
Where the prediction key values is a list of a 
list of predicted labels. Each list is therefore 
a different model run hence creating the 
<cite>PREDICTION 1</cite>, ‘PREDICTION 2’ etc. Thus the 
values of <cite>prediction_key</cite> must be of shape 
(number runs, number tokens)</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A CONLL formatted string where the format will be the 
following: <cite>TOKEN#GOLD LABEL#PREDICTION 1# PREDICTION 2</cite>
Where each token and relevant labels are on separate new 
lines. The first line will always contain the following:
<cite># {text_id: `value</cite>}` where the text_id represents the 
<cite>text_id</cite> of this TargetText, this will allow the CONLL
string to be uniquely identified back this TargetText 
object.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><a class="reference internal" href="#target_extraction.data_types_util.AnonymisedError" title="target_extraction.data_types_util.AnonymisedError"><strong>AnonymisedError</strong></a> – If the object has been anonymised then this 
method cannot be used.</p></li>
<li><p><strong>KeyError</strong> – If the the object has not be tokenized using 
<a class="reference internal" href="#target_extraction.data_types.TargetText.tokenize" title="target_extraction.data_types.TargetText.tokenize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tokenize()</span></code></a></p></li>
<li><p><strong>KeyError</strong> – If the <cite>prediction_key</cite> or <cite>gold_label_key</cite> do not 
exist.</p></li>
<li><p><strong>ValueError</strong> – If the <cite>gold_label_key</cite> or <cite>prediction_key</cite> values 
are not of the same length as the tokens, as the 
labels will not be able to match tokens etc.</p></li>
<li><p><strong>ValueError</strong> – If the values in <cite>prediction_key</cite> are not of shape 
(number runs, number tokens)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="target_extraction.data_types.TargetText.to_json">
<code class="sig-name descname">to_json</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/data_types.html#TargetText.to_json"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.data_types.TargetText.to_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Required as TargetText is not json serlizable due to the ‘spans’.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The object as a dictionary and then encoded using json.dumps</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="target_extraction.data_types.TargetText.tokenize">
<code class="sig-name descname">tokenize</code><span class="sig-paren">(</span><em class="sig-param">tokenizer</em>, <em class="sig-param">perform_type_checks=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/data_types.html#TargetText.tokenize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.data_types.TargetText.tokenize" title="Permalink to this definition">¶</a></dt>
<dd><p>This will add a new key <cite>tokenized_text</cite> to this TargetText instance
that will store the tokens of the text that is associated to this 
TargetText instance.</p>
<p>For a set of tokenizers that are definitely comptable see 
target_extraction.tokenizers module.</p>
<p>Ensures that the tokenization is character preserving.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tokenizer</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Callable</span></code>[[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>], <code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]]) – The tokenizer to use tokenize the text for each 
TargetText instance in the current collection</p></li>
<li><p><strong>perform_type_checks</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – Whether or not to perform type checks 
to ensure the tokenizer returns a List of 
Strings</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><a class="reference internal" href="#target_extraction.data_types_util.AnonymisedError" title="target_extraction.data_types_util.AnonymisedError"><strong>AnonymisedError</strong></a> – If the object has been anonymised then this 
method cannot be used.</p></li>
<li><p><strong>TypeError</strong> – If the tokenizer given does not return a List of 
Strings.</p></li>
<li><p><strong>ValueError</strong> – This is raised if the TargetText instance contains
empty text.</p></li>
<li><p><strong>ValueError</strong> – If the tokenization is not character preserving.</p></li>
</ul>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="target_extraction.data_types.TargetTextCollection">
<em class="property">class </em><code class="sig-prename descclassname">target_extraction.data_types.</code><code class="sig-name descname">TargetTextCollection</code><span class="sig-paren">(</span><em class="sig-param">target_texts=None</em>, <em class="sig-param">name=None</em>, <em class="sig-param">metadata=None</em>, <em class="sig-param">anonymised=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/data_types.html#TargetTextCollection"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.data_types.TargetTextCollection" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MutableMapping</span></code></p>
<p>This is a data structure that inherits from MutableMapping which is 
essentially a python dictionary, however the underlying storage is a 
OrderedDict therefore if you iterate over it, the iteration will always be 
in the same order.</p>
<p>This structure only contains TargetText instances.</p>
<p>Attributes:</p>
<ol class="arabic simple">
<li><p>name – Name associated to the TargetTextCollection.</p></li>
<li><p>metadata – Any metadata to associate to the object e.g. domain of the 
dataset, all metadata is stored in a dictionary. By default the 
metadata will always have the <cite>name</cite> attribute within 
the metadata under the key <cite>name</cite>. If <cite>anonymised</cite> is also True then 
this will also be in the metadata under the key <cite>anonymised</cite></p></li>
<li><p>anonymised – If True then the data within the TargetText objects have 
no text but the rest of the metadata should exist.</p></li>
</ol>
<p>Methods:</p>
<ol class="arabic simple">
<li><p>to_json – Writes each TargetText instances as a dictionary using it’s 
own to_json function on a new line within the returned String. The 
returned String is not json comptable but if split by new line it is and 
is also comptable with the from_json method of TargetText.</p></li>
<li><p>to_conll – A CONLL formatted string where the format will be the 
following: <cite>TOKEN#GOLD LABEL#PREDICTION 1# PREDICTION 2</cite> Where each 
token and relevant labels are on separate new lines. The first line 
will always contain the following: <cite># {text_id: `value</cite>}` where the 
text_id represents the <cite>text_id</cite> of this TargetText, this will allow 
the CONLL string to be uniquely identified back this TargetText 
object. Also each TargetText CONLL string will be seperated 
by a new line.</p></li>
<li><p>to_conll_file – Saves the TargetTextCollection to CONLL format. Useful
for Sequence Labelling tasks.</p></li>
<li><p>load_conll – Loads the CONLL information into the collection.</p></li>
<li><p>add – Wrapper around __setitem__. Given as an argument a TargetText 
instance it will be added to the collection.</p></li>
<li><p>to_json_file – Saves the current TargetTextCollection to a json file 
which won’t be strictly json but each line in the file will be and each 
line in the file can be loaded in from String via TargetText.from_json. 
Also the file can be reloaded into a TargetTextCollection using 
TargetTextCollection.load_json.</p></li>
<li><p>tokenize – This applies the TargetText.tokenize method across all 
of the TargetText instances within the collection.</p></li>
<li><dl class="simple">
<dt>pos_text – This applies the TargetText.pos_text method across all of </dt><dd><p>the TargetText instances within the collection.</p>
</dd>
</dl>
</li>
<li><p>sequence_labels – This applies the TargetText.sequence_labels 
method across all of the TargetText instances within the collection.</p></li>
<li><p>force_targets – This applies the TargetText.force_targets method 
across all of the TargetText instances within the collection.</p></li>
<li><p>exact_match_score – Recall, Precision, and F1 score in a Tuple. 
All of these measures are based on exact span matching rather than the 
matching of the sequence label tags, this is due to the annotation spans 
not always matching tokenization therefore this removes the tokenization 
error that can come from the sequence label measures.</p></li>
<li><p>samples_with_targets – Returns all of the samples that have target 
spans as a TargetTextCollection.</p></li>
<li><p>target_count – A dictionary of target text as key and values as the  
number of times the target text occurs in this TargetTextCollection</p></li>
<li><p>one_sample_per_span – This applies the TargetText.one_sample_per_span 
method across all of the TargetText instances within the collection to 
create a new collection with those new TargetText instances within it.</p></li>
<li><p>number_targets – Returns the total number of targets.</p></li>
<li><p>number_categories – Returns the total number of categories.</p></li>
<li><p>category_count – Returns a dictionary of categories as keys and 
values as the number of times the category occurs.</p></li>
<li><p>target_sentiments – A dictionary where the keys are target texts and 
the values are a List of sentiment values that have been associated to 
that target.</p></li>
<li><p>dict_iter – Returns an interator of all of the TargetText objects 
within the collection as dictionaries.</p></li>
<li><p>unique_distinct_sentiments – A set of the distinct sentiments within 
the collection. The length of the set represents the number of distinct 
sentiments within the collection.</p></li>
<li><p>de_anonymise – This will set the <cite>anonymised</cite> attribute to False 
from True and set the <cite>text</cite> key value to the value in the <cite>text</cite> 
key within the <cite>text_dict</cite> argument for each of the TargetTexts in 
the collection. If any Error is raised this collection will revert back
fully to being anonymised.</p></li>
<li><p>sanitize – This applies the TargetText.sanitize function to all of 
the TargetText instances within this collection, affectively ensures 
that all of the instances follow the specified rules that TargetText 
instances should follow.</p></li>
<li><p>in_order – This returns True if all TargetText objects within the 
collection contains a list of targets that are in order of appearance 
within the text from left to right e.g. if the only TargetText in the 
collection contains two targets where the first target in the <cite>targets</cite>
list is the first (left most) target in the text then this method would 
return True.</p></li>
<li><p>re_order – This will apply <a class="reference internal" href="#target_extraction.data_types.TargetText.re_order" title="target_extraction.data_types.TargetText.re_order"><code class="xref py py-meth docutils literal notranslate"><span class="pre">target_extraction.data_types.TargetText.re_order()</span></code></a>
to each TargetText within the collection.</p></li>
<li><p>add_unique_key – Applies the following 
<a class="reference internal" href="#target_extraction.data_types.TargetText.add_unique_key" title="target_extraction.data_types.TargetText.add_unique_key"><code class="xref py py-meth docutils literal notranslate"><span class="pre">target_extraction.data_types.TargetText.add_unique_key()</span></code></a> 
to each TargetText within this collection</p></li>
<li><p>key_difference – Given this collection and another it will return all
of the keys that the other collection contains which this does not.</p></li>
<li><p>combine_data_on_id – Given this collection and another it will add all
of the data from the other collection into this collection based on the 
unique key given.</p></li>
<li><p>one_sentiment_text – Adds the <cite>text_sentiment_key</cite> to each TargetText 
within the collection where the value will represent the sentiment value 
for the text based on the <cite>sentiment_key</cite> values and <cite>average_sentiment</cite> 
determining how to handle multiple sentiments. This will allow text level 
classifiers to be trained on target/aspect/category data.</p></li>
</ol>
<p>Static Functions:</p>
<ol class="arabic simple">
<li><p>from_json – Returns a TargetTextCollection object given the json like 
String from to_json. For example the json string can be the return of 
TargetTextCollection.to_json.</p></li>
<li><p>load_json – Returns a TargetTextCollection based on each new line in 
the given json file.</p></li>
<li><p>combine – Returns a TargetTextCollection that is the combination of all 
of those given.</p></li>
<li><p>same_data – Given a List of TargetTextCollections it will return a list 
of tuples specifying the overlap between the collections based on the 
samples <cite>text_id</cite> and <cite>text</cite> key values. If it returns an empty list 
then there are no overlap between the collections. This is useful to 
find duplicates beyond the <cite>text_id</cite> as it checks the <cite>text</cite> value as well.</p></li>
</ol>
<dl class="method">
<dt id="target_extraction.data_types.TargetTextCollection.add">
<code class="sig-name descname">add</code><span class="sig-paren">(</span><em class="sig-param">value</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/data_types.html#TargetTextCollection.add"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.data_types.TargetTextCollection.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper around set item. Instead of having to add the value the 
usual way of finding the instances ‘text_id’ and setting this containers
key to this value, it does this for you.</p>
<p>e.g. performs self[value[‘text_id’]] = value</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>value</strong> (<a class="reference internal" href="#target_extraction.data_types.TargetText" title="target_extraction.data_types.TargetText"><code class="xref py py-class docutils literal notranslate"><span class="pre">TargetText</span></code></a>) – The TargetText instance to store in the collection. Will 
anonymise the TargetText object if the collection’s 
anonymised attribute is True.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="target_extraction.data_types.TargetTextCollection.add_unique_key">
<code class="sig-name descname">add_unique_key</code><span class="sig-paren">(</span><em class="sig-param">id_key</em>, <em class="sig-param">id_key_name</em>, <em class="sig-param">id_delimiter='::'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/data_types.html#TargetTextCollection.add_unique_key"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.data_types.TargetTextCollection.add_unique_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies the following 
<a class="reference internal" href="#target_extraction.data_types.TargetText.add_unique_key" title="target_extraction.data_types.TargetText.add_unique_key"><code class="xref py py-meth docutils literal notranslate"><span class="pre">target_extraction.data_types.TargetText.add_unique_key()</span></code></a> 
to each TargetText within this collection</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>id_key</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – The name of the key within this TargetText that requires 
unique ids that will be stored in <cite>id_key_name</cite>.</p></li>
<li><p><strong>id_key_name</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – The name of the key to associate to these new 
unique ids.</p></li>
<li><p><strong>id_delimiter</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – The delimiter to seperate the <cite>text_id</cite> and the 
index of the <cite>id_key</cite> that is being represented 
by this unique id.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="target_extraction.data_types.TargetTextCollection.anonymised">
<em class="property">property </em><code class="sig-name descname">anonymised</code><a class="headerlink" href="#target_extraction.data_types.TargetTextCollection.anonymised" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>True if the data within the TargetTextCollection has been 
anonymised. Anonymised data means that there is no text 
associated with any of the TargetText objects within the 
collection, but all of the metadata is there.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="target_extraction.data_types.TargetTextCollection.category_count">
<code class="sig-name descname">category_count</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/data_types.html#TargetTextCollection.category_count"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.data_types.TargetTextCollection.category_count" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Dict</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A dictionary of categories as keys and values as the number 
of times the category occurs in this TargetTextCollection</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If any category has the value of None.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="target_extraction.data_types.TargetTextCollection.combine">
<em class="property">static </em><code class="sig-name descname">combine</code><span class="sig-paren">(</span><em class="sig-param">*collections</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/data_types.html#TargetTextCollection.combine"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.data_types.TargetTextCollection.combine" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>collections</strong> – An iterator containing one or more 
TargetTextCollections</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#target_extraction.data_types.TargetTextCollection" title="target_extraction.data_types.TargetTextCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">TargetTextCollection</span></code></a></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A TargetTextCollection that is the combination of all of 
those given.</p>
</dd>
<dt class="field-even">NOTE</dt>
<dd class="field-even"><p>If any of the collections are anonymised then the returned 
collection will also be anonymised, even if only one of the 
collections has been anonymised.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="target_extraction.data_types.TargetTextCollection.combine_data_on_id">
<code class="sig-name descname">combine_data_on_id</code><span class="sig-paren">(</span><em class="sig-param">other_collection</em>, <em class="sig-param">id_key</em>, <em class="sig-param">data_keys</em>, <em class="sig-param">raise_on_overwrite=True</em>, <em class="sig-param">check_same_ids=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/data_types.html#TargetTextCollection.combine_data_on_id"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.data_types.TargetTextCollection.combine_data_on_id" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>other_collection</strong> (<a class="reference internal" href="#target_extraction.data_types.TargetTextCollection" title="target_extraction.data_types.TargetTextCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">TargetTextCollection</span></code></a>) – The collection that contains the data 
that is to be copied to this collection.</p></li>
<li><p><strong>id_key</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – The key that indicates in each TargetText within 
this and the <cite>other_collection</cite> how the values are 
to be copied from the <cite>other_collection</cite> to this 
collection.</p></li>
<li><p><strong>data_keys</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]) – The keys of the values in each TargetText within the 
<cite>other_collection</cite> that is be copied to the relevant 
TargetTexts within this collection. It assumes that if
any of key/values are a list of lists that the inner 
lists relate to the targets and the outer list is 
not related to the targets.</p></li>
<li><p><strong>raise_on_overwrite</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – If True will raise the 
<a class="reference internal" href="#target_extraction.data_types_util.OverwriteError" title="target_extraction.data_types_util.OverwriteError"><code class="xref py py-class docutils literal notranslate"><span class="pre">target_extraction.data_types_util.OverwriteError</span></code></a> 
if any of the <cite>data_keys</cite> exist in any 
of the TargetTexts within this collection.</p></li>
<li><p><strong>check_same_ids</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – If True will ensure that this collection and the 
other collection are of same length and check 
if each have the same unique ids</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>AssertionError</strong> – If the number of IDs from the <cite>id_key</cite> does not 
match the number of data to be added to a data key</p></li>
<li><p><strong>ValueError</strong> – If <cite>check_same_ids</cite> is True and the two collections 
are either of not the same length or have  
different unique ids according to <cite>id_key</cite> within 
the TargetText objects.</p></li>
<li><p><a class="reference internal" href="#target_extraction.data_types_util.OverwriteError" title="target_extraction.data_types_util.OverwriteError"><strong>OverwriteError</strong></a> – If <cite>raise_on_overwrite</cite> is True and the any of 
the <cite>data_keys</cite> exist in any of the TargetTexts
within this collection.</p></li>
</ul>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="target_extraction.data_types.TargetTextCollection.de_anonymise">
<code class="sig-name descname">de_anonymise</code><span class="sig-paren">(</span><em class="sig-param">text_dicts</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/data_types.html#TargetTextCollection.de_anonymise"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.data_types.TargetTextCollection.de_anonymise" title="Permalink to this definition">¶</a></dt>
<dd><p>This will set the <cite>anonymised</cite> attribute to False 
from True and set the <cite>text</cite> key value to the value in the <cite>text</cite> 
key within the <cite>text_dict</cite> argument for each of the TargetTexts in 
the collection. If any Error is raised this collection will revert back
fully to being anonymised.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>text_dicts</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Dict</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]]) – An iterable of dictionaries that contain the following 
two keys: 1. <cite>text</cite> and 2. <cite>text_id</cite> where 
the <cite>text_id</cite> has to be a key within the current 
collection. The <cite>text</cite> associated to that id will 
become that TargetText object’s text value.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – If the length of the <cite>text_dicts</cite> does not match 
that of the collection.</p></li>
<li><p><strong>KeyError</strong> – If any of the <cite>text_id`s in the `text_dicts</cite> do not 
match those within this collection.</p></li>
</ul>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="target_extraction.data_types.TargetTextCollection.dict_iterator">
<code class="sig-name descname">dict_iterator</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/data_types.html#TargetTextCollection.dict_iterator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.data_types.TargetTextCollection.dict_iterator" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Dict</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, <code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code>]]</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An interator of all of the TargetText objects 
within the collection as dictionaries.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="target_extraction.data_types.TargetTextCollection.exact_match_score">
<code class="sig-name descname">exact_match_score</code><span class="sig-paren">(</span><em class="sig-param">predicted_sequence_key='predicted_sequence_labels'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/data_types.html#TargetTextCollection.exact_match_score"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.data_types.TargetTextCollection.exact_match_score" title="Permalink to this definition">¶</a></dt>
<dd><p>Just for clarification we use the sequence label tags to find the 
predicted spans. However even if you have a perfect sequence label 
score does not mean you will have a perfect extact span score 
as the tokenizer used for the sequence labelling might not align 
perfectly with the annotated spans.</p>
<p>The False Positive mistakes, False Negative mistakes, and correct
True Positive Dictionary keys are those names with the values neing a 
List of Tuples where the Tuple is made up of the TargetText instance ID 
and the Span that was incorrect (FP) or not tagged (FN) or correct (TP).
Example of this is as follows:
{<cite>FP</cite>: [(‘1’, Span(0, 4))], ‘FN’: [], ‘TP’: []}</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>predicted_sequence_key</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – Key of the predicted sequence labels 
within this TargetText instance.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Dict</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, <a class="reference internal" href="#target_extraction.data_types_util.Span" title="target_extraction.data_types_util.Span"><code class="xref py py-class docutils literal notranslate"><span class="pre">Span</span></code></a>]]]]</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Recall, Precision, and F1 score, False Positive mistakes, 
False Negative mistakes, and correct True Positives in a 
Dict. All of these measures are based on exact span matching 
rather than the matching of the sequence label tags, 
this is due to the annotation spans not always matching 
tokenization therefore this removes the tokenization 
error that can come from the sequence label measures.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>KeyError</strong> – If there are no predicted sequence label key 
within this TargetText.</p></li>
<li><p><strong>ValueError</strong> – If the predicted or true spans contain multiple 
spans that have the same span e.g. 
[Span(4, 15), Span(4, 15)]</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="target_extraction.data_types.TargetTextCollection.force_targets">
<code class="sig-name descname">force_targets</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/data_types.html#TargetTextCollection.force_targets"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.data_types.TargetTextCollection.force_targets" title="Permalink to this definition">¶</a></dt>
<dd><p>This applies the TargetText.force_targets method across all of the 
TargetText instances within the collection.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="target_extraction.data_types.TargetTextCollection.from_json">
<em class="property">static </em><code class="sig-name descname">from_json</code><span class="sig-paren">(</span><em class="sig-param">json_text</em>, <em class="sig-param">**target_text_collection_kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/data_types.html#TargetTextCollection.from_json"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.data_types.TargetTextCollection.from_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Required as the json text is expected to be the return from the 
self.to_json method. This string is not passable by a standard json 
decoder.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>json_text</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – This is expected to be a dictionary like object for 
each new line in this text</p></li>
<li><p><strong>target_text_collection_kwargs</strong> – Key word arguments to give to 
the TargetTextCollection 
constructor.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#target_extraction.data_types.TargetTextCollection" title="target_extraction.data_types.TargetTextCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">TargetTextCollection</span></code></a></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A TargetTextCollection based on each new line in the given 
text to be passable by TargetText.from_json method.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><a class="reference internal" href="#target_extraction.data_types_util.AnonymisedError" title="target_extraction.data_types_util.AnonymisedError"><strong>AnonymisedError</strong></a> – If the <cite>TargetText</cite> object that it is loading 
is anonymised but the <cite>target_text_collection_kwargs</cite>
argument contains <cite>anonymised</cite> False, as 
you cannot de-anonymised without performing 
the 
<code class="xref py py-meth docutils literal notranslate"><span class="pre">target_extraction.data_types.TargetTextCollection.de_anonymised()</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="target_extraction.data_types.TargetTextCollection.in_order">
<code class="sig-name descname">in_order</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/data_types.html#TargetTextCollection.in_order"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.data_types.TargetTextCollection.in_order" title="Permalink to this definition">¶</a></dt>
<dd><p>This returns True if all TargetText objects within the 
collection contains a list of targets that are in order of appearance 
within the text from left to right e.g. if the only TargetText in the 
collection contains two targets where the first target in the <cite>targets</cite>
list is the first (left most) target in the text then this method would 
return True.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>True if all the <cite>targets</cite> within all the TargetText objects 
in this collection are in sequential left to right order 
within the text.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="target_extraction.data_types.TargetTextCollection.key_difference">
<code class="sig-name descname">key_difference</code><span class="sig-paren">(</span><em class="sig-param">other_collection</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/data_types.html#TargetTextCollection.key_difference"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.data_types.TargetTextCollection.key_difference" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>other_collection</strong> (<a class="reference internal" href="#target_extraction.data_types.TargetTextCollection" title="target_extraction.data_types.TargetTextCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">TargetTextCollection</span></code></a>) – The collection that is being compared to this.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A list of keys that represent all of the keys that are in the 
other (compared) collection and not in this collection.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="target_extraction.data_types.TargetTextCollection.load_conll">
<code class="sig-name descname">load_conll</code><span class="sig-paren">(</span><em class="sig-param">conll_fp</em>, <em class="sig-param">tokens_key='tokenized_text'</em>, <em class="sig-param">gold_label_key=None</em>, <em class="sig-param">prediction_key=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/data_types.html#TargetTextCollection.load_conll"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.data_types.TargetTextCollection.load_conll" title="Permalink to this definition">¶</a></dt>
<dd><p>This takes the <cite>conll_fp</cite> and loads the CONLL data into the relevant 
TargetText samples in this collection using the TargetText <cite>from_conll</cite>
function. The matching of TargetText with CONLL data is through the CONLL
string containing <cite># {text_id: _id}</cite> for each CONLL sentence/text.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tokens_key</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – Key to save the CONLL tokens too, for the TargetText.</p></li>
<li><p><strong>gold_label_key</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]) – Key to save the gold labels too. Either 
<cite>gold_label_key</cite> or <cite>prediction_key</cite> must not be 
<cite>None</cite> or both not <cite>None</cite>, for the TargetText.</p></li>
<li><p><strong>prediction_key</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]) – Key to save the prediction labels too. The value 
will be of shape (number runs, number tokens), 
for the TargetText.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="target_extraction.data_types.TargetTextCollection.load_json">
<em class="property">static </em><code class="sig-name descname">load_json</code><span class="sig-paren">(</span><em class="sig-param">json_fp</em>, <em class="sig-param">**target_text_collection_kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/data_types.html#TargetTextCollection.load_json"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.data_types.TargetTextCollection.load_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Allows loading a dataset from json. Where the json file is expected to 
be output from TargetTextCollection.to_json_file as the file will be 
a json String on each line generated from TargetText.to_json. This 
will also load any meta data that was stored within the TargetTextCollection.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>json_fp</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code>) – File that contains json strings generated from 
TargetTextCollection.to_json_file</p></li>
<li><p><strong>target_text_collection_kwargs</strong> – Key word arguments to give to 
the TargetTextCollection 
constructor. If there was
any meta data stored within the 
loaded json then these key word 
arguments would over ride the 
meta data stored.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#target_extraction.data_types.TargetTextCollection" title="target_extraction.data_types.TargetTextCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">TargetTextCollection</span></code></a></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A TargetTextCollection based on each new line in the given 
json file, and the optional meta data on the last line.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="target_extraction.data_types.TargetTextCollection.name">
<em class="property">property </em><code class="sig-name descname">name</code><a class="headerlink" href="#target_extraction.data_types.TargetTextCollection.name" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The name attribute.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="target_extraction.data_types.TargetTextCollection.number_categories">
<code class="sig-name descname">number_categories</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/data_types.html#TargetTextCollection.number_categories"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.data_types.TargetTextCollection.number_categories" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The total number of categories in the collection</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If one of the category values in the list is of 
value None</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="target_extraction.data_types.TargetTextCollection.number_targets">
<code class="sig-name descname">number_targets</code><span class="sig-paren">(</span><em class="sig-param">incl_none_targets=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/data_types.html#TargetTextCollection.number_targets"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.data_types.TargetTextCollection.number_targets" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>incl_none_targets</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – Whether to include targets that are <cite>None</cite>
and are therefore associated to the categories 
in the count.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The total number of targets in the collection.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="target_extraction.data_types.TargetTextCollection.one_sample_per_span">
<code class="sig-name descname">one_sample_per_span</code><span class="sig-paren">(</span><em class="sig-param">remove_empty=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/data_types.html#TargetTextCollection.one_sample_per_span"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.data_types.TargetTextCollection.one_sample_per_span" title="Permalink to this definition">¶</a></dt>
<dd><p>This applies the TargetText.one_sample_per_span method across all of the 
TargetText instances within the collection to create a new collection 
with those new TargetText instances within it.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>remove_empty</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – If the TargetText instance contains any None 
targets then these will be removed along with 
their respective Spans.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#target_extraction.data_types.TargetTextCollection" title="target_extraction.data_types.TargetTextCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">TargetTextCollection</span></code></a></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A new TargetTextCollection that has samples that come 
from this collection but has had the 
TargetText.one_sample_per_span method applied to it.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="target_extraction.data_types.TargetTextCollection.one_sentiment_text">
<code class="sig-name descname">one_sentiment_text</code><span class="sig-paren">(</span><em class="sig-param">sentiment_key</em>, <em class="sig-param">average_sentiment=False</em>, <em class="sig-param">text_sentiment_key='text_sentiment'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/data_types.html#TargetTextCollection.one_sentiment_text"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.data_types.TargetTextCollection.one_sentiment_text" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds the <cite>text_sentiment_key</cite> to each TargetText within the collection 
where the value will represent the sentiment value for the text based 
on the <cite>sentiment_key</cite> values and <cite>average_sentiment</cite> determining how 
to handle multiple sentiments. This will allow text level classifiers 
to be trained on target/aspect/category data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sentiment_key</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – The key in the TargetTexts that represent the 
sentiment for the TargetTexts sentence.</p></li>
<li><p><strong>average_sentiment</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – If False it will only add the <cite>text_sentiment_key</cite> 
to TargetTexts that have one unique sentiment in the 
<cite>sentiment_key</cite> e.g. can have more than one sentiment
value in the <cite>sentiment_key</cite> but each one of 
those values has to be the same value. If True 
it will choose the 
most frequent sentiment , ties are decided 
by random choice. If the there are no 
values in <cite>sentiment_key</cite> then 
<cite>text_sentiment_key</cite> will not be added to 
the TargetText.</p></li>
<li><p><strong>text_sentiment_key</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – The key to add the text level sentiment value 
to.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="target_extraction.data_types.TargetTextCollection.pos_text">
<code class="sig-name descname">pos_text</code><span class="sig-paren">(</span><em class="sig-param">tagger</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/data_types.html#TargetTextCollection.pos_text"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.data_types.TargetTextCollection.pos_text" title="Permalink to this definition">¶</a></dt>
<dd><p>This applies the TargetText.pos_text method across all of 
the TargetText instances within the collection.</p>
<p>For a set of pos taggers that are definetly comptable see 
target_extraction.pos_taggers module.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>tagger</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Callable</span></code>[[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>], <code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]]) – POS tagger.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> – If the POS tagger given does not return a List of 
Strings.</p></li>
<li><p><strong>ValueError</strong> – This is raised if any of the TargetText instances 
in the collection contain an empty string.</p></li>
<li><p><strong>ValueError</strong> – If the Target Text instance has not been tokenized.</p></li>
<li><p><strong>ValueError</strong> – If the number of pos tags for a Target Text instance
does not have the same number of tokens that has 
been generated by the tokenizer function.</p></li>
</ul>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="target_extraction.data_types.TargetTextCollection.re_order">
<code class="sig-name descname">re_order</code><span class="sig-paren">(</span><em class="sig-param">keys_not_to_order=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/data_types.html#TargetTextCollection.re_order"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.data_types.TargetTextCollection.re_order" title="Permalink to this definition">¶</a></dt>
<dd><p>This will apply <a class="reference internal" href="#target_extraction.data_types.TargetText.re_order" title="target_extraction.data_types.TargetText.re_order"><code class="xref py py-meth docutils literal notranslate"><span class="pre">target_extraction.data_types.TargetText.re_order()</span></code></a>
to each TargetText within the collection.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>keys_not_to_order</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]]) – Any keys within the TargetTexts that do not 
need re-ordering</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="target_extraction.data_types.TargetTextCollection.same_data">
<em class="property">static </em><code class="sig-name descname">same_data</code><span class="sig-paren">(</span><em class="sig-param">collections</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/data_types.html#TargetTextCollection.same_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.data_types.TargetTextCollection.same_data" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>collections</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<a class="reference internal" href="#target_extraction.data_types.TargetTextCollection" title="target_extraction.data_types.TargetTextCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">TargetTextCollection</span></code></a>]) – A list of TargetTextCollections to test if there are 
any duplicates based on <cite>text_id</cite> and <cite>text</cite> key 
values.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Tuple</span></code>[<a class="reference internal" href="#target_extraction.data_types.TargetText" title="target_extraction.data_types.TargetText"><code class="xref py py-class docutils literal notranslate"><span class="pre">TargetText</span></code></a>, <a class="reference internal" href="#target_extraction.data_types.TargetText" title="target_extraction.data_types.TargetText"><code class="xref py py-class docutils literal notranslate"><span class="pre">TargetText</span></code></a>]], <code class="xref py py-class docutils literal notranslate"><span class="pre">Tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]]]</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>If the list is empty then there are no duplicates. Else a list of
tuples containing 1. A list of tuples of duplicate TargetText instances 
2. A tuple of collection names that the TargetText have come stating 
the names of the collections that have the duplicates.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="target_extraction.data_types.TargetTextCollection.samples_with_targets">
<code class="sig-name descname">samples_with_targets</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/data_types.html#TargetTextCollection.samples_with_targets"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.data_types.TargetTextCollection.samples_with_targets" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#target_extraction.data_types.TargetTextCollection" title="target_extraction.data_types.TargetTextCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">TargetTextCollection</span></code></a></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>All of the samples that have targets as a 
TargetTextCollection for this TargetTextCollection.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>KeyError</strong> – If either <cite>spans</cite> or <cite>targets</cite> does not exist in 
one or more of the TargetText instances within this 
collection. These key’s are protected keys thus they
should always exist but this is just a warning if 
you have got around the protected keys.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="target_extraction.data_types.TargetTextCollection.sanitize">
<code class="sig-name descname">sanitize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/data_types.html#TargetTextCollection.sanitize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.data_types.TargetTextCollection.sanitize" title="Permalink to this definition">¶</a></dt>
<dd><p>This applies the TargetText.sanitize function to all of 
the TargetText instances within this collection, affectively ensures 
that all of the instances follow the specified rules that TargetText 
instances should follow.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="target_extraction.data_types.TargetTextCollection.sequence_labels">
<code class="sig-name descname">sequence_labels</code><span class="sig-paren">(</span><em class="sig-param">return_errors=False</em>, <em class="sig-param">**target_sequence_label_kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/data_types.html#TargetTextCollection.sequence_labels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.data_types.TargetTextCollection.sequence_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>This applies the TargetText.sequence_labels method across all of 
the TargetText instances within the collection.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>return_errors</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – Returns TargetText objects that have caused 
the ValueError to be raised.</p></li>
<li><p><strong>target_sequence_label_kwargs</strong> – Any Keyword arguments to give to 
the TargetText <cite>sequence_labels</cite>
function.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<a class="reference internal" href="#target_extraction.data_types.TargetText" title="target_extraction.data_types.TargetText"><code class="xref py py-class docutils literal notranslate"><span class="pre">TargetText</span></code></a>]</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A list of TargetText objects that have caused the ValueError 
to be raised if <cite>return_errors</cite> is True else an empty list 
will be returned.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>KeyError</strong> – If the current TargetText has not been tokenized.</p></li>
<li><p><strong>ValueError</strong> – If two targets overlap the same token(s) e.g 
<cite>Laptop cover was great</cite> if <cite>Laptop</cite> and 
<cite>Laptop cover</cite> are two seperate targets this should 
riase a ValueError as a token should only be 
associated to one target.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="target_extraction.data_types.TargetTextCollection.target_count">
<code class="sig-name descname">target_count</code><span class="sig-paren">(</span><em class="sig-param">lower=False</em>, <em class="sig-param">target_key='targets'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/data_types.html#TargetTextCollection.target_count"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.data_types.TargetTextCollection.target_count" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Note</dt>
<dd class="field-odd"><p>The target can not exist e.g. be a <cite>None</cite> target as the target 
can be combined with the category like in the SemEval 2016 
Restaurant dataset. In these case we do not include these 
in the target_count.</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>lower</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – Whether or not to lower the target text.</p></li>
<li><p><strong>target_key</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – The key in each TargetText sample that contains the 
list of target words.</p></li>
</ul>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Dict</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A dictionary of target text as key and values as the number 
of times the target text occurs in this TargetTextCollection</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="target_extraction.data_types.TargetTextCollection.target_sentiments">
<code class="sig-name descname">target_sentiments</code><span class="sig-paren">(</span><em class="sig-param">lower=False</em>, <em class="sig-param">unique_sentiment=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/data_types.html#TargetTextCollection.target_sentiments"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.data_types.TargetTextCollection.target_sentiments" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Note</dt>
<dd class="field-odd"><p>The target can not exist e.g. be a <cite>None</cite> target as the target 
can be combined with the category like in the SemEval 2016 
Restaurant dataset. In these case we do not include these 
in the target_count.</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>lower</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – Whether or not to lower the target text.</p></li>
<li><p><strong>unique_sentiment</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – Whether or not the return is a dictionary  
whose values are a List of Strings or if 
True a Set of Strings.</p></li>
</ul>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Dict</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, <code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>], <code class="xref py py-class docutils literal notranslate"><span class="pre">Set</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]]]</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A dictionary where the keys are target texts and the values 
are a List of sentiment values that have been associated to 
that target. The sentiment value can occur more than once 
indicating the number of times that target has been associated 
with that sentiment unless unique_sentiment is True then 
instead of a List of sentiment values a Set is used instead.</p>
</dd>
<dt class="field-odd">Explanation</dt>
<dd class="field-odd"><p>If the target <cite>camera</cite> has occured with the sentiment 
<cite>positive</cite> twice and <cite>negative</cite> once then it will return 
{<cite>camera</cite>: [<cite>positive</cite>, <cite>positive</cite>, <cite>negative</cite>]}. However
if <cite>unique_sentiment</cite> is True then it will return:
{<cite>camera</cite>: {<cite>positive</cite>, <cite>negative</cite>}}.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="target_extraction.data_types.TargetTextCollection.to_conll">
<code class="sig-name descname">to_conll</code><span class="sig-paren">(</span><em class="sig-param">gold_label_key</em>, <em class="sig-param">prediction_key=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/data_types.html#TargetTextCollection.to_conll"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.data_types.TargetTextCollection.to_conll" title="Permalink to this definition">¶</a></dt>
<dd><p>This in affect performs the <cite>to_conll</cite> function for each TargetText 
within the collection and seperates each on the CONLL strings with a 
new line.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>gold_label</strong> – A key that contains a sequence of labels e.g. 
[<cite>B</cite>, <cite>I</cite>, <cite>O</cite>]. This can come from the return 
of the <a class="reference internal" href="#target_extraction.data_types.TargetTextCollection.sequence_labels" title="target_extraction.data_types.TargetTextCollection.sequence_labels"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sequence_labels()</span></code></a></p></li>
<li><p><strong>prediction_key</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]) – Key to the predicted labels of the <cite>gold_label</cite>. 
Where the prediction key values is a list of a 
list of predicted labels. Each list is therefore 
a different model run hence creating the 
<cite>PREDICTION 1</cite>, ‘PREDICTION 2’ etc. Thus the 
values of <cite>prediction_key</cite> must be of shape 
(number runs, number tokens)</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A CONLL formatted string where the format will be the 
following: <cite>TOKEN#GOLD LABEL#PREDICTION 1# PREDICTION 2</cite>
Where each token and relevant labels are on separate new 
lines. The first line will always contain the following:
<cite># {text_id: `value</cite>}` where the text_id represents the 
<cite>text_id</cite> of this TargetText, this will allow the CONLL
string to be uniquely identified back this TargetText 
object. Also each TargetText CONLL string will be seperated 
by a new line.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="target_extraction.data_types.TargetTextCollection.to_conll_file">
<code class="sig-name descname">to_conll_file</code><span class="sig-paren">(</span><em class="sig-param">conll_fp</em>, <em class="sig-param">gold_label_key</em>, <em class="sig-param">prediction_key=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/data_types.html#TargetTextCollection.to_conll_file"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.data_types.TargetTextCollection.to_conll_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes the ouput of <cite>to_conll</cite> to the <cite>conll_fp</cite> file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>conll_fp</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code>) – Write the CONLL string to this file path.</p></li>
<li><p><strong>gold_label</strong> – A key that contains a sequence of labels e.g. 
[<cite>B</cite>, <cite>I</cite>, <cite>O</cite>]. This can come from the return 
of the <a class="reference internal" href="#target_extraction.data_types.TargetTextCollection.sequence_labels" title="target_extraction.data_types.TargetTextCollection.sequence_labels"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sequence_labels()</span></code></a></p></li>
<li><p><strong>prediction_key</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]) – Key to the predicted labels of the <cite>gold_label</cite>. 
Where the prediction key values is a list of a 
list of predicted labels. Each list is therefore 
a different model run hence creating the 
<cite>PREDICTION 1</cite>, ‘PREDICTION 2’ etc. Thus the 
values of <cite>prediction_key</cite> must be of shape 
(number runs, number tokens)</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="target_extraction.data_types.TargetTextCollection.to_json">
<code class="sig-name descname">to_json</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/data_types.html#TargetTextCollection.to_json"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.data_types.TargetTextCollection.to_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Required as TargetTextCollection is not json serlizable due to the 
‘spans’ in the TargetText instances.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The object as a list of dictionaries where each the TargetText
instances are dictionaries. It will also JSON serialize any 
meta data as well.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="target_extraction.data_types.TargetTextCollection.to_json_file">
<code class="sig-name descname">to_json_file</code><span class="sig-paren">(</span><em class="sig-param">json_fp</em>, <em class="sig-param">include_metadata=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/data_types.html#TargetTextCollection.to_json_file"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.data_types.TargetTextCollection.to_json_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Saves the current TargetTextCollection to a json file which won’t be 
strictly json but each line in the file will be and each line in the 
file can be loaded in from String via TargetText.from_json. Also the 
file can be reloaded into a TargetTextCollection using 
TargetTextCollection.load_json.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>json_fp</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code>) – File path to the json file to save the current data to.</p></li>
<li><p><strong>include_metadata</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – Whether or not to include the metadata when 
writing to file.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="target_extraction.data_types.TargetTextCollection.tokenize">
<code class="sig-name descname">tokenize</code><span class="sig-paren">(</span><em class="sig-param">tokenizer</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/data_types.html#TargetTextCollection.tokenize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.data_types.TargetTextCollection.tokenize" title="Permalink to this definition">¶</a></dt>
<dd><p>This applies the TargetText.tokenize method across all of 
the TargetText instances within the collection.</p>
<p>For a set of tokenizers that are definetly comptable see 
target_extraction.tokenizers module.</p>
<p>Ensures that the tokenization is character preserving.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>tokenizer</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Callable</span></code>[[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>], <code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]]) – The tokenizer to use tokenize the text for each 
TargetText instance in the current collection</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> – If the tokenizer given does not return a List of 
Strings.</p></li>
<li><p><strong>ValueError</strong> – This is raised if any of the TargetText instances 
in the collection contain an empty string.</p></li>
<li><p><strong>ValueError</strong> – If the tokenization is not character preserving.</p></li>
</ul>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="target_extraction.data_types.TargetTextCollection.unique_distinct_sentiments">
<code class="sig-name descname">unique_distinct_sentiments</code><span class="sig-paren">(</span><em class="sig-param">sentiment_key='target_sentiments'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/data_types.html#TargetTextCollection.unique_distinct_sentiments"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.data_types.TargetTextCollection.unique_distinct_sentiments" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>sentiment_key</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – The key that represents the sentiment value 
for each TargetText object</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Set</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A set of the distinct sentiments within the collection. 
The length of the set represents the number of distinct 
sentiments within the collection.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>TypeError</strong> – If the value in the sentiment_key is not of type list</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="target_extraction.data_types.check_anonymised">
<code class="sig-prename descclassname">target_extraction.data_types.</code><code class="sig-name descname">check_anonymised</code><span class="sig-paren">(</span><em class="sig-param">func</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/data_types.html#check_anonymised"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.data_types.check_anonymised" title="Permalink to this definition">¶</a></dt>
<dd><p>Assumes the first argument in the given function is a TargetText object 
defined by self.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference internal" href="#target_extraction.data_types_util.AnonymisedError" title="target_extraction.data_types_util.AnonymisedError"><strong>AnonymisedError</strong></a> – If the TargetText object given to <cite>func</cite> 
<cite>anonymised</cite> attribute is True.</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-target_extraction.data_types_util">
<span id="target-extraction-data-types-util-module"></span><h2>target_extraction.data_types_util module<a class="headerlink" href="#module-target_extraction.data_types_util" title="Permalink to this headline">¶</a></h2>
<p>Module that contains helpful classes and methods for 
<cite>target_extraction.data_types</cite></p>
<p>classes:</p>
<ol class="arabic simple">
<li><p>Span</p></li>
<li><p>OverLappingTargetsError</p></li>
<li><p>AnonymisedError</p></li>
<li><p>OverwriteError</p></li>
</ol>
<dl class="exception">
<dt id="target_extraction.data_types_util.AnonymisedError">
<em class="property">exception </em><code class="sig-prename descclassname">target_extraction.data_types_util.</code><code class="sig-name descname">AnonymisedError</code><span class="sig-paren">(</span><em class="sig-param">error_string</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/data_types_util.html#AnonymisedError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.data_types_util.AnonymisedError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code></p>
<p>If the something cannot be performed because the 
<a class="reference internal" href="#target_extraction.data_types.TargetText" title="target_extraction.data_types.TargetText"><code class="xref py py-class docutils literal notranslate"><span class="pre">target_extraction.data_types.TargetText</span></code></a> 
or <a class="reference internal" href="#target_extraction.data_types.TargetTextCollection" title="target_extraction.data_types.TargetTextCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">target_extraction.data_types.TargetTextCollection</span></code></a> 
object has been anonymised.</p>
</dd></dl>

<dl class="exception">
<dt id="target_extraction.data_types_util.OverLappingTargetsError">
<em class="property">exception </em><code class="sig-prename descclassname">target_extraction.data_types_util.</code><code class="sig-name descname">OverLappingTargetsError</code><a class="reference internal" href="_modules/target_extraction/data_types_util.html#OverLappingTargetsError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.data_types_util.OverLappingTargetsError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code></p>
<p>If two targets within the same sentence overlap with each other when they 
shouldn’t.</p>
</dd></dl>

<dl class="exception">
<dt id="target_extraction.data_types_util.OverwriteError">
<em class="property">exception </em><code class="sig-prename descclassname">target_extraction.data_types_util.</code><code class="sig-name descname">OverwriteError</code><span class="sig-paren">(</span><em class="sig-param">error_string</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/data_types_util.html#OverwriteError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.data_types_util.OverwriteError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code></p>
<p>If some key exists in a dictionary like object and the intended action 
is to write data to that key when it should not then this error is raised 
to indicate this action was going to be performed.</p>
</dd></dl>

<dl class="class">
<dt id="target_extraction.data_types_util.Span">
<em class="property">class </em><code class="sig-prename descclassname">target_extraction.data_types_util.</code><code class="sig-name descname">Span</code><a class="reference internal" href="_modules/target_extraction/data_types_util.html#Span"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.data_types_util.Span" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></p>
<p>Span is a named tuple. It has two fields:</p>
<ol class="arabic simple">
<li><p>start – An integer that specifies the start of a target word within a 
text.</p></li>
<li><p>end – An integer that specifies the end of a target word within a text.</p></li>
</ol>
<dl class="method">
<dt id="target_extraction.data_types_util.Span.end">
<em class="property">property </em><code class="sig-name descname">end</code><a class="headerlink" href="#target_extraction.data_types_util.Span.end" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 1</p>
</dd></dl>

<dl class="method">
<dt id="target_extraction.data_types_util.Span.start">
<em class="property">property </em><code class="sig-name descname">start</code><a class="headerlink" href="#target_extraction.data_types_util.Span.start" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 0</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-target_extraction.dataset_parsers">
<span id="target-extraction-dataset-parsers-module"></span><h2>target_extraction.dataset_parsers module<a class="headerlink" href="#module-target_extraction.dataset_parsers" title="Permalink to this headline">¶</a></h2>
<p>This module contains all the functions that will parse a particular dataset
into a <cite>target_extraction.data_types.TargetTextCollection</cite> object.</p>
<p>Functions:</p>
<ol class="arabic simple">
<li><p>semeval_2014</p></li>
</ol>
<dl class="data">
<dt id="target_extraction.dataset_parsers.CACHE_DIRECTORY">
<code class="sig-prename descclassname">target_extraction.dataset_parsers.</code><code class="sig-name descname">CACHE_DIRECTORY</code><em class="property"> = PosixPath('/home/travis/.bella_tdsa')</em><a class="headerlink" href="#target_extraction.dataset_parsers.CACHE_DIRECTORY" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="target_extraction.dataset_parsers.download_election_folder">
<code class="sig-prename descclassname">target_extraction.dataset_parsers.</code><code class="sig-name descname">download_election_folder</code><span class="sig-paren">(</span><em class="sig-param">cache_dir=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/dataset_parsers.html#download_election_folder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.dataset_parsers.download_election_folder" title="Permalink to this definition">¶</a></dt>
<dd><p>Downloads the data for the Election Twitter dataset by 
<cite>Wang et al, 2017 &lt;https://www.aclweb.org/anthology/E17-1046&gt;</cite> that can be found 
<a class="reference external" href="https://figshare.com/articles/EACL_2017_-_Multi-target_UK_election_Twitter_sentiment_corpus/4479563/1">here</a></p>
<p>This is then further used in the following functions
<a class="reference internal" href="#target_extraction.dataset_parsers.wang_2017_election_twitter_train" title="target_extraction.dataset_parsers.wang_2017_election_twitter_train"><code class="xref py py-func docutils literal notranslate"><span class="pre">target_extraction.dataset_parsers.wang_2017_election_twitter_train()</span></code></a>
and 
<a class="reference internal" href="#target_extraction.dataset_parsers.wang_2017_election_twitter_test" title="target_extraction.dataset_parsers.wang_2017_election_twitter_test"><code class="xref py py-func docutils literal notranslate"><span class="pre">target_extraction.dataset_parsers.wang_2017_election_twitter_test()</span></code></a>
as a way to get the data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>cache_dir</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code>]) – The directory where all of the data is stored for 
this code base. If None then the cache directory is
<cite>dataset_parsers.CACHE_DIRECTORY</cite></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The Path to the <cite>Wang 2017 Election Twitter</cite> folder within the 
<cite>cache_dir</cite>.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>FileNotFoundError</strong> – If not all of files where downloaded the first 
time. Will require the user to delete either 
the cache directory or the 
<cite>Wang 2017 Election Twitter</cite> folder within the 
cache directory.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="target_extraction.dataset_parsers.multi_aspect_multi_sentiment_acsa">
<code class="sig-prename descclassname">target_extraction.dataset_parsers.</code><code class="sig-name descname">multi_aspect_multi_sentiment_acsa</code><span class="sig-paren">(</span><em class="sig-param">dataset</em>, <em class="sig-param">cache_dir=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/dataset_parsers.html#multi_aspect_multi_sentiment_acsa"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.dataset_parsers.multi_aspect_multi_sentiment_acsa" title="Permalink to this definition">¶</a></dt>
<dd><p>The data for this function when downloaded is stored within: 
<a href="#id1"><span class="problematic" id="id2">`</span></a>Path(cache_dir, ‘Jiang 2019 MAMS ACSA’)</p>
<dl class="field-list simple">
<dt class="field-odd">NOTE</dt>
<dd class="field-odd"><p>That as each sentence/<cite>TargetText</cite> object has to have 
a <cite>text_id</cite>, as no ids exist in this dataset the ids are created 
based on when the sentence occurs in the dataset e.g. the first 
sentence/<cite>TargetText</cite> object id is ‘0’</p>
</dd>
</dl>
<p>For reference this dataset has 8 different aspect categories.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dataset</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – Either <cite>train</cite>, <cite>val</cite> or <cite>test</cite>, determines the dataset that 
is returned.</p></li>
<li><p><strong>cache_dir</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code>]) – The directory where all of the data is stored for 
this code base. If None then the cache directory is
<cite>dataset_parsers.CACHE_DIRECTORY</cite></p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#target_extraction.data_types.TargetTextCollection" title="target_extraction.data_types.TargetTextCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">TargetTextCollection</span></code></a></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The <cite>train</cite>, <cite>val</cite>, or <cite>test</cite> dataset from the 
Multi-Aspect-Multi-Sentiment dataset (MAMS) ACSA version. 
Dataset came from the <a class="reference external" href="https://www.aclweb.org/anthology/D19-1654.pdf">A Challenge Dataset and Effective Models  
for Aspect-Based Sentiment Analysis, EMNLP 2019</a></p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If the <cite>dataset</cite> value is not <cite>train</cite>, <cite>val</cite>, or <cite>test</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="target_extraction.dataset_parsers.multi_aspect_multi_sentiment_atsa">
<code class="sig-prename descclassname">target_extraction.dataset_parsers.</code><code class="sig-name descname">multi_aspect_multi_sentiment_atsa</code><span class="sig-paren">(</span><em class="sig-param">dataset</em>, <em class="sig-param">cache_dir=None</em>, <em class="sig-param">original=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/dataset_parsers.html#multi_aspect_multi_sentiment_atsa"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.dataset_parsers.multi_aspect_multi_sentiment_atsa" title="Permalink to this definition">¶</a></dt>
<dd><p>The data for this function when downloaded is stored within: 
<a href="#id3"><span class="problematic" id="id4">`</span></a>Path(cache_dir, ‘Jiang 2019 MAMS ATSA’)</p>
<dl class="field-list simple">
<dt class="field-odd">NOTE</dt>
<dd class="field-odd"><p>That as each sentence/<cite>TargetText</cite> object has to have 
a <cite>text_id</cite>, as no ids exist in this dataset the ids are created 
based on when the sentence occurs in the dataset e.g. the first 
sentence/<cite>TargetText</cite> object id is ‘0’</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>dataset</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – Either <cite>train</cite>, <cite>val</cite> or <cite>test</cite>, determines the dataset that 
is returned.</p></li>
<li><p><strong>cache_dir</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code>]) – The directory where all of the data is stored for 
this code base. If None then the cache directory is
<cite>dataset_parsers.CACHE_DIRECTORY</cite></p></li>
<li><p><strong>original</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – This does not affect <cite>val</cite> or <cite>test</cite>. If True then it will 
download the original training data from the <a class="reference external" href="https://www.aclweb.org/anthology/D19-1654.pdf">original paper</a> . Else 
it will download the cleaned Training dataset version. The 
cleaned version only contains a few sample differences 
but these differences are with respect to overlapping 
targets. See this <a class="reference external" href="https://github.com/apmoore1/target-extraction/blob/master/tutorials/Difference_between_MAMS_ATSA_original_and_MAMS_ATSA_cleaned.ipynb">notebook for full differences</a>:</p></li>
</ul>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#target_extraction.data_types.TargetTextCollection" title="target_extraction.data_types.TargetTextCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">TargetTextCollection</span></code></a></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>The <cite>train</cite>, <cite>val</cite>, or <cite>test</cite> dataset from the 
Multi-Aspect-Multi-Sentiment dataset (MAMS) ATSA version. 
Dataset came from the <a class="reference external" href="https://www.aclweb.org/anthology/D19-1654.pdf">A Challenge Dataset and Effective Models  
for Aspect-Based Sentiment Analysis, EMNLP 2019</a></p>
</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the <cite>dataset</cite> value is not <cite>train</cite>, <cite>val</cite>, or <cite>test</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="target_extraction.dataset_parsers.semeval_2014">
<code class="sig-prename descclassname">target_extraction.dataset_parsers.</code><code class="sig-name descname">semeval_2014</code><span class="sig-paren">(</span><em class="sig-param">data_fp</em>, <em class="sig-param">conflict</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/dataset_parsers.html#semeval_2014"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.dataset_parsers.semeval_2014" title="Permalink to this definition">¶</a></dt>
<dd><p>The sentiment labels are the following: 1. negative, 2. neutral, 
3. positive, and 4. conflict. conflict will not appear if the argument 
<cite>conflict</cite> is False.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data_fp</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code>) – Path to the SemEval 2014 formatted file.</p></li>
<li><p><strong>conflict</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – Whether or not to include targets or categories that 
have the <cite>conflict</cite> sentiment value. True is to include 
conflict targets and categories.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#target_extraction.data_types.TargetTextCollection" title="target_extraction.data_types.TargetTextCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">TargetTextCollection</span></code></a></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The SemEval 2014 data formatted into a 
<cite>target_extraction.data_types.TargetTextCollection</cite> object.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>SyntaxError</strong> – If the File passed is detected as not a SemEval 
formatted file.</p></li>
<li><p><strong>xml.etree.ElementTree.ParseError</strong> – If the File passed is 
not formatted correctly e.g. 
mismatched tags</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="target_extraction.dataset_parsers.semeval_2016">
<code class="sig-prename descclassname">target_extraction.dataset_parsers.</code><code class="sig-name descname">semeval_2016</code><span class="sig-paren">(</span><em class="sig-param">data_fp</em>, <em class="sig-param">conflict</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/dataset_parsers.html#semeval_2016"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.dataset_parsers.semeval_2016" title="Permalink to this definition">¶</a></dt>
<dd><p>This is only for subtask 1 files where the review is broken down into 
sentences. Furthermore if the data contains targets and not just categories 
the targets and category sentiments are linked and are all stored in the 
<cite>targets_sentiments</cite> further as some of the datasets only contain category 
information to make it the same across domains the sentiment values here 
will always be in the targets_sentiments field.</p>
<p>The sentiment labels are the following: 1. negative, 2. neutral, 
3. positive, and 4. conflict. conflict will not appear if the argument 
<cite>conflict</cite> is False.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data_fp</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code>) – Path to the SemEval 2016 formatted file.</p></li>
<li><p><strong>conflict</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – Whether or not to include targets and categories that 
have the <cite>conflict</cite> sentiment value. True is to include 
conflict targets and categories.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#target_extraction.data_types.TargetTextCollection" title="target_extraction.data_types.TargetTextCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">TargetTextCollection</span></code></a></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The SemEval 2016 data formatted into a 
<cite>target_extraction.data_types.TargetTextCollection</cite> object.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>SyntaxError</strong> – If the File passed is detected as not a SemEval 
formatted file.</p></li>
<li><p><strong>xml.etree.ElementTree.ParseError</strong> – If the File passed is 
not formatted correctly e.g. 
mismatched tags</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="target_extraction.dataset_parsers.wang_2017_election_twitter_test">
<code class="sig-prename descclassname">target_extraction.dataset_parsers.</code><code class="sig-name descname">wang_2017_election_twitter_test</code><span class="sig-paren">(</span><em class="sig-param">cache_dir=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/dataset_parsers.html#wang_2017_election_twitter_test"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.dataset_parsers.wang_2017_election_twitter_test" title="Permalink to this definition">¶</a></dt>
<dd><p>The data for this function when downloaded is stored within: 
<cite>Path(cache_dir, ‘Wang 2017 Election Twitter’)</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>cache_dir</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code>]) – The directory where all of the data is stored for 
this code base. If None then the cache directory is
<cite>dataset_parsers.CACHE_DIRECTORY</cite></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#target_extraction.data_types.TargetTextCollection" title="target_extraction.data_types.TargetTextCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">TargetTextCollection</span></code></a></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p>The Test dataset of the Election Twitter dataset by 
<cite>Wang et al, 2017 &lt;https://www.aclweb.org/anthology/E17-1046&gt;</cite> 
that can be found 
<a class="reference external" href="https://figshare.com/articles/EACL_2017_-_Multi-target_UK_election_Twitter_sentiment_corpus/4479563/1">here</a></p>
</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>FileNotFoundError</strong> – If not all of files where downloaded the first 
time. Will require the user to delete either 
the cache directory or the 
<cite>Wang 2017 Election Twitter</cite> folder within the 
cache directory.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="target_extraction.dataset_parsers.wang_2017_election_twitter_train">
<code class="sig-prename descclassname">target_extraction.dataset_parsers.</code><code class="sig-name descname">wang_2017_election_twitter_train</code><span class="sig-paren">(</span><em class="sig-param">cache_dir=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/dataset_parsers.html#wang_2017_election_twitter_train"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.dataset_parsers.wang_2017_election_twitter_train" title="Permalink to this definition">¶</a></dt>
<dd><p>The data for this function when downloaded is stored within: 
<cite>Path(cache_dir, ‘Wang 2017 Election Twitter’)</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>cache_dir</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code>]) – The directory where all of the data is stored for 
this code base. If None then the cache directory is
<cite>dataset_parsers.CACHE_DIRECTORY</cite></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#target_extraction.data_types.TargetTextCollection" title="target_extraction.data_types.TargetTextCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">TargetTextCollection</span></code></a></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p>The Training dataset of the Election Twitter dataset by 
<cite>Wang et al, 2017 &lt;https://www.aclweb.org/anthology/E17-1046&gt;</cite> 
that can be found 
<a class="reference external" href="https://figshare.com/articles/EACL_2017_-_Multi-target_UK_election_Twitter_sentiment_corpus/4479563/1">here</a></p>
</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>FileNotFoundError</strong> – If not all of files where downloaded the first 
time. Will require the user to delete either 
the cache directory or the 
<cite>Wang 2017 Election Twitter</cite> folder within the 
cache directory.</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-target_extraction.pos_taggers">
<span id="target-extraction-pos-taggers-module"></span><h2>target_extraction.pos_taggers module<a class="headerlink" href="#module-target_extraction.pos_taggers" title="Permalink to this headline">¶</a></h2>
<p>This modules contains a set of functions that return pos tagger functions 
which can be defined by the following typing: 
Callable[[str], Tuple[List[str], List[str]]]. 
All of the functions take exactly no positional arguments but can take 
keyword arguments.</p>
<p>All of the functions take in a String and perform tokenisation and POS tagging 
at the same time and return both as a List of Strings where the first List 
are the tokens and the second the POS tags.</p>
<p>Functions:</p>
<ol class="arabic simple">
<li><p>stanford – Returns both UPOS and XPOS tags where UPOS is the default. 
Stanford Neural Network POS tagger. Tagger has the option to have been 
trained on different languages and treebanks.</p></li>
<li><p>spacy – Returns both UPOS and XPOS tags where UPOS is the default. 
Spacy Neural Network POS tagger. Tagger has the option to have been trained 
on different languages.</p></li>
</ol>
<dl class="function">
<dt id="target_extraction.pos_taggers.spacy_tagger">
<code class="sig-prename descclassname">target_extraction.pos_taggers.</code><code class="sig-name descname">spacy_tagger</code><span class="sig-paren">(</span><em class="sig-param">fine=False</em>, <em class="sig-param">spacy_model_name='en_core_web_sm'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/pos_taggers.html#spacy_tagger"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.pos_taggers.spacy_tagger" title="Permalink to this definition">¶</a></dt>
<dd><p>Spacy Neural Network POS tagger which returns both UPOS and XPOS tags.</p>
<p>Choice of two different POS tags:
1. UPOS - Universal POS tags, coarse grained POS tags.
2. XPOS - Target language fine grained POS tags.</p>
<p>The XPOS for English I think is Penn Treebank set.</p>
<p>If the whitespace between two words is more than one token then the Spacy 
tagger tags it as a space, however we remove these tags.</p>
<p>Languages supported: 
<a class="reference external" href="https://spacy.io/usage/models">https://spacy.io/usage/models</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fine</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – If True then returns XPOS else returns UPOS tags.</p></li>
<li><p><strong>spacy_model_name</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – Name of the Spacy model e.g. en_core_web_sm</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-data docutils literal notranslate"><span class="pre">Callable</span></code>[[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>], <code class="xref py py-class docutils literal notranslate"><span class="pre">Tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>], <code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]]]</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A callable that takes a String and returns the tokens and  
associated POS tags for that String.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="target_extraction.pos_taggers.stanford">
<code class="sig-prename descclassname">target_extraction.pos_taggers.</code><code class="sig-name descname">stanford</code><span class="sig-paren">(</span><em class="sig-param">fine=False</em>, <em class="sig-param">lang='en'</em>, <em class="sig-param">treebank=None</em>, <em class="sig-param">download=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/pos_taggers.html#stanford"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.pos_taggers.stanford" title="Permalink to this definition">¶</a></dt>
<dd><p>Stanford Neural Network (NN) tagger that uses a highway BiLSTM that has as 
input: 1. Word2Vec and FastText embeddings, 2. Trainable Word Vector, and 
3. Uni-Directional LSTM over character embeddings. The UPOS predicted tag 
is used as a feature to predict the XPOS tag within the NN.</p>
<p>Choice of two different POS tags:
1. UPOS - Universal POS tags, coarse grained POS tags.
2. XPOS - Target language fine grained POS tags.</p>
<p>The XPOS for English I think is Penn Treebank set.</p>
<p>ASSUMPTIONS: The returned callable pos tagger will assume that all text 
that is given to it, is one sentence, as this method performs sentence 
splitting but we assume each text is one sentence and we ignore the 
sentence splitting.</p>
<p>Languages supported: 
<a class="reference external" href="https://stanfordnlp.github.io/stanfordnlp/installation_download.html#human">https://stanfordnlp.github.io/stanfordnlp/installation_download.html#human</a>-
languages-supported-by-stanfordnlp</p>
<p>Reference paper:
<a class="reference external" href="https://www.aclweb.org/anthology/K18-2016">https://www.aclweb.org/anthology/K18-2016</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fine</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – If True then returns XPOS else returns UPOS tags.</p></li>
<li><p><strong>lang</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – Language of the Neural Network tokeniser</p></li>
<li><p><strong>treebank</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]) – The neural network model to use based on the treebank 
it was trained from. If not given the default treebank 
will be used. To see which is the default treebank 
and the treebanks available for each language go to:
<a class="reference external" href="https://stanfordnlp.github.io/stanfordnlp/">https://stanfordnlp.github.io/stanfordnlp/</a><a href="#id8"><span class="problematic" id="id9">installation_</span></a>
download.html#human-languages-supported-by-stanfordnlp</p></li>
<li><p><strong>download</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – If to re-download the model.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-data docutils literal notranslate"><span class="pre">Callable</span></code>[[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>], <code class="xref py py-class docutils literal notranslate"><span class="pre">Tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>], <code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]]]</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A callable that takes a String and returns the tokens and  
associated POS tags for that String.</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-target_extraction.taggers_helper">
<span id="target-extraction-taggers-helper-module"></span><h2>target_extraction.taggers_helper module<a class="headerlink" href="#module-target_extraction.taggers_helper" title="Permalink to this headline">¶</a></h2>
<p>This module contains code that will help the following modules:</p>
<ol class="arabic simple">
<li><p>tokenizers</p></li>
<li><p>pos_taggers</p></li>
</ol>
<p>Functions:</p>
<ol class="arabic simple">
<li><p>stanford_downloader - Downloads the specific Stanford NLP Neural Network 
pipeline.</p></li>
<li><p>spacy_downloader - This in affect downloads the relevant spacy model and 
loads the model with the relevant taggers e.g. POS, Parse and NER taggers 
for that spacy model which is language dependent.</p></li>
</ol>
<dl class="data">
<dt id="target_extraction.taggers_helper.LOADED_SPACY_MODELS">
<code class="sig-prename descclassname">target_extraction.taggers_helper.</code><code class="sig-name descname">LOADED_SPACY_MODELS</code><em class="property"> = {}</em><a class="headerlink" href="#target_extraction.taggers_helper.LOADED_SPACY_MODELS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="target_extraction.taggers_helper.spacy_downloader">
<code class="sig-prename descclassname">target_extraction.taggers_helper.</code><code class="sig-name descname">spacy_downloader</code><span class="sig-paren">(</span><em class="sig-param">spacy_model_name</em>, <em class="sig-param">pos_tags</em>, <em class="sig-param">parse</em>, <em class="sig-param">ner</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/taggers_helper.html#spacy_downloader"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.taggers_helper.spacy_downloader" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a copy of allennlp.common.util.get_spacy_model function. This in  
affect downloads the relevant spacy model and loads the model with the  
relevant taggers e.g. POS, Parse and NER taggers for that spacy model which  
is language dependent.</p>
<p>Spacy can have multiple trained models per language based on size.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>spacy_model_name</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – Name of the Spacy model e.g. en_core_web_sm</p></li>
<li><p><strong>pos_tags</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – Whether or not the returned Spacy model should perform 
POS tagging.</p></li>
<li><p><strong>parse</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – Whether or not the returned Spacy model should perform 
Parsing.</p></li>
<li><p><strong>ner</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – Whether or not the returned Spacy model should perform 
NER.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Language</span></code></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The relevant Spacy model.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="target_extraction.taggers_helper.stanford_downloader">
<code class="sig-prename descclassname">target_extraction.taggers_helper.</code><code class="sig-name descname">stanford_downloader</code><span class="sig-paren">(</span><em class="sig-param">lang</em>, <em class="sig-param">treebank=None</em>, <em class="sig-param">download=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/taggers_helper.html#stanford_downloader"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.taggers_helper.stanford_downloader" title="Permalink to this definition">¶</a></dt>
<dd><p>Downloads the Stanford NLP Neural Network pipelines that can be used 
for the following tagging tasks:</p>
<ol class="arabic simple">
<li><p>tokenizing</p></li>
<li><p>Multi Word Tokens (MWT)</p></li>
<li><p>POS tagging - Universal POS (UPOS) tags and depending on the language, 
language specific POS tags (XPOS)</p></li>
<li><p>Lemmatization</p></li>
<li><p>Dependency Parsing</p></li>
</ol>
<p>Each pipeline is trained per language and per treebank hence why the 
language and treebank is required as arguments. When the treebank is not 
given the default treebank is used.</p>
<p>If download is True then it will re-download the pipeline even if it 
already exists, this might be useful if a new version has come avliable.</p>
<p>Languages supported: 
<a class="reference external" href="https://stanfordnlp.github.io/stanfordnlp/installation_download.html#human">https://stanfordnlp.github.io/stanfordnlp/installation_download.html#human</a>-
languages-supported-by-stanfordnlp</p>
<p>Reference paper:
<a class="reference external" href="https://www.aclweb.org/anthology/K18-2016">https://www.aclweb.org/anthology/K18-2016</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lang</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – Language of the Neural Network Pipeline to download.</p></li>
<li><p><strong>treebank</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]) – The neural network model to use based on the treebank 
it was trained from. If not given the default treebank 
will be used. To see which is the default treebank 
and the treebanks available for each language go to:
<a class="reference external" href="https://stanfordnlp.github.io/stanfordnlp/">https://stanfordnlp.github.io/stanfordnlp/</a><a href="#id10"><span class="problematic" id="id11">installation_</span></a>
download.html#human-languages-supported-by-stanfordnlp</p></li>
<li><p><strong>download</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – If to re-download the model.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The treebank full name which this method has to resolve to it’s 
full name to find the model’s directory.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If the treebank does not exist for the given language.
Also will raise an error there is not a pipeline for 
the language given.</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-target_extraction.tokenizers">
<span id="target-extraction-tokenizers-module"></span><h2>target_extraction.tokenizers module<a class="headerlink" href="#module-target_extraction.tokenizers" title="Permalink to this headline">¶</a></h2>
<p>This modules contains a set of functions that return tokenization functions 
which can be defined by the following typing: Callable[[str], List[str]]. 
All of the functions take exactly no positional arguments but can take 
keyword arguments.</p>
<dl class="function">
<dt id="target_extraction.tokenizers.ark_twokenize">
<code class="sig-prename descclassname">target_extraction.tokenizers.</code><code class="sig-name descname">ark_twokenize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/tokenizers.html#ark_twokenize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.tokenizers.ark_twokenize" title="Permalink to this definition">¶</a></dt>
<dd><p>A Twitter tokeniser from
<a class="reference external" href="https://github.com/brendano/ark-tweet-nlp">CMU Ark</a> and relevant 
<a class="reference external" href="https://www.cs.cmu.edu/~ark/TweetNLP/gimpel+etal.acl11.pdf">paper</a></p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-data docutils literal notranslate"><span class="pre">Callable</span></code>[[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>], <code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]]</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A callable that takes a String and returns the tokens for 
that String.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="target_extraction.tokenizers.is_character_preserving">
<code class="sig-prename descclassname">target_extraction.tokenizers.</code><code class="sig-name descname">is_character_preserving</code><span class="sig-paren">(</span><em class="sig-param">original_text</em>, <em class="sig-param">text_tokens</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/tokenizers.html#is_character_preserving"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.tokenizers.is_character_preserving" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>original_text</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – Text that has been tokenized</p></li>
<li><p><strong>text_tokens</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]) – List of tokens after the text has been tokenized</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>True if the tokenized text when all characters are joined 
together is equal to the original text with all it’s 
characters joined together.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="target_extraction.tokenizers.spacy_tokenizer">
<code class="sig-prename descclassname">target_extraction.tokenizers.</code><code class="sig-name descname">spacy_tokenizer</code><span class="sig-paren">(</span><em class="sig-param">lang='en'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/tokenizers.html#spacy_tokenizer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.tokenizers.spacy_tokenizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Given optionally the language (default English) it will return the 
Spacy rule based tokeniser for that language but the function will now 
return a List of String rather than Spacy tokens.</p>
<p>If the whitespace between two words is more than one token then the Spacy 
tokenizer treat it as in affect a special space token, we remove these 
special space tokens.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>lang</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – Language of the rule based Spacy tokeniser to use.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-data docutils literal notranslate"><span class="pre">Callable</span></code>[[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>], <code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]]</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A callable that takes a String and returns the tokens for that 
String.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="target_extraction.tokenizers.stanford">
<code class="sig-prename descclassname">target_extraction.tokenizers.</code><code class="sig-name descname">stanford</code><span class="sig-paren">(</span><em class="sig-param">lang='en'</em>, <em class="sig-param">treebank=None</em>, <em class="sig-param">download=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/tokenizers.html#stanford"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.tokenizers.stanford" title="Permalink to this definition">¶</a></dt>
<dd><p>Stanford neural network tokeniser that uses a BiLSTM and CNN at the 
character and token level.</p>
<p>ASSUMPTIONS: The returned callable tokeniser will assume that all text 
that is given to it, is one sentence, as this method performs sentence 
splitting but we assume each text is one sentence and we ignore the 
sentence splitting.</p>
<p>For Vietnamese instead of characters they used syllables.</p>
<p><a class="reference external" href="https://stanfordnlp.github.io/stanfordnlp/installation_download.html#human-languages-supported-by-stanfordnlp">Languages supported</a></p>
<p><a class="reference external" href="https://www.aclweb.org/anthology/K18-2016">Reference paper</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lang</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – Language of the Neural Network tokeniser</p></li>
<li><p><strong>treebank</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]) – The neural network model to use based on the treebank 
it was trained from. If not given the default treebank 
will be used. To see which is the default treebank 
and the treebanks available for each language go to this 
<a class="reference external" href="https://stanfordnlp.github.io/stanfordnlp/models.html#human-languages-supported-by-stanfordnlp">link</a></p></li>
<li><p><strong>download</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – If to re-download the model.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-data docutils literal notranslate"><span class="pre">Callable</span></code>[[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>], <code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]]</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A callable that takes a String and returns the tokens for that 
String.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="target_extraction.tokenizers.token_index_alignment">
<code class="sig-prename descclassname">target_extraction.tokenizers.</code><code class="sig-name descname">token_index_alignment</code><span class="sig-paren">(</span><em class="sig-param">text</em>, <em class="sig-param">tokens</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/tokenizers.html#token_index_alignment"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.tokenizers.token_index_alignment" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>text</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – text that has been tokenized</p></li>
<li><p><strong>tokens</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]) – The tokens that were the output of the text and a tokenizer
(tokenizer has to be character preserving)</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<a class="reference internal" href="#target_extraction.data_types_util.Span" title="target_extraction.data_types_util.Span"><code class="xref py py-class docutils literal notranslate"><span class="pre">Span</span></code></a>]</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A list of tuples where each tuple contains two ints each 
representing the start and end index for each of the associated 
tokens given as an argument.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="target_extraction.tokenizers.whitespace">
<code class="sig-prename descclassname">target_extraction.tokenizers.</code><code class="sig-name descname">whitespace</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/target_extraction/tokenizers.html#whitespace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#target_extraction.tokenizers.whitespace" title="Permalink to this definition">¶</a></dt>
<dd><p>Standard whitespace tokeniser</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-data docutils literal notranslate"><span class="pre">Callable</span></code>[[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>], <code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]]</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A callable that takes a String and returns the tokens for that 
String.</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-target_extraction">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-target_extraction" title="Permalink to this headline">¶</a></h2>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Andrew Moore

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>